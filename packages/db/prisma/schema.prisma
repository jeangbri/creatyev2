generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  workspaces WorkspaceMember[]
  ownedWorkspaces Workspace[]
}

model Workspace {
  id        String   @id @default(uuid())
  name      String
  ownerId   String
  owner     User     @relation(fields: [ownerId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  members          WorkspaceMember[]
  instagramAccounts InstagramAccount[]
  workflowFolders  WorkflowFolder[]
  workflows        Workflow[]
  responseTemplates ResponseTemplate[]
}

model WorkspaceMember {
  id          String    @id @default(uuid())
  workspaceId String
  workspace   Workspace @relation(fields: [workspaceId], references: [id])
  userId      String
  user        User      @relation(fields: [userId], references: [id])
  role        String    // OWNER, MEMBER
  createdAt   DateTime  @default(now())

  @@unique([workspaceId, userId])
}

model InstagramAccount {
  id                   String   @id @default(uuid())
  workspaceId          String
  workspace            Workspace @relation(fields: [workspaceId], references: [id])
  igUserId             String   // unique per workspace logic handled in app code or complex constraint. But usually unique globally for a user? Let's assume unique globally for simplicity or just plain String.
  username             String
  profilePicUrl        String?
  status               String   // CONNECTED, DISCONNECTED, TOKEN_EXPIRED
  accessTokenEncrypted String
  tokenExpiresAt       DateTime?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  @@unique([workspaceId, igUserId])
}

model WorkflowFolder {
  id          String   @id @default(uuid())
  workspaceId String
  workspace   Workspace @relation(fields: [workspaceId], references: [id])
  name        String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  workflows   Workflow[]
}

model Workflow {
  id          String   @id @default(uuid())
  workspaceId String
  workspace   Workspace @relation(fields: [workspaceId], references: [id])
  folderId    String?
  folder      WorkflowFolder? @relation(fields: [folderId], references: [id])
  title       String
  description String?
  channels    Json     // ["dm","story","feed"]
  isActive    Boolean  @default(false)
  status      String   // DRAFT, PUBLISHED
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  publishedAt DateTime?
  runCount    Int      @default(0)
  lastRunAt   DateTime?

  triggers        WorkflowTrigger[]
  actions         WorkflowAction[]
  automationRuns  AutomationRun[]
}

model WorkflowTrigger {
  id          String   @id @default(uuid())
  workflowId  String
  workflow    Workflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  type        String   // DM_RECEIVED, STORY_REPLY, FEED_COMMENT
  configJson  Json
}

model WorkflowAction {
  id          String   @id @default(uuid())
  workflowId  String
  workflow    Workflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  type        String   // SEND_DM, REPLY_COMMENT
  configJson  Json
}

model ResponseTemplate {
  id          String   @id @default(uuid())
  workspaceId String
  workspace   Workspace @relation(fields: [workspaceId], references: [id])
  name        String
  body        String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model WebhookEvent {
  id              String   @id @default(uuid())
  workspaceId     String?
  platform        String   // INSTAGRAM
  eventType       String
  platformEventId String   @unique // idempotency key
  payloadJson     Json
  receivedAt      DateTime @default(now())
  signatureValid  Boolean
  processedAt     DateTime?
  processingStatus String   // PENDING, PROCESSING, DONE, ERROR
  lastError       String?
  automationRuns  AutomationRun[]
}

model AutomationRun {
  id              String   @id @default(uuid())
  workflowId      String
  workflow        Workflow @relation(fields: [workflowId], references: [id])
  webhookEventId  String
  webhookEvent    WebhookEvent @relation(fields: [webhookEventId], references: [id])
  status          String   // SUCCESS, ERROR, SKIPPED
  startedAt       DateTime @default(now())
  finishedAt      DateTime?
  correlationId   String?
  errorMessage    String?
  logs            AutomationRunLog[]
}

model AutomationRunLog {
  id        String   @id @default(uuid())
  runId     String
  run       AutomationRun @relation(fields: [runId], references: [id], onDelete: Cascade)
  ts        DateTime @default(now())
  level     String   // INFO, WARN, ERROR
  message   String
  metaJson  Json?
}
