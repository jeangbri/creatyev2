"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@supabase+storage-js@2.91.0";
exports.ids = ["vendor-chunks/@supabase+storage-js@2.91.0"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@supabase+storage-js@2.91.0/node_modules/@supabase/storage-js/dist/index.mjs":
/*!*************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@supabase+storage-js@2.91.0/node_modules/@supabase/storage-js/dist/index.mjs ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StorageAnalyticsClient: () => (/* binding */ StorageAnalyticsClient),\n/* harmony export */   StorageApiError: () => (/* binding */ StorageApiError),\n/* harmony export */   StorageClient: () => (/* binding */ StorageClient),\n/* harmony export */   StorageError: () => (/* binding */ StorageError),\n/* harmony export */   StorageUnknownError: () => (/* binding */ StorageUnknownError),\n/* harmony export */   StorageVectorsApiError: () => (/* binding */ StorageVectorsApiError),\n/* harmony export */   StorageVectorsClient: () => (/* binding */ StorageVectorsClient),\n/* harmony export */   StorageVectorsError: () => (/* binding */ StorageVectorsError),\n/* harmony export */   StorageVectorsErrorCode: () => (/* binding */ StorageVectorsErrorCode),\n/* harmony export */   StorageVectorsUnknownError: () => (/* binding */ StorageVectorsUnknownError),\n/* harmony export */   VectorBucketApi: () => (/* binding */ VectorBucketApi),\n/* harmony export */   VectorBucketScope: () => (/* binding */ VectorBucketScope),\n/* harmony export */   VectorDataApi: () => (/* binding */ VectorDataApi),\n/* harmony export */   VectorIndexApi: () => (/* binding */ VectorIndexApi),\n/* harmony export */   VectorIndexScope: () => (/* binding */ VectorIndexScope),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isStorageError: () => (/* binding */ isStorageError),\n/* harmony export */   isStorageVectorsError: () => (/* binding */ isStorageVectorsError),\n/* harmony export */   normalizeToFloat32: () => (/* binding */ normalizeToFloat32),\n/* harmony export */   resolveFetch: () => (/* binding */ resolveFetch),\n/* harmony export */   resolveResponse: () => (/* binding */ resolveResponse),\n/* harmony export */   validateVectorDimension: () => (/* binding */ validateVectorDimension)\n/* harmony export */ });\n/* harmony import */ var iceberg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! iceberg-js */ \"(ssr)/../../node_modules/.pnpm/iceberg-js@0.8.1/node_modules/iceberg-js/dist/index.mjs\");\n\n//#region src/lib/errors.ts\nvar StorageError = class extends Error {\n    constructor(message){\n        super(message);\n        this.__isStorageError = true;\n        this.name = \"StorageError\";\n    }\n};\nfunction isStorageError(error) {\n    return typeof error === \"object\" && error !== null && \"__isStorageError\" in error;\n}\nvar StorageApiError = class extends StorageError {\n    constructor(message, status, statusCode){\n        super(message);\n        this.name = \"StorageApiError\";\n        this.status = status;\n        this.statusCode = statusCode;\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            status: this.status,\n            statusCode: this.statusCode\n        };\n    }\n};\nvar StorageUnknownError = class extends StorageError {\n    constructor(message, originalError){\n        super(message);\n        this.name = \"StorageUnknownError\";\n        this.originalError = originalError;\n    }\n};\n//#endregion\n//#region src/lib/helpers.ts\nconst resolveFetch$1 = (customFetch)=>{\n    if (customFetch) return (...args)=>customFetch(...args);\n    return (...args)=>fetch(...args);\n};\nconst resolveResponse$1 = ()=>{\n    return Response;\n};\nconst recursiveToCamel = (item)=>{\n    if (Array.isArray(item)) return item.map((el)=>recursiveToCamel(el));\n    else if (typeof item === \"function\" || item !== Object(item)) return item;\n    const result = {};\n    Object.entries(item).forEach(([key, value])=>{\n        const newKey = key.replace(/([-_][a-z])/gi, (c)=>c.toUpperCase().replace(/[-_]/g, \"\"));\n        result[newKey] = recursiveToCamel(value);\n    });\n    return result;\n};\n/**\n* Determine if input is a plain object\n* An object is plain if it's created by either {}, new Object(), or Object.create(null)\n* source: https://github.com/sindresorhus/is-plain-obj\n*/ const isPlainObject$1 = (value)=>{\n    if (typeof value !== \"object\" || value === null) return false;\n    const prototype = Object.getPrototypeOf(value);\n    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n};\n/**\n* Validates if a given bucket name is valid according to Supabase Storage API rules\n* Mirrors backend validation from: storage/src/storage/limits.ts:isValidBucketName()\n*\n* Rules:\n* - Length: 1-100 characters\n* - Allowed characters: alphanumeric (a-z, A-Z, 0-9), underscore (_), and safe special characters\n* - Safe special characters: ! - . * ' ( ) space & $ @ = ; : + , ?\n* - Forbidden: path separators (/, \\), path traversal (..), leading/trailing whitespace\n*\n* AWS S3 Reference: https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html\n*\n* @param bucketName - The bucket name to validate\n* @returns true if valid, false otherwise\n*/ const isValidBucketName = (bucketName)=>{\n    if (!bucketName || typeof bucketName !== \"string\") return false;\n    if (bucketName.length === 0 || bucketName.length > 100) return false;\n    if (bucketName.trim() !== bucketName) return false;\n    if (bucketName.includes(\"/\") || bucketName.includes(\"\\\\\")) return false;\n    return /^[\\w!.\\*'() &$@=;:+,?-]+$/.test(bucketName);\n};\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/typeof.js\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o$1) {\n        return typeof o$1;\n    } : function(o$1) {\n        return o$1 && \"function\" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? \"symbol\" : typeof o$1;\n    }, _typeof(o);\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/toPrimitive.js\nfunction toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/toPropertyKey.js\nfunction toPropertyKey(t) {\n    var i = toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/defineProperty.js\nfunction _defineProperty(e, r, t) {\n    return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n        value: t,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n    }) : e[r] = t, e;\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/objectSpread2.js\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r$1) {\n            return Object.getOwnPropertyDescriptor(e, r$1).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread2(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r$1) {\n            _defineProperty(e, r$1, t[r$1]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r$1) {\n            Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));\n        });\n    }\n    return e;\n}\n//#endregion\n//#region src/lib/fetch.ts\nconst _getErrorMessage$1 = (err)=>{\n    var _err$error;\n    return err.msg || err.message || err.error_description || (typeof err.error === \"string\" ? err.error : (_err$error = err.error) === null || _err$error === void 0 ? void 0 : _err$error.message) || JSON.stringify(err);\n};\nconst handleError$1 = async (error, reject, options)=>{\n    if (error instanceof await resolveResponse$1() && !(options === null || options === void 0 ? void 0 : options.noResolveJson)) error.json().then((err)=>{\n        const status = error.status || 500;\n        const statusCode = (err === null || err === void 0 ? void 0 : err.statusCode) || status + \"\";\n        reject(new StorageApiError(_getErrorMessage$1(err), status, statusCode));\n    }).catch((err)=>{\n        reject(new StorageUnknownError(_getErrorMessage$1(err), err));\n    });\n    else reject(new StorageUnknownError(_getErrorMessage$1(error), error));\n};\nconst _getRequestParams$1 = (method, options, parameters, body)=>{\n    const params = {\n        method,\n        headers: (options === null || options === void 0 ? void 0 : options.headers) || {}\n    };\n    if (method === \"GET\" || !body) return params;\n    if (isPlainObject$1(body)) {\n        params.headers = _objectSpread2({\n            \"Content-Type\": \"application/json\"\n        }, options === null || options === void 0 ? void 0 : options.headers);\n        params.body = JSON.stringify(body);\n    } else params.body = body;\n    if (options === null || options === void 0 ? void 0 : options.duplex) params.duplex = options.duplex;\n    return _objectSpread2(_objectSpread2({}, params), parameters);\n};\nasync function _handleRequest$1(fetcher, method, url, options, parameters, body) {\n    return new Promise((resolve, reject)=>{\n        fetcher(url, _getRequestParams$1(method, options, parameters, body)).then((result)=>{\n            if (!result.ok) throw result;\n            if (options === null || options === void 0 ? void 0 : options.noResolveJson) return result;\n            return result.json();\n        }).then((data)=>resolve(data)).catch((error)=>handleError$1(error, reject, options));\n    });\n}\nasync function get(fetcher, url, options, parameters) {\n    return _handleRequest$1(fetcher, \"GET\", url, options, parameters);\n}\nasync function post$1(fetcher, url, body, options, parameters) {\n    return _handleRequest$1(fetcher, \"POST\", url, options, parameters, body);\n}\nasync function put(fetcher, url, body, options, parameters) {\n    return _handleRequest$1(fetcher, \"PUT\", url, options, parameters, body);\n}\nasync function head(fetcher, url, options, parameters) {\n    return _handleRequest$1(fetcher, \"HEAD\", url, _objectSpread2(_objectSpread2({}, options), {}, {\n        noResolveJson: true\n    }), parameters);\n}\nasync function remove(fetcher, url, body, options, parameters) {\n    return _handleRequest$1(fetcher, \"DELETE\", url, options, parameters, body);\n}\n//#endregion\n//#region src/packages/StreamDownloadBuilder.ts\nvar StreamDownloadBuilder = class {\n    constructor(downloadFn, shouldThrowOnError){\n        this.downloadFn = downloadFn;\n        this.shouldThrowOnError = shouldThrowOnError;\n    }\n    then(onfulfilled, onrejected) {\n        return this.execute().then(onfulfilled, onrejected);\n    }\n    async execute() {\n        var _this = this;\n        try {\n            return {\n                data: (await _this.downloadFn()).body,\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n};\n//#endregion\n//#region src/packages/BlobDownloadBuilder.ts\nlet _Symbol$toStringTag;\n_Symbol$toStringTag = Symbol.toStringTag;\nvar BlobDownloadBuilder = class {\n    constructor(downloadFn, shouldThrowOnError){\n        this.downloadFn = downloadFn;\n        this.shouldThrowOnError = shouldThrowOnError;\n        this[_Symbol$toStringTag] = \"BlobDownloadBuilder\";\n        this.promise = null;\n    }\n    asStream() {\n        return new StreamDownloadBuilder(this.downloadFn, this.shouldThrowOnError);\n    }\n    then(onfulfilled, onrejected) {\n        return this.getPromise().then(onfulfilled, onrejected);\n    }\n    catch(onrejected) {\n        return this.getPromise().catch(onrejected);\n    }\n    finally(onfinally) {\n        return this.getPromise().finally(onfinally);\n    }\n    getPromise() {\n        if (!this.promise) this.promise = this.execute();\n        return this.promise;\n    }\n    async execute() {\n        var _this = this;\n        try {\n            return {\n                data: await (await _this.downloadFn()).blob(),\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n};\n//#endregion\n//#region src/packages/StorageFileApi.ts\nconst DEFAULT_SEARCH_OPTIONS = {\n    limit: 100,\n    offset: 0,\n    sortBy: {\n        column: \"name\",\n        order: \"asc\"\n    }\n};\nconst DEFAULT_FILE_OPTIONS = {\n    cacheControl: \"3600\",\n    contentType: \"text/plain;charset=UTF-8\",\n    upsert: false\n};\nvar StorageFileApi = class {\n    constructor(url, headers = {}, bucketId, fetch$1){\n        this.shouldThrowOnError = false;\n        this.url = url;\n        this.headers = headers;\n        this.bucketId = bucketId;\n        this.fetch = resolveFetch$1(fetch$1);\n    }\n    /**\n\t* Enable throwing errors instead of returning them.\n\t*\n\t* @category File Buckets\n\t*/ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /**\n\t* Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.\n\t*\n\t* @param method HTTP method.\n\t* @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n\t* @param fileBody The body of the file to be stored in the bucket.\n\t*/ async uploadOrUpdate(method, path, fileBody, fileOptions) {\n        var _this = this;\n        try {\n            let body;\n            const options = _objectSpread2(_objectSpread2({}, DEFAULT_FILE_OPTIONS), fileOptions);\n            let headers = _objectSpread2(_objectSpread2({}, _this.headers), method === \"POST\" && {\n                \"x-upsert\": String(options.upsert)\n            });\n            const metadata = options.metadata;\n            if (typeof Blob !== \"undefined\" && fileBody instanceof Blob) {\n                body = new FormData();\n                body.append(\"cacheControl\", options.cacheControl);\n                if (metadata) body.append(\"metadata\", _this.encodeMetadata(metadata));\n                body.append(\"\", fileBody);\n            } else if (typeof FormData !== \"undefined\" && fileBody instanceof FormData) {\n                body = fileBody;\n                if (!body.has(\"cacheControl\")) body.append(\"cacheControl\", options.cacheControl);\n                if (metadata && !body.has(\"metadata\")) body.append(\"metadata\", _this.encodeMetadata(metadata));\n            } else {\n                body = fileBody;\n                headers[\"cache-control\"] = `max-age=${options.cacheControl}`;\n                headers[\"content-type\"] = options.contentType;\n                if (metadata) headers[\"x-metadata\"] = _this.toBase64(_this.encodeMetadata(metadata));\n                if ((typeof ReadableStream !== \"undefined\" && body instanceof ReadableStream || body && typeof body === \"object\" && \"pipe\" in body && typeof body.pipe === \"function\") && !options.duplex) options.duplex = \"half\";\n            }\n            if (fileOptions === null || fileOptions === void 0 ? void 0 : fileOptions.headers) headers = _objectSpread2(_objectSpread2({}, headers), fileOptions.headers);\n            const cleanPath = _this._removeEmptyFolders(path);\n            const _path = _this._getFinalPath(cleanPath);\n            const data = await (method == \"PUT\" ? put : post$1)(_this.fetch, `${_this.url}/object/${_path}`, body, _objectSpread2({\n                headers\n            }, (options === null || options === void 0 ? void 0 : options.duplex) ? {\n                duplex: options.duplex\n            } : {}));\n            return {\n                data: {\n                    path: cleanPath,\n                    id: data.Id,\n                    fullPath: data.Key\n                },\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Uploads a file to an existing bucket.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n\t* @param fileBody The body of the file to be stored in the bucket.\n\t* @param fileOptions Optional file upload options including cacheControl, contentType, upsert, and metadata.\n\t* @returns Promise with response containing file path, id, and fullPath or error\n\t*\n\t* @example Upload file\n\t* ```js\n\t* const avatarFile = event.target.files[0]\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .upload('public/avatar1.png', avatarFile, {\n\t*     cacheControl: '3600',\n\t*     upsert: false\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"path\": \"public/avatar1.png\",\n\t*     \"fullPath\": \"avatars/public/avatar1.png\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*\n\t* @example Upload file using `ArrayBuffer` from base64 file data\n\t* ```js\n\t* import { decode } from 'base64-arraybuffer'\n\t*\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .upload('public/avatar1.png', decode('base64FileData'), {\n\t*     contentType: 'image/png'\n\t*   })\n\t* ```\n\t*/ async upload(path, fileBody, fileOptions) {\n        return this.uploadOrUpdate(\"POST\", path, fileBody, fileOptions);\n    }\n    /**\n\t* Upload a file with a token generated from `createSignedUploadUrl`.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n\t* @param token The token generated from `createSignedUploadUrl`\n\t* @param fileBody The body of the file to be stored in the bucket.\n\t* @param fileOptions HTTP headers (cacheControl, contentType, etc.).\n\t* **Note:** The `upsert` option has no effect here. To enable upsert behavior,\n\t* pass `{ upsert: true }` when calling `createSignedUploadUrl()` instead.\n\t* @returns Promise with response containing file path and fullPath or error\n\t*\n\t* @example Upload to a signed URL\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .uploadToSignedUrl('folder/cat.jpg', 'token-from-createSignedUploadUrl', file)\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"path\": \"folder/cat.jpg\",\n\t*     \"fullPath\": \"avatars/folder/cat.jpg\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async uploadToSignedUrl(path, token, fileBody, fileOptions) {\n        var _this3 = this;\n        const cleanPath = _this3._removeEmptyFolders(path);\n        const _path = _this3._getFinalPath(cleanPath);\n        const url = new URL(_this3.url + `/object/upload/sign/${_path}`);\n        url.searchParams.set(\"token\", token);\n        try {\n            let body;\n            const options = _objectSpread2({\n                upsert: DEFAULT_FILE_OPTIONS.upsert\n            }, fileOptions);\n            const headers = _objectSpread2(_objectSpread2({}, _this3.headers), {\n                \"x-upsert\": String(options.upsert)\n            });\n            if (typeof Blob !== \"undefined\" && fileBody instanceof Blob) {\n                body = new FormData();\n                body.append(\"cacheControl\", options.cacheControl);\n                body.append(\"\", fileBody);\n            } else if (typeof FormData !== \"undefined\" && fileBody instanceof FormData) {\n                body = fileBody;\n                body.append(\"cacheControl\", options.cacheControl);\n            } else {\n                body = fileBody;\n                headers[\"cache-control\"] = `max-age=${options.cacheControl}`;\n                headers[\"content-type\"] = options.contentType;\n            }\n            return {\n                data: {\n                    path: cleanPath,\n                    fullPath: (await put(_this3.fetch, url.toString(), body, {\n                        headers\n                    })).Key\n                },\n                error: null\n            };\n        } catch (error) {\n            if (_this3.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Creates a signed upload URL.\n\t* Signed upload URLs can be used to upload files to the bucket without further authentication.\n\t* They are valid for 2 hours.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the current file name. For example `folder/image.png`.\n\t* @param options.upsert If set to true, allows the file to be overwritten if it already exists.\n\t* @returns Promise with response containing signed upload URL, token, and path or error\n\t*\n\t* @example Create Signed Upload URL\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .createSignedUploadUrl('folder/cat.jpg')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"signedUrl\": \"https://example.supabase.co/storage/v1/object/upload/sign/avatars/folder/cat.jpg?token=<TOKEN>\",\n\t*     \"path\": \"folder/cat.jpg\",\n\t*     \"token\": \"<TOKEN>\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async createSignedUploadUrl(path, options) {\n        var _this4 = this;\n        try {\n            let _path = _this4._getFinalPath(path);\n            const headers = _objectSpread2({}, _this4.headers);\n            if (options === null || options === void 0 ? void 0 : options.upsert) headers[\"x-upsert\"] = \"true\";\n            const data = await post$1(_this4.fetch, `${_this4.url}/object/upload/sign/${_path}`, {}, {\n                headers\n            });\n            const url = new URL(_this4.url + data.url);\n            const token = url.searchParams.get(\"token\");\n            if (!token) throw new StorageError(\"No token returned by API\");\n            return {\n                data: {\n                    signedUrl: url.toString(),\n                    path,\n                    token\n                },\n                error: null\n            };\n        } catch (error) {\n            if (_this4.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Replaces an existing file at the specified path with a new one.\n\t*\n\t* @category File Buckets\n\t* @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.\n\t* @param fileBody The body of the file to be stored in the bucket.\n\t* @param fileOptions Optional file upload options including cacheControl, contentType, upsert, and metadata.\n\t* @returns Promise with response containing file path, id, and fullPath or error\n\t*\n\t* @example Update file\n\t* ```js\n\t* const avatarFile = event.target.files[0]\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .update('public/avatar1.png', avatarFile, {\n\t*     cacheControl: '3600',\n\t*     upsert: true\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"path\": \"public/avatar1.png\",\n\t*     \"fullPath\": \"avatars/public/avatar1.png\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*\n\t* @example Update file using `ArrayBuffer` from base64 file data\n\t* ```js\n\t* import {decode} from 'base64-arraybuffer'\n\t*\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .update('public/avatar1.png', decode('base64FileData'), {\n\t*     contentType: 'image/png'\n\t*   })\n\t* ```\n\t*/ async update(path, fileBody, fileOptions) {\n        return this.uploadOrUpdate(\"PUT\", path, fileBody, fileOptions);\n    }\n    /**\n\t* Moves an existing file to a new path in the same bucket.\n\t*\n\t* @category File Buckets\n\t* @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n\t* @param toPath The new file path, including the new file name. For example `folder/image-new.png`.\n\t* @param options The destination options.\n\t* @returns Promise with response containing success message or error\n\t*\n\t* @example Move file\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .move('public/avatar1.png', 'private/avatar2.png')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"message\": \"Successfully moved\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async move(fromPath, toPath, options) {\n        var _this6 = this;\n        try {\n            return {\n                data: await post$1(_this6.fetch, `${_this6.url}/object/move`, {\n                    bucketId: _this6.bucketId,\n                    sourceKey: fromPath,\n                    destinationKey: toPath,\n                    destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket\n                }, {\n                    headers: _this6.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this6.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Copies an existing file to a new path in the same bucket.\n\t*\n\t* @category File Buckets\n\t* @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n\t* @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.\n\t* @param options The destination options.\n\t* @returns Promise with response containing copied file path or error\n\t*\n\t* @example Copy file\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .copy('public/avatar1.png', 'private/avatar2.png')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"path\": \"avatars/private/avatar2.png\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async copy(fromPath, toPath, options) {\n        var _this7 = this;\n        try {\n            return {\n                data: {\n                    path: (await post$1(_this7.fetch, `${_this7.url}/object/copy`, {\n                        bucketId: _this7.bucketId,\n                        sourceKey: fromPath,\n                        destinationKey: toPath,\n                        destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket\n                    }, {\n                        headers: _this7.headers\n                    })).Key\n                },\n                error: null\n            };\n        } catch (error) {\n            if (_this7.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the current file name. For example `folder/image.png`.\n\t* @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.\n\t* @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n\t* @param options.transform Transform the asset before serving it to the client.\n\t* @returns Promise with response containing signed URL or error\n\t*\n\t* @example Create Signed URL\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .createSignedUrl('folder/avatar1.png', 60)\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"signedUrl\": \"https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar1.png?token=<TOKEN>\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*\n\t* @example Create a signed URL for an asset with transformations\n\t* ```js\n\t* const { data } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .createSignedUrl('folder/avatar1.png', 60, {\n\t*     transform: {\n\t*       width: 100,\n\t*       height: 100,\n\t*     }\n\t*   })\n\t* ```\n\t*\n\t* @example Create a signed URL which triggers the download of the asset\n\t* ```js\n\t* const { data } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .createSignedUrl('folder/avatar1.png', 60, {\n\t*     download: true,\n\t*   })\n\t* ```\n\t*/ async createSignedUrl(path, expiresIn, options) {\n        var _this8 = this;\n        try {\n            let _path = _this8._getFinalPath(path);\n            let data = await post$1(_this8.fetch, `${_this8.url}/object/sign/${_path}`, _objectSpread2({\n                expiresIn\n            }, (options === null || options === void 0 ? void 0 : options.transform) ? {\n                transform: options.transform\n            } : {}), {\n                headers: _this8.headers\n            });\n            const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? \"\" : options.download}` : \"\";\n            data = {\n                signedUrl: encodeURI(`${_this8.url}${data.signedURL}${downloadQueryParam}`)\n            };\n            return {\n                data,\n                error: null\n            };\n        } catch (error) {\n            if (_this8.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.\n\t*\n\t* @category File Buckets\n\t* @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.\n\t* @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.\n\t* @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n\t* @returns Promise with response containing array of objects with signedUrl, path, and error or error\n\t*\n\t* @example Create Signed URLs\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .createSignedUrls(['folder/avatar1.png', 'folder/avatar2.png'], 60)\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": [\n\t*     {\n\t*       \"error\": null,\n\t*       \"path\": \"folder/avatar1.png\",\n\t*       \"signedURL\": \"/object/sign/avatars/folder/avatar1.png?token=<TOKEN>\",\n\t*       \"signedUrl\": \"https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar1.png?token=<TOKEN>\"\n\t*     },\n\t*     {\n\t*       \"error\": null,\n\t*       \"path\": \"folder/avatar2.png\",\n\t*       \"signedURL\": \"/object/sign/avatars/folder/avatar2.png?token=<TOKEN>\",\n\t*       \"signedUrl\": \"https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar2.png?token=<TOKEN>\"\n\t*     }\n\t*   ],\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async createSignedUrls(paths, expiresIn, options) {\n        var _this9 = this;\n        try {\n            const data = await post$1(_this9.fetch, `${_this9.url}/object/sign/${_this9.bucketId}`, {\n                expiresIn,\n                paths\n            }, {\n                headers: _this9.headers\n            });\n            const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? \"\" : options.download}` : \"\";\n            return {\n                data: data.map((datum)=>_objectSpread2(_objectSpread2({}, datum), {}, {\n                        signedUrl: datum.signedURL ? encodeURI(`${_this9.url}${datum.signedURL}${downloadQueryParam}`) : null\n                    })),\n                error: null\n            };\n        } catch (error) {\n            if (_this9.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Downloads a file from a private bucket. For public buckets, make a request to the URL returned from `getPublicUrl` instead.\n\t*\n\t* @category File Buckets\n\t* @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.\n\t* @param options.transform Transform the asset before serving it to the client.\n\t* @returns BlobDownloadBuilder instance for downloading the file\n\t*\n\t* @example Download file\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .download('folder/avatar1.png')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": <BLOB>,\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*\n\t* @example Download file with transformations\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .download('folder/avatar1.png', {\n\t*     transform: {\n\t*       width: 100,\n\t*       height: 100,\n\t*       quality: 80\n\t*     }\n\t*   })\n\t* ```\n\t*/ download(path, options) {\n        const renderPath = typeof (options === null || options === void 0 ? void 0 : options.transform) !== \"undefined\" ? \"render/image/authenticated\" : \"object\";\n        const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});\n        const queryString = transformationQuery ? `?${transformationQuery}` : \"\";\n        const _path = this._getFinalPath(path);\n        const downloadFn = ()=>get(this.fetch, `${this.url}/${renderPath}/${_path}${queryString}`, {\n                headers: this.headers,\n                noResolveJson: true\n            });\n        return new BlobDownloadBuilder(downloadFn, this.shouldThrowOnError);\n    }\n    /**\n\t* Retrieves the details of an existing file.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the file name. For example `folder/image.png`.\n\t* @returns Promise with response containing file metadata or error\n\t*\n\t* @example Get file info\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .info('folder/avatar1.png')\n\t* ```\n\t*/ async info(path) {\n        var _this10 = this;\n        const _path = _this10._getFinalPath(path);\n        try {\n            return {\n                data: recursiveToCamel(await get(_this10.fetch, `${_this10.url}/object/info/${_path}`, {\n                    headers: _this10.headers\n                })),\n                error: null\n            };\n        } catch (error) {\n            if (_this10.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Checks the existence of a file.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the file name. For example `folder/image.png`.\n\t* @returns Promise with response containing boolean indicating file existence or error\n\t*\n\t* @example Check file existence\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .exists('folder/avatar1.png')\n\t* ```\n\t*/ async exists(path) {\n        var _this11 = this;\n        const _path = _this11._getFinalPath(path);\n        try {\n            await head(_this11.fetch, `${_this11.url}/object/${_path}`, {\n                headers: _this11.headers\n            });\n            return {\n                data: true,\n                error: null\n            };\n        } catch (error) {\n            if (_this11.shouldThrowOnError) throw error;\n            if (isStorageError(error) && error instanceof StorageUnknownError) {\n                const originalError = error.originalError;\n                if ([\n                    400,\n                    404\n                ].includes(originalError === null || originalError === void 0 ? void 0 : originalError.status)) return {\n                    data: false,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n\t* A simple convenience function to get the URL for an asset in a public bucket. If you do not want to use this function, you can construct the public URL by concatenating the bucket URL with the path to the asset.\n\t* This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.\n\t*\n\t* @category File Buckets\n\t* @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.\n\t* @param options.download Triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n\t* @param options.transform Transform the asset before serving it to the client.\n\t* @returns Object with public URL\n\t*\n\t* @example Returns the URL for an asset in a public bucket\n\t* ```js\n\t* const { data } = supabase\n\t*   .storage\n\t*   .from('public-bucket')\n\t*   .getPublicUrl('folder/avatar1.png')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"publicUrl\": \"https://example.supabase.co/storage/v1/object/public/public-bucket/folder/avatar1.png\"\n\t*   }\n\t* }\n\t* ```\n\t*\n\t* @example Returns the URL for an asset in a public bucket with transformations\n\t* ```js\n\t* const { data } = supabase\n\t*   .storage\n\t*   .from('public-bucket')\n\t*   .getPublicUrl('folder/avatar1.png', {\n\t*     transform: {\n\t*       width: 100,\n\t*       height: 100,\n\t*     }\n\t*   })\n\t* ```\n\t*\n\t* @example Returns the URL which triggers the download of an asset in a public bucket\n\t* ```js\n\t* const { data } = supabase\n\t*   .storage\n\t*   .from('public-bucket')\n\t*   .getPublicUrl('folder/avatar1.png', {\n\t*     download: true,\n\t*   })\n\t* ```\n\t*/ getPublicUrl(path, options) {\n        const _path = this._getFinalPath(path);\n        const _queryString = [];\n        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `download=${options.download === true ? \"\" : options.download}` : \"\";\n        if (downloadQueryParam !== \"\") _queryString.push(downloadQueryParam);\n        const renderPath = typeof (options === null || options === void 0 ? void 0 : options.transform) !== \"undefined\" ? \"render/image\" : \"object\";\n        const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});\n        if (transformationQuery !== \"\") _queryString.push(transformationQuery);\n        let queryString = _queryString.join(\"&\");\n        if (queryString !== \"\") queryString = `?${queryString}`;\n        return {\n            data: {\n                publicUrl: encodeURI(`${this.url}/${renderPath}/public/${_path}${queryString}`)\n            }\n        };\n    }\n    /**\n\t* Deletes files within the same bucket\n\t*\n\t* @category File Buckets\n\t* @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].\n\t* @returns Promise with response containing array of deleted file objects or error\n\t*\n\t* @example Delete file\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .remove(['folder/avatar1.png'])\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": [],\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async remove(paths) {\n        var _this12 = this;\n        try {\n            return {\n                data: await remove(_this12.fetch, `${_this12.url}/object/${_this12.bucketId}`, {\n                    prefixes: paths\n                }, {\n                    headers: _this12.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this12.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Get file metadata\n\t* @param id the file id to retrieve metadata\n\t*/ /**\n\t* Update file metadata\n\t* @param id the file id to update metadata\n\t* @param meta the new file metadata\n\t*/ /**\n\t* Lists all the files and folders within a path of the bucket.\n\t*\n\t* @category File Buckets\n\t* @param path The folder path.\n\t* @param options Search options including limit (defaults to 100), offset, sortBy, and search\n\t* @param parameters Optional fetch parameters including signal for cancellation\n\t* @returns Promise with response containing array of files or error\n\t*\n\t* @example List files in a bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .list('folder', {\n\t*     limit: 100,\n\t*     offset: 0,\n\t*     sortBy: { column: 'name', order: 'asc' },\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": [\n\t*     {\n\t*       \"name\": \"avatar1.png\",\n\t*       \"id\": \"e668cf7f-821b-4a2f-9dce-7dfa5dd1cfd2\",\n\t*       \"updated_at\": \"2024-05-22T23:06:05.580Z\",\n\t*       \"created_at\": \"2024-05-22T23:04:34.443Z\",\n\t*       \"last_accessed_at\": \"2024-05-22T23:04:34.443Z\",\n\t*       \"metadata\": {\n\t*         \"eTag\": \"\\\"c5e8c553235d9af30ef4f6e280790b92\\\"\",\n\t*         \"size\": 32175,\n\t*         \"mimetype\": \"image/png\",\n\t*         \"cacheControl\": \"max-age=3600\",\n\t*         \"lastModified\": \"2024-05-22T23:06:05.574Z\",\n\t*         \"contentLength\": 32175,\n\t*         \"httpStatusCode\": 200\n\t*       }\n\t*     }\n\t*   ],\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*\n\t* @example Search files in a bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .list('folder', {\n\t*     limit: 100,\n\t*     offset: 0,\n\t*     sortBy: { column: 'name', order: 'asc' },\n\t*     search: 'jon'\n\t*   })\n\t* ```\n\t*/ async list(path, options, parameters) {\n        var _this13 = this;\n        try {\n            const body = _objectSpread2(_objectSpread2(_objectSpread2({}, DEFAULT_SEARCH_OPTIONS), options), {}, {\n                prefix: path || \"\"\n            });\n            return {\n                data: await post$1(_this13.fetch, `${_this13.url}/object/list/${_this13.bucketId}`, body, {\n                    headers: _this13.headers\n                }, parameters),\n                error: null\n            };\n        } catch (error) {\n            if (_this13.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* @experimental this method signature might change in the future\n\t*\n\t* @category File Buckets\n\t* @param options search options\n\t* @param parameters\n\t*/ async listV2(options, parameters) {\n        var _this14 = this;\n        try {\n            const body = _objectSpread2({}, options);\n            return {\n                data: await post$1(_this14.fetch, `${_this14.url}/object/list-v2/${_this14.bucketId}`, body, {\n                    headers: _this14.headers\n                }, parameters),\n                error: null\n            };\n        } catch (error) {\n            if (_this14.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    encodeMetadata(metadata) {\n        return JSON.stringify(metadata);\n    }\n    toBase64(data) {\n        if (typeof Buffer !== \"undefined\") return Buffer.from(data).toString(\"base64\");\n        return btoa(data);\n    }\n    _getFinalPath(path) {\n        return `${this.bucketId}/${path.replace(/^\\/+/, \"\")}`;\n    }\n    _removeEmptyFolders(path) {\n        return path.replace(/^\\/|\\/$/g, \"\").replace(/\\/+/g, \"/\");\n    }\n    transformOptsToQueryString(transform) {\n        const params = [];\n        if (transform.width) params.push(`width=${transform.width}`);\n        if (transform.height) params.push(`height=${transform.height}`);\n        if (transform.resize) params.push(`resize=${transform.resize}`);\n        if (transform.format) params.push(`format=${transform.format}`);\n        if (transform.quality) params.push(`quality=${transform.quality}`);\n        return params.join(\"&\");\n    }\n};\n//#endregion\n//#region src/lib/version.ts\nconst version = \"2.91.0\";\n//#endregion\n//#region src/lib/constants.ts\nconst DEFAULT_HEADERS$1 = {\n    \"X-Client-Info\": `storage-js/${version}`\n};\n//#endregion\n//#region src/packages/StorageBucketApi.ts\nvar StorageBucketApi = class {\n    constructor(url, headers = {}, fetch$1, opts){\n        this.shouldThrowOnError = false;\n        const baseUrl = new URL(url);\n        if (opts === null || opts === void 0 ? void 0 : opts.useNewHostname) {\n            if (/supabase\\.(co|in|red)$/.test(baseUrl.hostname) && !baseUrl.hostname.includes(\"storage.supabase.\")) baseUrl.hostname = baseUrl.hostname.replace(\"supabase.\", \"storage.supabase.\");\n        }\n        this.url = baseUrl.href.replace(/\\/$/, \"\");\n        this.headers = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS$1), headers);\n        this.fetch = resolveFetch$1(fetch$1);\n    }\n    /**\n\t* Enable throwing errors instead of returning them.\n\t*\n\t* @category File Buckets\n\t*/ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /**\n\t* Retrieves the details of all Storage buckets within an existing project.\n\t*\n\t* @category File Buckets\n\t* @param options Query parameters for listing buckets\n\t* @param options.limit Maximum number of buckets to return\n\t* @param options.offset Number of buckets to skip\n\t* @param options.sortColumn Column to sort by ('id', 'name', 'created_at', 'updated_at')\n\t* @param options.sortOrder Sort order ('asc' or 'desc')\n\t* @param options.search Search term to filter bucket names\n\t* @returns Promise with response containing array of buckets or error\n\t*\n\t* @example List buckets\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .listBuckets()\n\t* ```\n\t*\n\t* @example List buckets with options\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .listBuckets({\n\t*     limit: 10,\n\t*     offset: 0,\n\t*     sortColumn: 'created_at',\n\t*     sortOrder: 'desc',\n\t*     search: 'prod'\n\t*   })\n\t* ```\n\t*/ async listBuckets(options) {\n        var _this = this;\n        try {\n            const queryString = _this.listBucketOptionsToQueryString(options);\n            return {\n                data: await get(_this.fetch, `${_this.url}/bucket${queryString}`, {\n                    headers: _this.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Retrieves the details of an existing Storage bucket.\n\t*\n\t* @category File Buckets\n\t* @param id The unique identifier of the bucket you would like to retrieve.\n\t* @returns Promise with response containing bucket details or error\n\t*\n\t* @example Get bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .getBucket('avatars')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"id\": \"avatars\",\n\t*     \"name\": \"avatars\",\n\t*     \"owner\": \"\",\n\t*     \"public\": false,\n\t*     \"file_size_limit\": 1024,\n\t*     \"allowed_mime_types\": [\n\t*       \"image/png\"\n\t*     ],\n\t*     \"created_at\": \"2024-05-22T22:26:05.100Z\",\n\t*     \"updated_at\": \"2024-05-22T22:26:05.100Z\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async getBucket(id) {\n        var _this2 = this;\n        try {\n            return {\n                data: await get(_this2.fetch, `${_this2.url}/bucket/${id}`, {\n                    headers: _this2.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this2.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Creates a new Storage bucket\n\t*\n\t* @category File Buckets\n\t* @param id A unique identifier for the bucket you are creating.\n\t* @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.\n\t* @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n\t* The global file size limit takes precedence over this value.\n\t* The default value is null, which doesn't set a per bucket file size limit.\n\t* @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n\t* The default value is null, which allows files with all mime types to be uploaded.\n\t* Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n\t* @param options.type (private-beta) specifies the bucket type. see `BucketType` for more details.\n\t*   - default bucket type is `STANDARD`\n\t* @returns Promise with response containing newly created bucket name or error\n\t*\n\t* @example Create bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .createBucket('avatars', {\n\t*     public: false,\n\t*     allowedMimeTypes: ['image/png'],\n\t*     fileSizeLimit: 1024\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"name\": \"avatars\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async createBucket(id, options = {\n        public: false\n    }) {\n        var _this3 = this;\n        try {\n            return {\n                data: await post$1(_this3.fetch, `${_this3.url}/bucket`, {\n                    id,\n                    name: id,\n                    type: options.type,\n                    public: options.public,\n                    file_size_limit: options.fileSizeLimit,\n                    allowed_mime_types: options.allowedMimeTypes\n                }, {\n                    headers: _this3.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this3.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Updates a Storage bucket\n\t*\n\t* @category File Buckets\n\t* @param id A unique identifier for the bucket you are updating.\n\t* @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.\n\t* @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n\t* The global file size limit takes precedence over this value.\n\t* The default value is null, which doesn't set a per bucket file size limit.\n\t* @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n\t* The default value is null, which allows files with all mime types to be uploaded.\n\t* Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n\t* @returns Promise with response containing success message or error\n\t*\n\t* @example Update bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .updateBucket('avatars', {\n\t*     public: false,\n\t*     allowedMimeTypes: ['image/png'],\n\t*     fileSizeLimit: 1024\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"message\": \"Successfully updated\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async updateBucket(id, options) {\n        var _this4 = this;\n        try {\n            return {\n                data: await put(_this4.fetch, `${_this4.url}/bucket/${id}`, {\n                    id,\n                    name: id,\n                    public: options.public,\n                    file_size_limit: options.fileSizeLimit,\n                    allowed_mime_types: options.allowedMimeTypes\n                }, {\n                    headers: _this4.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this4.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Removes all objects inside a single bucket.\n\t*\n\t* @category File Buckets\n\t* @param id The unique identifier of the bucket you would like to empty.\n\t* @returns Promise with success message or error\n\t*\n\t* @example Empty bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .emptyBucket('avatars')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"message\": \"Successfully emptied\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async emptyBucket(id) {\n        var _this5 = this;\n        try {\n            return {\n                data: await post$1(_this5.fetch, `${_this5.url}/bucket/${id}/empty`, {}, {\n                    headers: _this5.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this5.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.\n\t* You must first `empty()` the bucket.\n\t*\n\t* @category File Buckets\n\t* @param id The unique identifier of the bucket you would like to delete.\n\t* @returns Promise with success message or error\n\t*\n\t* @example Delete bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .deleteBucket('avatars')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"message\": \"Successfully deleted\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async deleteBucket(id) {\n        var _this6 = this;\n        try {\n            return {\n                data: await remove(_this6.fetch, `${_this6.url}/bucket/${id}`, {}, {\n                    headers: _this6.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this6.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    listBucketOptionsToQueryString(options) {\n        const params = {};\n        if (options) {\n            if (\"limit\" in options) params.limit = String(options.limit);\n            if (\"offset\" in options) params.offset = String(options.offset);\n            if (options.search) params.search = options.search;\n            if (options.sortColumn) params.sortColumn = options.sortColumn;\n            if (options.sortOrder) params.sortOrder = options.sortOrder;\n        }\n        return Object.keys(params).length > 0 ? \"?\" + new URLSearchParams(params).toString() : \"\";\n    }\n};\n//#endregion\n//#region src/packages/StorageAnalyticsClient.ts\n/**\n* Client class for managing Analytics Buckets using Iceberg tables\n* Provides methods for creating, listing, and deleting analytics buckets\n*/ var StorageAnalyticsClient = class {\n    /**\n\t* @alpha\n\t*\n\t* Creates a new StorageAnalyticsClient instance\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @param url - The base URL for the storage API\n\t* @param headers - HTTP headers to include in requests\n\t* @param fetch - Optional custom fetch implementation\n\t*\n\t* @example\n\t* ```typescript\n\t* const client = new StorageAnalyticsClient(url, headers)\n\t* ```\n\t*/ constructor(url, headers = {}, fetch$1){\n        this.shouldThrowOnError = false;\n        this.url = url.replace(/\\/$/, \"\");\n        this.headers = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS$1), headers);\n        this.fetch = resolveFetch$1(fetch$1);\n    }\n    /**\n\t* @alpha\n\t*\n\t* Enable throwing errors instead of returning them in the response\n\t* When enabled, failed operations will throw instead of returning { data: null, error }\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @returns This instance for method chaining\n\t*/ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /**\n\t* @alpha\n\t*\n\t* Creates a new analytics bucket using Iceberg tables\n\t* Analytics buckets are optimized for analytical queries and data processing\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @param name A unique name for the bucket you are creating\n\t* @returns Promise with response containing newly created analytics bucket or error\n\t*\n\t* @example Create analytics bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .analytics\n\t*   .createBucket('analytics-data')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"name\": \"analytics-data\",\n\t*     \"type\": \"ANALYTICS\",\n\t*     \"format\": \"iceberg\",\n\t*     \"created_at\": \"2024-05-22T22:26:05.100Z\",\n\t*     \"updated_at\": \"2024-05-22T22:26:05.100Z\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async createBucket(name) {\n        var _this = this;\n        try {\n            return {\n                data: await post$1(_this.fetch, `${_this.url}/bucket`, {\n                    name\n                }, {\n                    headers: _this.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* @alpha\n\t*\n\t* Retrieves the details of all Analytics Storage buckets within an existing project\n\t* Only returns buckets of type 'ANALYTICS'\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @param options Query parameters for listing buckets\n\t* @param options.limit Maximum number of buckets to return\n\t* @param options.offset Number of buckets to skip\n\t* @param options.sortColumn Column to sort by ('name', 'created_at', 'updated_at')\n\t* @param options.sortOrder Sort order ('asc' or 'desc')\n\t* @param options.search Search term to filter bucket names\n\t* @returns Promise with response containing array of analytics buckets or error\n\t*\n\t* @example List analytics buckets\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .analytics\n\t*   .listBuckets({\n\t*     limit: 10,\n\t*     offset: 0,\n\t*     sortColumn: 'created_at',\n\t*     sortOrder: 'desc'\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": [\n\t*     {\n\t*       \"name\": \"analytics-data\",\n\t*       \"type\": \"ANALYTICS\",\n\t*       \"format\": \"iceberg\",\n\t*       \"created_at\": \"2024-05-22T22:26:05.100Z\",\n\t*       \"updated_at\": \"2024-05-22T22:26:05.100Z\"\n\t*     }\n\t*   ],\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async listBuckets(options) {\n        var _this2 = this;\n        try {\n            const queryParams = new URLSearchParams();\n            if ((options === null || options === void 0 ? void 0 : options.limit) !== void 0) queryParams.set(\"limit\", options.limit.toString());\n            if ((options === null || options === void 0 ? void 0 : options.offset) !== void 0) queryParams.set(\"offset\", options.offset.toString());\n            if (options === null || options === void 0 ? void 0 : options.sortColumn) queryParams.set(\"sortColumn\", options.sortColumn);\n            if (options === null || options === void 0 ? void 0 : options.sortOrder) queryParams.set(\"sortOrder\", options.sortOrder);\n            if (options === null || options === void 0 ? void 0 : options.search) queryParams.set(\"search\", options.search);\n            const queryString = queryParams.toString();\n            const url = queryString ? `${_this2.url}/bucket?${queryString}` : `${_this2.url}/bucket`;\n            return {\n                data: await get(_this2.fetch, url, {\n                    headers: _this2.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this2.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* @alpha\n\t*\n\t* Deletes an existing analytics bucket\n\t* A bucket can't be deleted with existing objects inside it\n\t* You must first empty the bucket before deletion\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @param bucketName The unique identifier of the bucket you would like to delete\n\t* @returns Promise with response containing success message or error\n\t*\n\t* @example Delete analytics bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .analytics\n\t*   .deleteBucket('analytics-data')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"message\": \"Successfully deleted\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async deleteBucket(bucketName) {\n        var _this3 = this;\n        try {\n            return {\n                data: await remove(_this3.fetch, `${_this3.url}/bucket/${bucketName}`, {}, {\n                    headers: _this3.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this3.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* @alpha\n\t*\n\t* Get an Iceberg REST Catalog client configured for a specific analytics bucket\n\t* Use this to perform advanced table and namespace operations within the bucket\n\t* The returned client provides full access to the Apache Iceberg REST Catalog API\n\t* with the Supabase `{ data, error }` pattern for consistent error handling on all operations.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @param bucketName - The name of the analytics bucket (warehouse) to connect to\n\t* @returns The wrapped Iceberg catalog client\n\t* @throws {StorageError} If the bucket name is invalid\n\t*\n\t* @example Get catalog and create table\n\t* ```js\n\t* // First, create an analytics bucket\n\t* const { data: bucket, error: bucketError } = await supabase\n\t*   .storage\n\t*   .analytics\n\t*   .createBucket('analytics-data')\n\t*\n\t* // Get the Iceberg catalog for that bucket\n\t* const catalog = supabase.storage.analytics.from('analytics-data')\n\t*\n\t* // Create a namespace\n\t* const { error: nsError } = await catalog.createNamespace({ namespace: ['default'] })\n\t*\n\t* // Create a table with schema\n\t* const { data: tableMetadata, error: tableError } = await catalog.createTable(\n\t*   { namespace: ['default'] },\n\t*   {\n\t*     name: 'events',\n\t*     schema: {\n\t*       type: 'struct',\n\t*       fields: [\n\t*         { id: 1, name: 'id', type: 'long', required: true },\n\t*         { id: 2, name: 'timestamp', type: 'timestamp', required: true },\n\t*         { id: 3, name: 'user_id', type: 'string', required: false }\n\t*       ],\n\t*       'schema-id': 0,\n\t*       'identifier-field-ids': [1]\n\t*     },\n\t*     'partition-spec': {\n\t*       'spec-id': 0,\n\t*       fields: []\n\t*     },\n\t*     'write-order': {\n\t*       'order-id': 0,\n\t*       fields: []\n\t*     },\n\t*     properties: {\n\t*       'write.format.default': 'parquet'\n\t*     }\n\t*   }\n\t* )\n\t* ```\n\t*\n\t* @example List tables in namespace\n\t* ```js\n\t* const catalog = supabase.storage.analytics.from('analytics-data')\n\t*\n\t* // List all tables in the default namespace\n\t* const { data: tables, error: listError } = await catalog.listTables({ namespace: ['default'] })\n\t* if (listError) {\n\t*   if (listError.isNotFound()) {\n\t*     console.log('Namespace not found')\n\t*   }\n\t*   return\n\t* }\n\t* console.log(tables) // [{ namespace: ['default'], name: 'events' }]\n\t* ```\n\t*\n\t* @example Working with namespaces\n\t* ```js\n\t* const catalog = supabase.storage.analytics.from('analytics-data')\n\t*\n\t* // List all namespaces\n\t* const { data: namespaces } = await catalog.listNamespaces()\n\t*\n\t* // Create namespace with properties\n\t* await catalog.createNamespace(\n\t*   { namespace: ['production'] },\n\t*   { properties: { owner: 'data-team', env: 'prod' } }\n\t* )\n\t* ```\n\t*\n\t* @example Cleanup operations\n\t* ```js\n\t* const catalog = supabase.storage.analytics.from('analytics-data')\n\t*\n\t* // Drop table with purge option (removes all data)\n\t* const { error: dropError } = await catalog.dropTable(\n\t*   { namespace: ['default'], name: 'events' },\n\t*   { purge: true }\n\t* )\n\t*\n\t* if (dropError?.isNotFound()) {\n\t*   console.log('Table does not exist')\n\t* }\n\t*\n\t* // Drop namespace (must be empty)\n\t* await catalog.dropNamespace({ namespace: ['default'] })\n\t* ```\n\t*\n\t* @remarks\n\t* This method provides a bridge between Supabase's bucket management and the standard\n\t* Apache Iceberg REST Catalog API. The bucket name maps to the Iceberg warehouse parameter.\n\t* All authentication and configuration is handled automatically using your Supabase credentials.\n\t*\n\t* **Error Handling**: Invalid bucket names throw immediately. All catalog\n\t* operations return `{ data, error }` where errors are `IcebergError` instances from iceberg-js.\n\t* Use helper methods like `error.isNotFound()` or check `error.status` for specific error handling.\n\t* Use `.throwOnError()` on the analytics client if you prefer exceptions for catalog operations.\n\t*\n\t* **Cleanup Operations**: When using `dropTable`, the `purge: true` option permanently\n\t* deletes all table data. Without it, the table is marked as deleted but data remains.\n\t*\n\t* **Library Dependency**: The returned catalog wraps `IcebergRestCatalog` from iceberg-js.\n\t* For complete API documentation and advanced usage, refer to the\n\t* [iceberg-js documentation](https://supabase.github.io/iceberg-js/).\n\t*/ from(bucketName) {\n        var _this4 = this;\n        if (!isValidBucketName(bucketName)) throw new StorageError(\"Invalid bucket name: File, folder, and bucket names must follow AWS object key naming guidelines and should avoid the use of any other characters.\");\n        const catalog = new iceberg_js__WEBPACK_IMPORTED_MODULE_0__.IcebergRestCatalog({\n            baseUrl: this.url,\n            catalogName: bucketName,\n            auth: {\n                type: \"custom\",\n                getHeaders: async ()=>_this4.headers\n            },\n            fetch: this.fetch\n        });\n        const shouldThrowOnError = this.shouldThrowOnError;\n        return new Proxy(catalog, {\n            get (target, prop) {\n                const value = target[prop];\n                if (typeof value !== \"function\") return value;\n                return async (...args)=>{\n                    try {\n                        return {\n                            data: await value.apply(target, args),\n                            error: null\n                        };\n                    } catch (error) {\n                        if (shouldThrowOnError) throw error;\n                        return {\n                            data: null,\n                            error\n                        };\n                    }\n                };\n            }\n        });\n    }\n};\n//#endregion\n//#region src/lib/vectors/constants.ts\nconst DEFAULT_HEADERS = {\n    \"X-Client-Info\": `storage-js/${version}`,\n    \"Content-Type\": \"application/json\"\n};\n//#endregion\n//#region src/lib/vectors/errors.ts\n/**\n* Base error class for all Storage Vectors errors\n*/ var StorageVectorsError = class extends Error {\n    constructor(message){\n        super(message);\n        this.__isStorageVectorsError = true;\n        this.name = \"StorageVectorsError\";\n    }\n};\n/**\n* Type guard to check if an error is a StorageVectorsError\n* @param error - The error to check\n* @returns True if the error is a StorageVectorsError\n*/ function isStorageVectorsError(error) {\n    return typeof error === \"object\" && error !== null && \"__isStorageVectorsError\" in error;\n}\n/**\n* API error returned from S3 Vectors service\n* Includes HTTP status code and service-specific error code\n*/ var StorageVectorsApiError = class extends StorageVectorsError {\n    constructor(message, status, statusCode){\n        super(message);\n        this.name = \"StorageVectorsApiError\";\n        this.status = status;\n        this.statusCode = statusCode;\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            status: this.status,\n            statusCode: this.statusCode\n        };\n    }\n};\n/**\n* Unknown error that doesn't match expected error patterns\n* Wraps the original error for debugging\n*/ var StorageVectorsUnknownError = class extends StorageVectorsError {\n    constructor(message, originalError){\n        super(message);\n        this.name = \"StorageVectorsUnknownError\";\n        this.originalError = originalError;\n    }\n};\n/**\n* Error codes specific to S3 Vectors API\n* Maps AWS service errors to application-friendly error codes\n*/ let StorageVectorsErrorCode = /* @__PURE__ */ function(StorageVectorsErrorCode$1) {\n    /** Internal server fault (HTTP 500) */ StorageVectorsErrorCode$1[\"InternalError\"] = \"InternalError\";\n    /** Resource already exists / conflict (HTTP 409) */ StorageVectorsErrorCode$1[\"S3VectorConflictException\"] = \"S3VectorConflictException\";\n    /** Resource not found (HTTP 404) */ StorageVectorsErrorCode$1[\"S3VectorNotFoundException\"] = \"S3VectorNotFoundException\";\n    /** Delete bucket while not empty (HTTP 400) */ StorageVectorsErrorCode$1[\"S3VectorBucketNotEmpty\"] = \"S3VectorBucketNotEmpty\";\n    /** Exceeds bucket quota/limit (HTTP 400) */ StorageVectorsErrorCode$1[\"S3VectorMaxBucketsExceeded\"] = \"S3VectorMaxBucketsExceeded\";\n    /** Exceeds index quota/limit (HTTP 400) */ StorageVectorsErrorCode$1[\"S3VectorMaxIndexesExceeded\"] = \"S3VectorMaxIndexesExceeded\";\n    return StorageVectorsErrorCode$1;\n}({});\n//#endregion\n//#region src/lib/vectors/helpers.ts\n/**\n* Resolves the fetch implementation to use\n* Uses custom fetch if provided, otherwise uses native fetch\n*\n* @param customFetch - Optional custom fetch implementation\n* @returns Resolved fetch function\n*/ const resolveFetch = (customFetch)=>{\n    if (customFetch) return (...args)=>customFetch(...args);\n    return (...args)=>fetch(...args);\n};\n/**\n* Resolves the Response constructor to use\n* Returns native Response constructor\n*\n* @returns Response constructor\n*/ const resolveResponse = ()=>{\n    return Response;\n};\n/**\n* Determine if input is a plain object\n* An object is plain if it's created by either {}, new Object(), or Object.create(null)\n*\n* @param value - Value to check\n* @returns True if value is a plain object\n* @source https://github.com/sindresorhus/is-plain-obj\n*/ const isPlainObject = (value)=>{\n    if (typeof value !== \"object\" || value === null) return false;\n    const prototype = Object.getPrototypeOf(value);\n    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n};\n/**\n* Normalizes a number array to float32 format\n* Ensures all vector values are valid 32-bit floats\n*\n* @param values - Array of numbers to normalize\n* @returns Normalized float32 array\n*/ const normalizeToFloat32 = (values)=>{\n    return Array.from(new Float32Array(values));\n};\n/**\n* Validates vector dimensions match expected dimension\n* Throws error if dimensions don't match\n*\n* @param vector - Vector data to validate\n* @param expectedDimension - Expected vector dimension\n* @throws Error if dimensions don't match\n*/ const validateVectorDimension = (vector, expectedDimension)=>{\n    if (expectedDimension !== void 0 && vector.float32.length !== expectedDimension) throw new Error(`Vector dimension mismatch: expected ${expectedDimension}, got ${vector.float32.length}`);\n};\n//#endregion\n//#region src/lib/vectors/fetch.ts\n/**\n* Extracts error message from various error response formats\n* @param err - Error object from API\n* @returns Human-readable error message\n*/ const _getErrorMessage = (err)=>err.msg || err.message || err.error_description || err.error || JSON.stringify(err);\n/**\n* Handles fetch errors and converts them to StorageVectors error types\n* @param error - The error caught from fetch\n* @param reject - Promise rejection function\n* @param options - Fetch options that may affect error handling\n*/ const handleError = async (error, reject, options)=>{\n    if (error && typeof error === \"object\" && \"status\" in error && \"ok\" in error && typeof error.status === \"number\" && !(options === null || options === void 0 ? void 0 : options.noResolveJson)) {\n        const status = error.status || 500;\n        const responseError = error;\n        if (typeof responseError.json === \"function\") responseError.json().then((err)=>{\n            const statusCode = (err === null || err === void 0 ? void 0 : err.statusCode) || (err === null || err === void 0 ? void 0 : err.code) || status + \"\";\n            reject(new StorageVectorsApiError(_getErrorMessage(err), status, statusCode));\n        }).catch(()=>{\n            const statusCode = status + \"\";\n            reject(new StorageVectorsApiError(responseError.statusText || `HTTP ${status} error`, status, statusCode));\n        });\n        else {\n            const statusCode = status + \"\";\n            reject(new StorageVectorsApiError(responseError.statusText || `HTTP ${status} error`, status, statusCode));\n        }\n    } else reject(new StorageVectorsUnknownError(_getErrorMessage(error), error));\n};\n/**\n* Builds request parameters for fetch calls\n* @param method - HTTP method\n* @param options - Custom fetch options\n* @param parameters - Additional fetch parameters like AbortSignal\n* @param body - Request body (will be JSON stringified if plain object)\n* @returns Complete fetch request parameters\n*/ const _getRequestParams = (method, options, parameters, body)=>{\n    const params = {\n        method,\n        headers: (options === null || options === void 0 ? void 0 : options.headers) || {}\n    };\n    if (method === \"GET\" || !body) return params;\n    if (isPlainObject(body)) {\n        params.headers = _objectSpread2({\n            \"Content-Type\": \"application/json\"\n        }, options === null || options === void 0 ? void 0 : options.headers);\n        params.body = JSON.stringify(body);\n    } else params.body = body;\n    return _objectSpread2(_objectSpread2({}, params), parameters);\n};\n/**\n* Internal request handler that wraps fetch with error handling\n* @param fetcher - Fetch function to use\n* @param method - HTTP method\n* @param url - Request URL\n* @param options - Custom fetch options\n* @param parameters - Additional fetch parameters\n* @param body - Request body\n* @returns Promise with parsed response or error\n*/ async function _handleRequest(fetcher, method, url, options, parameters, body) {\n    return new Promise((resolve, reject)=>{\n        fetcher(url, _getRequestParams(method, options, parameters, body)).then((result)=>{\n            if (!result.ok) throw result;\n            if (options === null || options === void 0 ? void 0 : options.noResolveJson) return result;\n            const contentType = result.headers.get(\"content-type\");\n            if (!contentType || !contentType.includes(\"application/json\")) return {};\n            return result.json();\n        }).then((data)=>resolve(data)).catch((error)=>handleError(error, reject, options));\n    });\n}\n/**\n* Performs a POST request\n* @param fetcher - Fetch function to use\n* @param url - Request URL\n* @param body - Request body to be JSON stringified\n* @param options - Custom fetch options\n* @param parameters - Additional fetch parameters\n* @returns Promise with parsed response\n*/ async function post(fetcher, url, body, options, parameters) {\n    return _handleRequest(fetcher, \"POST\", url, options, parameters, body);\n}\n//#endregion\n//#region src/lib/vectors/VectorIndexApi.ts\n/**\n* @hidden\n* Base implementation for vector index operations.\n* Use {@link VectorBucketScope} via `supabase.storage.vectors.from('bucket')` instead.\n*/ var VectorIndexApi = class {\n    /** Creates a new VectorIndexApi instance */ constructor(url, headers = {}, fetch$1){\n        this.shouldThrowOnError = false;\n        this.url = url.replace(/\\/$/, \"\");\n        this.headers = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS), headers);\n        this.fetch = resolveFetch(fetch$1);\n    }\n    /** Enable throwing errors instead of returning them in the response */ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /** Creates a new vector index within a bucket */ async createIndex(options) {\n        var _this = this;\n        try {\n            return {\n                data: await post(_this.fetch, `${_this.url}/CreateIndex`, options, {\n                    headers: _this.headers\n                }) || {},\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Retrieves metadata for a specific vector index */ async getIndex(vectorBucketName, indexName) {\n        var _this2 = this;\n        try {\n            return {\n                data: await post(_this2.fetch, `${_this2.url}/GetIndex`, {\n                    vectorBucketName,\n                    indexName\n                }, {\n                    headers: _this2.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this2.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Lists vector indexes within a bucket with optional filtering and pagination */ async listIndexes(options) {\n        var _this3 = this;\n        try {\n            return {\n                data: await post(_this3.fetch, `${_this3.url}/ListIndexes`, options, {\n                    headers: _this3.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this3.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Deletes a vector index and all its data */ async deleteIndex(vectorBucketName, indexName) {\n        var _this4 = this;\n        try {\n            return {\n                data: await post(_this4.fetch, `${_this4.url}/DeleteIndex`, {\n                    vectorBucketName,\n                    indexName\n                }, {\n                    headers: _this4.headers\n                }) || {},\n                error: null\n            };\n        } catch (error) {\n            if (_this4.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n};\n//#endregion\n//#region src/lib/vectors/VectorDataApi.ts\n/**\n* @hidden\n* Base implementation for vector data operations.\n* Use {@link VectorIndexScope} via `supabase.storage.vectors.from('bucket').index('idx')` instead.\n*/ var VectorDataApi = class {\n    /** Creates a new VectorDataApi instance */ constructor(url, headers = {}, fetch$1){\n        this.shouldThrowOnError = false;\n        this.url = url.replace(/\\/$/, \"\");\n        this.headers = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS), headers);\n        this.fetch = resolveFetch(fetch$1);\n    }\n    /** Enable throwing errors instead of returning them in the response */ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /** Inserts or updates vectors in batch (1-500 per request) */ async putVectors(options) {\n        var _this = this;\n        try {\n            if (options.vectors.length < 1 || options.vectors.length > 500) throw new Error(\"Vector batch size must be between 1 and 500 items\");\n            return {\n                data: await post(_this.fetch, `${_this.url}/PutVectors`, options, {\n                    headers: _this.headers\n                }) || {},\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Retrieves vectors by their keys in batch */ async getVectors(options) {\n        var _this2 = this;\n        try {\n            return {\n                data: await post(_this2.fetch, `${_this2.url}/GetVectors`, options, {\n                    headers: _this2.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this2.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Lists vectors in an index with pagination */ async listVectors(options) {\n        var _this3 = this;\n        try {\n            if (options.segmentCount !== void 0) {\n                if (options.segmentCount < 1 || options.segmentCount > 16) throw new Error(\"segmentCount must be between 1 and 16\");\n                if (options.segmentIndex !== void 0) {\n                    if (options.segmentIndex < 0 || options.segmentIndex >= options.segmentCount) throw new Error(`segmentIndex must be between 0 and ${options.segmentCount - 1}`);\n                }\n            }\n            return {\n                data: await post(_this3.fetch, `${_this3.url}/ListVectors`, options, {\n                    headers: _this3.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this3.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Queries for similar vectors using approximate nearest neighbor search */ async queryVectors(options) {\n        var _this4 = this;\n        try {\n            return {\n                data: await post(_this4.fetch, `${_this4.url}/QueryVectors`, options, {\n                    headers: _this4.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this4.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Deletes vectors by their keys in batch (1-500 per request) */ async deleteVectors(options) {\n        var _this5 = this;\n        try {\n            if (options.keys.length < 1 || options.keys.length > 500) throw new Error(\"Keys batch size must be between 1 and 500 items\");\n            return {\n                data: await post(_this5.fetch, `${_this5.url}/DeleteVectors`, options, {\n                    headers: _this5.headers\n                }) || {},\n                error: null\n            };\n        } catch (error) {\n            if (_this5.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n};\n//#endregion\n//#region src/lib/vectors/VectorBucketApi.ts\n/**\n* @hidden\n* Base implementation for vector bucket operations.\n* Use {@link StorageVectorsClient} via `supabase.storage.vectors` instead.\n*/ var VectorBucketApi = class {\n    /** Creates a new VectorBucketApi instance */ constructor(url, headers = {}, fetch$1){\n        this.shouldThrowOnError = false;\n        this.url = url.replace(/\\/$/, \"\");\n        this.headers = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS), headers);\n        this.fetch = resolveFetch(fetch$1);\n    }\n    /** Enable throwing errors instead of returning them in the response */ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /** Creates a new vector bucket */ async createBucket(vectorBucketName) {\n        var _this = this;\n        try {\n            return {\n                data: await post(_this.fetch, `${_this.url}/CreateVectorBucket`, {\n                    vectorBucketName\n                }, {\n                    headers: _this.headers\n                }) || {},\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Retrieves metadata for a specific vector bucket */ async getBucket(vectorBucketName) {\n        var _this2 = this;\n        try {\n            return {\n                data: await post(_this2.fetch, `${_this2.url}/GetVectorBucket`, {\n                    vectorBucketName\n                }, {\n                    headers: _this2.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this2.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Lists vector buckets with optional filtering and pagination */ async listBuckets(options = {}) {\n        var _this3 = this;\n        try {\n            return {\n                data: await post(_this3.fetch, `${_this3.url}/ListVectorBuckets`, options, {\n                    headers: _this3.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this3.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Deletes a vector bucket (must be empty first) */ async deleteBucket(vectorBucketName) {\n        var _this4 = this;\n        try {\n            return {\n                data: await post(_this4.fetch, `${_this4.url}/DeleteVectorBucket`, {\n                    vectorBucketName\n                }, {\n                    headers: _this4.headers\n                }) || {},\n                error: null\n            };\n        } catch (error) {\n            if (_this4.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n};\n//#endregion\n//#region src/lib/vectors/StorageVectorsClient.ts\n/**\n*\n* @alpha\n*\n* Main client for interacting with S3 Vectors API\n* Provides access to bucket, index, and vector data operations\n*\n* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n*\n* **Usage Patterns:**\n*\n* ```typescript\n* const { data, error } = await supabase\n*  .storage\n*  .vectors\n*  .createBucket('embeddings-prod')\n*\n* // Access index operations via buckets\n* const bucket = supabase.storage.vectors.from('embeddings-prod')\n* await bucket.createIndex({\n*   indexName: 'documents',\n*   dataType: 'float32',\n*   dimension: 1536,\n*   distanceMetric: 'cosine'\n* })\n*\n* // Access vector operations via index\n* const index = bucket.index('documents')\n* await index.putVectors({\n*   vectors: [\n*     { key: 'doc-1', data: { float32: [...] }, metadata: { title: 'Intro' } }\n*   ]\n* })\n*\n* // Query similar vectors\n* const { data } = await index.queryVectors({\n*   queryVector: { float32: [...] },\n*   topK: 5,\n*   returnDistance: true\n* })\n* ```\n*/ var StorageVectorsClient = class extends VectorBucketApi {\n    /**\n\t* @alpha\n\t*\n\t* Creates a StorageVectorsClient that can manage buckets, indexes, and vectors.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param url - Base URL of the Storage Vectors REST API.\n\t* @param options.headers - Optional headers (for example `Authorization`) applied to every request.\n\t* @param options.fetch - Optional custom `fetch` implementation for non-browser runtimes.\n\t*\n\t* @example\n\t* ```typescript\n\t* const client = new StorageVectorsClient(url, options)\n\t* ```\n\t*/ constructor(url, options = {}){\n        super(url, options.headers || {}, options.fetch);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Access operations for a specific vector bucket\n\t* Returns a scoped client for index and vector operations within the bucket\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param vectorBucketName - Name of the vector bucket\n\t* @returns Bucket-scoped client with index and vector operations\n\t*\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* ```\n\t*/ from(vectorBucketName) {\n        return new VectorBucketScope(this.url, this.headers, vectorBucketName, this.fetch);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Creates a new vector bucket\n\t* Vector buckets are containers for vector indexes and their data\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param vectorBucketName - Unique name for the vector bucket\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .vectors\n\t*   .createBucket('embeddings-prod')\n\t* ```\n\t*/ async createBucket(vectorBucketName) {\n        var _superprop_getCreateBucket = ()=>super.createBucket, _this = this;\n        return _superprop_getCreateBucket().call(_this, vectorBucketName);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Retrieves metadata for a specific vector bucket\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param vectorBucketName - Name of the vector bucket\n\t* @returns Promise with bucket metadata or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .vectors\n\t*   .getBucket('embeddings-prod')\n\t*\n\t* console.log('Bucket created:', data?.vectorBucket.creationTime)\n\t* ```\n\t*/ async getBucket(vectorBucketName) {\n        var _superprop_getGetBucket = ()=>super.getBucket, _this2 = this;\n        return _superprop_getGetBucket().call(_this2, vectorBucketName);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Lists all vector buckets with optional filtering and pagination\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Optional filters (prefix, maxResults, nextToken)\n\t* @returns Promise with list of buckets or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .vectors\n\t*   .listBuckets({ prefix: 'embeddings-' })\n\t*\n\t* data?.vectorBuckets.forEach(bucket => {\n\t*   console.log(bucket.vectorBucketName)\n\t* })\n\t* ```\n\t*/ async listBuckets(options = {}) {\n        var _superprop_getListBuckets = ()=>super.listBuckets, _this3 = this;\n        return _superprop_getListBuckets().call(_this3, options);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Deletes a vector bucket (bucket must be empty)\n\t* All indexes must be deleted before deleting the bucket\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param vectorBucketName - Name of the vector bucket to delete\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .vectors\n\t*   .deleteBucket('embeddings-old')\n\t* ```\n\t*/ async deleteBucket(vectorBucketName) {\n        var _superprop_getDeleteBucket = ()=>super.deleteBucket, _this4 = this;\n        return _superprop_getDeleteBucket().call(_this4, vectorBucketName);\n    }\n};\n/**\n*\n* @alpha\n*\n* Scoped client for operations within a specific vector bucket\n* Provides index management and access to vector operations\n*\n* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n*/ var VectorBucketScope = class extends VectorIndexApi {\n    /**\n\t* @alpha\n\t*\n\t* Creates a helper that automatically scopes all index operations to the provided bucket.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* ```\n\t*/ constructor(url, headers, vectorBucketName, fetch$1){\n        super(url, headers, fetch$1);\n        this.vectorBucketName = vectorBucketName;\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Creates a new vector index in this bucket\n\t* Convenience method that automatically includes the bucket name\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Index configuration (vectorBucketName is automatically set)\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* await bucket.createIndex({\n\t*   indexName: 'documents-openai',\n\t*   dataType: 'float32',\n\t*   dimension: 1536,\n\t*   distanceMetric: 'cosine',\n\t*   metadataConfiguration: {\n\t*     nonFilterableMetadataKeys: ['raw_text']\n\t*   }\n\t* })\n\t* ```\n\t*/ async createIndex(options) {\n        var _superprop_getCreateIndex = ()=>super.createIndex, _this5 = this;\n        return _superprop_getCreateIndex().call(_this5, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this5.vectorBucketName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Lists indexes in this bucket\n\t* Convenience method that automatically includes the bucket name\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Listing options (vectorBucketName is automatically set)\n\t* @returns Promise with response containing indexes array and pagination token or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* const { data } = await bucket.listIndexes({ prefix: 'documents-' })\n\t* ```\n\t*/ async listIndexes(options = {}) {\n        var _superprop_getListIndexes = ()=>super.listIndexes, _this6 = this;\n        return _superprop_getListIndexes().call(_this6, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this6.vectorBucketName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Retrieves metadata for a specific index in this bucket\n\t* Convenience method that automatically includes the bucket name\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param indexName - Name of the index to retrieve\n\t* @returns Promise with index metadata or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* const { data } = await bucket.getIndex('documents-openai')\n\t* console.log('Dimension:', data?.index.dimension)\n\t* ```\n\t*/ async getIndex(indexName) {\n        var _superprop_getGetIndex = ()=>super.getIndex, _this7 = this;\n        return _superprop_getGetIndex().call(_this7, _this7.vectorBucketName, indexName);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Deletes an index from this bucket\n\t* Convenience method that automatically includes the bucket name\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param indexName - Name of the index to delete\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* await bucket.deleteIndex('old-index')\n\t* ```\n\t*/ async deleteIndex(indexName) {\n        var _superprop_getDeleteIndex = ()=>super.deleteIndex, _this8 = this;\n        return _superprop_getDeleteIndex().call(_this8, _this8.vectorBucketName, indexName);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Access operations for a specific index within this bucket\n\t* Returns a scoped client for vector data operations\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param indexName - Name of the index\n\t* @returns Index-scoped client with vector data operations\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t*\n\t* // Insert vectors\n\t* await index.putVectors({\n\t*   vectors: [\n\t*     { key: 'doc-1', data: { float32: [...] }, metadata: { title: 'Intro' } }\n\t*   ]\n\t* })\n\t*\n\t* // Query similar vectors\n\t* const { data } = await index.queryVectors({\n\t*   queryVector: { float32: [...] },\n\t*   topK: 5\n\t* })\n\t* ```\n\t*/ index(indexName) {\n        return new VectorIndexScope(this.url, this.headers, this.vectorBucketName, indexName, this.fetch);\n    }\n};\n/**\n*\n* @alpha\n*\n* Scoped client for operations within a specific vector index\n* Provides vector data operations (put, get, list, query, delete)\n*\n* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n*/ var VectorIndexScope = class extends VectorDataApi {\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Creates a helper that automatically scopes all vector operations to the provided bucket/index names.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* ```\n\t*/ constructor(url, headers, vectorBucketName, indexName, fetch$1){\n        super(url, headers, fetch$1);\n        this.vectorBucketName = vectorBucketName;\n        this.indexName = indexName;\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Inserts or updates vectors in this index\n\t* Convenience method that automatically includes bucket and index names\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Vector insertion options (bucket and index names automatically set)\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* await index.putVectors({\n\t*   vectors: [\n\t*     {\n\t*       key: 'doc-1',\n\t*       data: { float32: [0.1, 0.2, ...] },\n\t*       metadata: { title: 'Introduction', page: 1 }\n\t*     }\n\t*   ]\n\t* })\n\t* ```\n\t*/ async putVectors(options) {\n        var _superprop_getPutVectors = ()=>super.putVectors, _this9 = this;\n        return _superprop_getPutVectors().call(_this9, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this9.vectorBucketName,\n            indexName: _this9.indexName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Retrieves vectors by keys from this index\n\t* Convenience method that automatically includes bucket and index names\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Vector retrieval options (bucket and index names automatically set)\n\t* @returns Promise with response containing vectors array or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* const { data } = await index.getVectors({\n\t*   keys: ['doc-1', 'doc-2'],\n\t*   returnMetadata: true\n\t* })\n\t* ```\n\t*/ async getVectors(options) {\n        var _superprop_getGetVectors = ()=>super.getVectors, _this10 = this;\n        return _superprop_getGetVectors().call(_this10, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this10.vectorBucketName,\n            indexName: _this10.indexName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Lists vectors in this index with pagination\n\t* Convenience method that automatically includes bucket and index names\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Listing options (bucket and index names automatically set)\n\t* @returns Promise with response containing vectors array and pagination token or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* const { data } = await index.listVectors({\n\t*   maxResults: 500,\n\t*   returnMetadata: true\n\t* })\n\t* ```\n\t*/ async listVectors(options = {}) {\n        var _superprop_getListVectors = ()=>super.listVectors, _this11 = this;\n        return _superprop_getListVectors().call(_this11, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this11.vectorBucketName,\n            indexName: _this11.indexName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Queries for similar vectors in this index\n\t* Convenience method that automatically includes bucket and index names\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Query options (bucket and index names automatically set)\n\t* @returns Promise with response containing matches array of similar vectors ordered by distance or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* const { data } = await index.queryVectors({\n\t*   queryVector: { float32: [0.1, 0.2, ...] },\n\t*   topK: 5,\n\t*   filter: { category: 'technical' },\n\t*   returnDistance: true,\n\t*   returnMetadata: true\n\t* })\n\t* ```\n\t*/ async queryVectors(options) {\n        var _superprop_getQueryVectors = ()=>super.queryVectors, _this12 = this;\n        return _superprop_getQueryVectors().call(_this12, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this12.vectorBucketName,\n            indexName: _this12.indexName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Deletes vectors by keys from this index\n\t* Convenience method that automatically includes bucket and index names\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Deletion options (bucket and index names automatically set)\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* await index.deleteVectors({\n\t*   keys: ['doc-1', 'doc-2', 'doc-3']\n\t* })\n\t* ```\n\t*/ async deleteVectors(options) {\n        var _superprop_getDeleteVectors = ()=>super.deleteVectors, _this13 = this;\n        return _superprop_getDeleteVectors().call(_this13, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this13.vectorBucketName,\n            indexName: _this13.indexName\n        }));\n    }\n};\n//#endregion\n//#region src/StorageClient.ts\nvar StorageClient = class extends StorageBucketApi {\n    /**\n\t* Creates a client for Storage buckets, files, analytics, and vectors.\n\t*\n\t* @category File Buckets\n\t* @example\n\t* ```ts\n\t* import { StorageClient } from '@supabase/storage-js'\n\t*\n\t* const storage = new StorageClient('https://xyzcompany.supabase.co/storage/v1', {\n\t*   apikey: 'public-anon-key',\n\t* })\n\t* const avatars = storage.from('avatars')\n\t* ```\n\t*/ constructor(url, headers = {}, fetch$1, opts){\n        super(url, headers, fetch$1, opts);\n    }\n    /**\n\t* Perform file operation in a bucket.\n\t*\n\t* @category File Buckets\n\t* @param id The bucket id to operate on.\n\t*\n\t* @example\n\t* ```typescript\n\t* const avatars = supabase.storage.from('avatars')\n\t* ```\n\t*/ from(id) {\n        return new StorageFileApi(this.url, this.headers, id, this.fetch);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Access vector storage operations.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @returns A StorageVectorsClient instance configured with the current storage settings.\n\t*/ get vectors() {\n        return new StorageVectorsClient(this.url + \"/vector\", {\n            headers: this.headers,\n            fetch: this.fetch\n        });\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Access analytics storage operations using Iceberg tables.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @returns A StorageAnalyticsClient instance configured with the current storage settings.\n\t*/ get analytics() {\n        return new StorageAnalyticsClient(this.url + \"/iceberg\", this.headers, this.fetch);\n    }\n};\n//#endregion\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzdXBhYmFzZStzdG9yYWdlLWpzQDIuOTEuMC9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0Q7QUFFaEQsMkJBQTJCO0FBQzNCLElBQUlDLGVBQWUsY0FBY0M7SUFDaENDLFlBQVlDLE9BQU8sQ0FBRTtRQUNwQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRztRQUN4QixJQUFJLENBQUNDLElBQUksR0FBRztJQUNiO0FBQ0Q7QUFDQSxTQUFTQyxlQUFlQyxLQUFLO0lBQzVCLE9BQU8sT0FBT0EsVUFBVSxZQUFZQSxVQUFVLFFBQVEsc0JBQXNCQTtBQUM3RTtBQUNBLElBQUlDLGtCQUFrQixjQUFjUjtJQUNuQ0UsWUFBWUMsT0FBTyxFQUFFTSxNQUFNLEVBQUVDLFVBQVUsQ0FBRTtRQUN4QyxLQUFLLENBQUNQO1FBQ04sSUFBSSxDQUFDRSxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNJLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNDLFVBQVUsR0FBR0E7SUFDbkI7SUFDQUMsU0FBUztRQUNSLE9BQU87WUFDTk4sTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDZkYsU0FBUyxJQUFJLENBQUNBLE9BQU87WUFDckJNLFFBQVEsSUFBSSxDQUFDQSxNQUFNO1lBQ25CQyxZQUFZLElBQUksQ0FBQ0EsVUFBVTtRQUM1QjtJQUNEO0FBQ0Q7QUFDQSxJQUFJRSxzQkFBc0IsY0FBY1o7SUFDdkNFLFlBQVlDLE9BQU8sRUFBRVUsYUFBYSxDQUFFO1FBQ25DLEtBQUssQ0FBQ1Y7UUFDTixJQUFJLENBQUNFLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ1EsYUFBYSxHQUFHQTtJQUN0QjtBQUNEO0FBRUEsWUFBWTtBQUNaLDRCQUE0QjtBQUM1QixNQUFNQyxpQkFBaUIsQ0FBQ0M7SUFDdkIs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YWJhc2Urc3RvcmFnZS1qc0AyLjkxLjAvbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdG9yYWdlLWpzL2Rpc3QvaW5kZXgubWpzP2E4ZDkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSWNlYmVyZ1Jlc3RDYXRhbG9nIH0gZnJvbSBcImljZWJlcmctanNcIjtcblxuLy8jcmVnaW9uIHNyYy9saWIvZXJyb3JzLnRzXG52YXIgU3RvcmFnZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG5cdGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcblx0XHRzdXBlcihtZXNzYWdlKTtcblx0XHR0aGlzLl9faXNTdG9yYWdlRXJyb3IgPSB0cnVlO1xuXHRcdHRoaXMubmFtZSA9IFwiU3RvcmFnZUVycm9yXCI7XG5cdH1cbn07XG5mdW5jdGlvbiBpc1N0b3JhZ2VFcnJvcihlcnJvcikge1xuXHRyZXR1cm4gdHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiICYmIGVycm9yICE9PSBudWxsICYmIFwiX19pc1N0b3JhZ2VFcnJvclwiIGluIGVycm9yO1xufVxudmFyIFN0b3JhZ2VBcGlFcnJvciA9IGNsYXNzIGV4dGVuZHMgU3RvcmFnZUVycm9yIHtcblx0Y29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzLCBzdGF0dXNDb2RlKSB7XG5cdFx0c3VwZXIobWVzc2FnZSk7XG5cdFx0dGhpcy5uYW1lID0gXCJTdG9yYWdlQXBpRXJyb3JcIjtcblx0XHR0aGlzLnN0YXR1cyA9IHN0YXR1cztcblx0XHR0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuXHR9XG5cdHRvSlNPTigpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0bmFtZTogdGhpcy5uYW1lLFxuXHRcdFx0bWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuXHRcdFx0c3RhdHVzOiB0aGlzLnN0YXR1cyxcblx0XHRcdHN0YXR1c0NvZGU6IHRoaXMuc3RhdHVzQ29kZVxuXHRcdH07XG5cdH1cbn07XG52YXIgU3RvcmFnZVVua25vd25FcnJvciA9IGNsYXNzIGV4dGVuZHMgU3RvcmFnZUVycm9yIHtcblx0Y29uc3RydWN0b3IobWVzc2FnZSwgb3JpZ2luYWxFcnJvcikge1xuXHRcdHN1cGVyKG1lc3NhZ2UpO1xuXHRcdHRoaXMubmFtZSA9IFwiU3RvcmFnZVVua25vd25FcnJvclwiO1xuXHRcdHRoaXMub3JpZ2luYWxFcnJvciA9IG9yaWdpbmFsRXJyb3I7XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9saWIvaGVscGVycy50c1xuY29uc3QgcmVzb2x2ZUZldGNoJDEgPSAoY3VzdG9tRmV0Y2gpID0+IHtcblx0aWYgKGN1c3RvbUZldGNoKSByZXR1cm4gKC4uLmFyZ3MpID0+IGN1c3RvbUZldGNoKC4uLmFyZ3MpO1xuXHRyZXR1cm4gKC4uLmFyZ3MpID0+IGZldGNoKC4uLmFyZ3MpO1xufTtcbmNvbnN0IHJlc29sdmVSZXNwb25zZSQxID0gKCkgPT4ge1xuXHRyZXR1cm4gUmVzcG9uc2U7XG59O1xuY29uc3QgcmVjdXJzaXZlVG9DYW1lbCA9IChpdGVtKSA9PiB7XG5cdGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSByZXR1cm4gaXRlbS5tYXAoKGVsKSA9PiByZWN1cnNpdmVUb0NhbWVsKGVsKSk7XG5cdGVsc2UgaWYgKHR5cGVvZiBpdGVtID09PSBcImZ1bmN0aW9uXCIgfHwgaXRlbSAhPT0gT2JqZWN0KGl0ZW0pKSByZXR1cm4gaXRlbTtcblx0Y29uc3QgcmVzdWx0ID0ge307XG5cdE9iamVjdC5lbnRyaWVzKGl0ZW0pLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuXHRcdGNvbnN0IG5ld0tleSA9IGtleS5yZXBsYWNlKC8oWy1fXVthLXpdKS9naSwgKGMpID0+IGMudG9VcHBlckNhc2UoKS5yZXBsYWNlKC9bLV9dL2csIFwiXCIpKTtcblx0XHRyZXN1bHRbbmV3S2V5XSA9IHJlY3Vyc2l2ZVRvQ2FtZWwodmFsdWUpO1xuXHR9KTtcblx0cmV0dXJuIHJlc3VsdDtcbn07XG4vKipcbiogRGV0ZXJtaW5lIGlmIGlucHV0IGlzIGEgcGxhaW4gb2JqZWN0XG4qIEFuIG9iamVjdCBpcyBwbGFpbiBpZiBpdCdzIGNyZWF0ZWQgYnkgZWl0aGVyIHt9LCBuZXcgT2JqZWN0KCksIG9yIE9iamVjdC5jcmVhdGUobnVsbClcbiogc291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL2lzLXBsYWluLW9ialxuKi9cbmNvbnN0IGlzUGxhaW5PYmplY3QkMSA9ICh2YWx1ZSkgPT4ge1xuXHRpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdGNvbnN0IHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XG5cdHJldHVybiAocHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG90eXBlKSA9PT0gbnVsbCkgJiYgIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWUpICYmICEoU3ltYm9sLml0ZXJhdG9yIGluIHZhbHVlKTtcbn07XG4vKipcbiogVmFsaWRhdGVzIGlmIGEgZ2l2ZW4gYnVja2V0IG5hbWUgaXMgdmFsaWQgYWNjb3JkaW5nIHRvIFN1cGFiYXNlIFN0b3JhZ2UgQVBJIHJ1bGVzXG4qIE1pcnJvcnMgYmFja2VuZCB2YWxpZGF0aW9uIGZyb206IHN0b3JhZ2Uvc3JjL3N0b3JhZ2UvbGltaXRzLnRzOmlzVmFsaWRCdWNrZXROYW1lKClcbipcbiogUnVsZXM6XG4qIC0gTGVuZ3RoOiAxLTEwMCBjaGFyYWN0ZXJzXG4qIC0gQWxsb3dlZCBjaGFyYWN0ZXJzOiBhbHBoYW51bWVyaWMgKGEteiwgQS1aLCAwLTkpLCB1bmRlcnNjb3JlIChfKSwgYW5kIHNhZmUgc3BlY2lhbCBjaGFyYWN0ZXJzXG4qIC0gU2FmZSBzcGVjaWFsIGNoYXJhY3RlcnM6ICEgLSAuICogJyAoICkgc3BhY2UgJiAkIEAgPSA7IDogKyAsID9cbiogLSBGb3JiaWRkZW46IHBhdGggc2VwYXJhdG9ycyAoLywgXFwpLCBwYXRoIHRyYXZlcnNhbCAoLi4pLCBsZWFkaW5nL3RyYWlsaW5nIHdoaXRlc3BhY2VcbipcbiogQVdTIFMzIFJlZmVyZW5jZTogaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FtYXpvblMzL2xhdGVzdC91c2VyZ3VpZGUvb2JqZWN0LWtleXMuaHRtbFxuKlxuKiBAcGFyYW0gYnVja2V0TmFtZSAtIFRoZSBidWNrZXQgbmFtZSB0byB2YWxpZGF0ZVxuKiBAcmV0dXJucyB0cnVlIGlmIHZhbGlkLCBmYWxzZSBvdGhlcndpc2VcbiovXG5jb25zdCBpc1ZhbGlkQnVja2V0TmFtZSA9IChidWNrZXROYW1lKSA9PiB7XG5cdGlmICghYnVja2V0TmFtZSB8fCB0eXBlb2YgYnVja2V0TmFtZSAhPT0gXCJzdHJpbmdcIikgcmV0dXJuIGZhbHNlO1xuXHRpZiAoYnVja2V0TmFtZS5sZW5ndGggPT09IDAgfHwgYnVja2V0TmFtZS5sZW5ndGggPiAxMDApIHJldHVybiBmYWxzZTtcblx0aWYgKGJ1Y2tldE5hbWUudHJpbSgpICE9PSBidWNrZXROYW1lKSByZXR1cm4gZmFsc2U7XG5cdGlmIChidWNrZXROYW1lLmluY2x1ZGVzKFwiL1wiKSB8fCBidWNrZXROYW1lLmluY2x1ZGVzKFwiXFxcXFwiKSkgcmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gL15bXFx3IS5cXConKCkgJiRAPTs6Kyw/LV0rJC8udGVzdChidWNrZXROYW1lKTtcbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIFxcMEBveGMtcHJvamVjdCtydW50aW1lQDAuMTAxLjAvaGVscGVycy90eXBlb2YuanNcbmZ1bmN0aW9uIF90eXBlb2Yobykge1xuXHRcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cdHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24obyQxKSB7XG5cdFx0cmV0dXJuIHR5cGVvZiBvJDE7XG5cdH0gOiBmdW5jdGlvbihvJDEpIHtcblx0XHRyZXR1cm4gbyQxICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8kMS5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8kMSAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbyQxO1xuXHR9LCBfdHlwZW9mKG8pO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBcXDBAb3hjLXByb2plY3QrcnVudGltZUAwLjEwMS4wL2hlbHBlcnMvdG9QcmltaXRpdmUuanNcbmZ1bmN0aW9uIHRvUHJpbWl0aXZlKHQsIHIpIHtcblx0aWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7XG5cdHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdO1xuXHRpZiAodm9pZCAwICE9PSBlKSB7XG5cdFx0dmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7XG5cdFx0aWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuXHR9XG5cdHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIFxcMEBveGMtcHJvamVjdCtydW50aW1lQDAuMTAxLjAvaGVscGVycy90b1Byb3BlcnR5S2V5LmpzXG5mdW5jdGlvbiB0b1Byb3BlcnR5S2V5KHQpIHtcblx0dmFyIGkgPSB0b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTtcblx0cmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gXFwwQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC4xMDEuMC9oZWxwZXJzL2RlZmluZVByb3BlcnR5LmpzXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkge1xuXHRyZXR1cm4gKHIgPSB0b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHtcblx0XHR2YWx1ZTogdCxcblx0XHRlbnVtZXJhYmxlOiAhMCxcblx0XHRjb25maWd1cmFibGU6ICEwLFxuXHRcdHdyaXRhYmxlOiAhMFxuXHR9KSA6IGVbcl0gPSB0LCBlO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBcXDBAb3hjLXByb2plY3QrcnVudGltZUAwLjEwMS4wL2hlbHBlcnMvb2JqZWN0U3ByZWFkMi5qc1xuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7XG5cdHZhciB0ID0gT2JqZWN0LmtleXMoZSk7XG5cdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0dmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuXHRcdHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbihyJDEpIHtcblx0XHRcdHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIkMSkuZW51bWVyYWJsZTtcblx0XHR9KSksIHQucHVzaC5hcHBseSh0LCBvKTtcblx0fVxuXHRyZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKGUpIHtcblx0Zm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHtcblx0XHR2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307XG5cdFx0ciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24ociQxKSB7XG5cdFx0XHRfZGVmaW5lUHJvcGVydHkoZSwgciQxLCB0W3IkMV0pO1xuXHRcdH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbihyJDEpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByJDEsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgciQxKSk7XG5cdFx0fSk7XG5cdH1cblx0cmV0dXJuIGU7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9saWIvZmV0Y2gudHNcbmNvbnN0IF9nZXRFcnJvck1lc3NhZ2UkMSA9IChlcnIpID0+IHtcblx0dmFyIF9lcnIkZXJyb3I7XG5cdHJldHVybiBlcnIubXNnIHx8IGVyci5tZXNzYWdlIHx8IGVyci5lcnJvcl9kZXNjcmlwdGlvbiB8fCAodHlwZW9mIGVyci5lcnJvciA9PT0gXCJzdHJpbmdcIiA/IGVyci5lcnJvciA6IChfZXJyJGVycm9yID0gZXJyLmVycm9yKSA9PT0gbnVsbCB8fCBfZXJyJGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXJyJGVycm9yLm1lc3NhZ2UpIHx8IEpTT04uc3RyaW5naWZ5KGVycik7XG59O1xuY29uc3QgaGFuZGxlRXJyb3IkMSA9IGFzeW5jIChlcnJvciwgcmVqZWN0LCBvcHRpb25zKSA9PiB7XG5cdGlmIChlcnJvciBpbnN0YW5jZW9mIGF3YWl0IHJlc29sdmVSZXNwb25zZSQxKCkgJiYgIShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubm9SZXNvbHZlSnNvbikpIGVycm9yLmpzb24oKS50aGVuKChlcnIpID0+IHtcblx0XHRjb25zdCBzdGF0dXMgPSBlcnJvci5zdGF0dXMgfHwgNTAwO1xuXHRcdGNvbnN0IHN0YXR1c0NvZGUgPSAoZXJyID09PSBudWxsIHx8IGVyciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyLnN0YXR1c0NvZGUpIHx8IHN0YXR1cyArIFwiXCI7XG5cdFx0cmVqZWN0KG5ldyBTdG9yYWdlQXBpRXJyb3IoX2dldEVycm9yTWVzc2FnZSQxKGVyciksIHN0YXR1cywgc3RhdHVzQ29kZSkpO1xuXHR9KS5jYXRjaCgoZXJyKSA9PiB7XG5cdFx0cmVqZWN0KG5ldyBTdG9yYWdlVW5rbm93bkVycm9yKF9nZXRFcnJvck1lc3NhZ2UkMShlcnIpLCBlcnIpKTtcblx0fSk7XG5cdGVsc2UgcmVqZWN0KG5ldyBTdG9yYWdlVW5rbm93bkVycm9yKF9nZXRFcnJvck1lc3NhZ2UkMShlcnJvciksIGVycm9yKSk7XG59O1xuY29uc3QgX2dldFJlcXVlc3RQYXJhbXMkMSA9IChtZXRob2QsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpID0+IHtcblx0Y29uc3QgcGFyYW1zID0ge1xuXHRcdG1ldGhvZCxcblx0XHRoZWFkZXJzOiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMpIHx8IHt9XG5cdH07XG5cdGlmIChtZXRob2QgPT09IFwiR0VUXCIgfHwgIWJvZHkpIHJldHVybiBwYXJhbXM7XG5cdGlmIChpc1BsYWluT2JqZWN0JDEoYm9keSkpIHtcblx0XHRwYXJhbXMuaGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMpO1xuXHRcdHBhcmFtcy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG5cdH0gZWxzZSBwYXJhbXMuYm9keSA9IGJvZHk7XG5cdGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZHVwbGV4KSBwYXJhbXMuZHVwbGV4ID0gb3B0aW9ucy5kdXBsZXg7XG5cdHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgcGFyYW1zKSwgcGFyYW1ldGVycyk7XG59O1xuYXN5bmMgZnVuY3Rpb24gX2hhbmRsZVJlcXVlc3QkMShmZXRjaGVyLCBtZXRob2QsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSkge1xuXHRyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdGZldGNoZXIodXJsLCBfZ2V0UmVxdWVzdFBhcmFtcyQxKG1ldGhvZCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSkpLnRoZW4oKHJlc3VsdCkgPT4ge1xuXHRcdFx0aWYgKCFyZXN1bHQub2spIHRocm93IHJlc3VsdDtcblx0XHRcdGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubm9SZXNvbHZlSnNvbikgcmV0dXJuIHJlc3VsdDtcblx0XHRcdHJldHVybiByZXN1bHQuanNvbigpO1xuXHRcdH0pLnRoZW4oKGRhdGEpID0+IHJlc29sdmUoZGF0YSkpLmNhdGNoKChlcnJvcikgPT4gaGFuZGxlRXJyb3IkMShlcnJvciwgcmVqZWN0LCBvcHRpb25zKSk7XG5cdH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0KGZldGNoZXIsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycykge1xuXHRyZXR1cm4gX2hhbmRsZVJlcXVlc3QkMShmZXRjaGVyLCBcIkdFVFwiLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMpO1xufVxuYXN5bmMgZnVuY3Rpb24gcG9zdCQxKGZldGNoZXIsIHVybCwgYm9keSwgb3B0aW9ucywgcGFyYW1ldGVycykge1xuXHRyZXR1cm4gX2hhbmRsZVJlcXVlc3QkMShmZXRjaGVyLCBcIlBPU1RcIiwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHB1dChmZXRjaGVyLCB1cmwsIGJvZHksIG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcblx0cmV0dXJuIF9oYW5kbGVSZXF1ZXN0JDEoZmV0Y2hlciwgXCJQVVRcIiwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhlYWQoZmV0Y2hlciwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XG5cdHJldHVybiBfaGFuZGxlUmVxdWVzdCQxKGZldGNoZXIsIFwiSEVBRFwiLCB1cmwsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBvcHRpb25zKSwge30sIHsgbm9SZXNvbHZlSnNvbjogdHJ1ZSB9KSwgcGFyYW1ldGVycyk7XG59XG5hc3luYyBmdW5jdGlvbiByZW1vdmUoZmV0Y2hlciwgdXJsLCBib2R5LCBvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XG5cdHJldHVybiBfaGFuZGxlUmVxdWVzdCQxKGZldGNoZXIsIFwiREVMRVRFXCIsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSk7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9wYWNrYWdlcy9TdHJlYW1Eb3dubG9hZEJ1aWxkZXIudHNcbnZhciBTdHJlYW1Eb3dubG9hZEJ1aWxkZXIgPSBjbGFzcyB7XG5cdGNvbnN0cnVjdG9yKGRvd25sb2FkRm4sIHNob3VsZFRocm93T25FcnJvcikge1xuXHRcdHRoaXMuZG93bmxvYWRGbiA9IGRvd25sb2FkRm47XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSBzaG91bGRUaHJvd09uRXJyb3I7XG5cdH1cblx0dGhlbihvbmZ1bGZpbGxlZCwgb25yZWplY3RlZCkge1xuXHRcdHJldHVybiB0aGlzLmV4ZWN1dGUoKS50aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKTtcblx0fVxuXHRhc3luYyBleGVjdXRlKCkge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IChhd2FpdCBfdGhpcy5kb3dubG9hZEZuKCkpLmJvZHksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvcGFja2FnZXMvQmxvYkRvd25sb2FkQnVpbGRlci50c1xubGV0IF9TeW1ib2wkdG9TdHJpbmdUYWc7XG5fU3ltYm9sJHRvU3RyaW5nVGFnID0gU3ltYm9sLnRvU3RyaW5nVGFnO1xudmFyIEJsb2JEb3dubG9hZEJ1aWxkZXIgPSBjbGFzcyB7XG5cdGNvbnN0cnVjdG9yKGRvd25sb2FkRm4sIHNob3VsZFRocm93T25FcnJvcikge1xuXHRcdHRoaXMuZG93bmxvYWRGbiA9IGRvd25sb2FkRm47XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSBzaG91bGRUaHJvd09uRXJyb3I7XG5cdFx0dGhpc1tfU3ltYm9sJHRvU3RyaW5nVGFnXSA9IFwiQmxvYkRvd25sb2FkQnVpbGRlclwiO1xuXHRcdHRoaXMucHJvbWlzZSA9IG51bGw7XG5cdH1cblx0YXNTdHJlYW0oKSB7XG5cdFx0cmV0dXJuIG5ldyBTdHJlYW1Eb3dubG9hZEJ1aWxkZXIodGhpcy5kb3dubG9hZEZuLCB0aGlzLnNob3VsZFRocm93T25FcnJvcik7XG5cdH1cblx0dGhlbihvbmZ1bGZpbGxlZCwgb25yZWplY3RlZCkge1xuXHRcdHJldHVybiB0aGlzLmdldFByb21pc2UoKS50aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKTtcblx0fVxuXHRjYXRjaChvbnJlamVjdGVkKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UHJvbWlzZSgpLmNhdGNoKG9ucmVqZWN0ZWQpO1xuXHR9XG5cdGZpbmFsbHkob25maW5hbGx5KSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UHJvbWlzZSgpLmZpbmFsbHkob25maW5hbGx5KTtcblx0fVxuXHRnZXRQcm9taXNlKCkge1xuXHRcdGlmICghdGhpcy5wcm9taXNlKSB0aGlzLnByb21pc2UgPSB0aGlzLmV4ZWN1dGUoKTtcblx0XHRyZXR1cm4gdGhpcy5wcm9taXNlO1xuXHR9XG5cdGFzeW5jIGV4ZWN1dGUoKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgKGF3YWl0IF90aGlzLmRvd25sb2FkRm4oKSkuYmxvYigpLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3BhY2thZ2VzL1N0b3JhZ2VGaWxlQXBpLnRzXG5jb25zdCBERUZBVUxUX1NFQVJDSF9PUFRJT05TID0ge1xuXHRsaW1pdDogMTAwLFxuXHRvZmZzZXQ6IDAsXG5cdHNvcnRCeToge1xuXHRcdGNvbHVtbjogXCJuYW1lXCIsXG5cdFx0b3JkZXI6IFwiYXNjXCJcblx0fVxufTtcbmNvbnN0IERFRkFVTFRfRklMRV9PUFRJT05TID0ge1xuXHRjYWNoZUNvbnRyb2w6IFwiMzYwMFwiLFxuXHRjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLThcIixcblx0dXBzZXJ0OiBmYWxzZVxufTtcbnZhciBTdG9yYWdlRmlsZUFwaSA9IGNsYXNzIHtcblx0Y29uc3RydWN0b3IodXJsLCBoZWFkZXJzID0ge30sIGJ1Y2tldElkLCBmZXRjaCQxKSB7XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSBmYWxzZTtcblx0XHR0aGlzLnVybCA9IHVybDtcblx0XHR0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuXHRcdHRoaXMuYnVja2V0SWQgPSBidWNrZXRJZDtcblx0XHR0aGlzLmZldGNoID0gcmVzb2x2ZUZldGNoJDEoZmV0Y2gkMSk7XG5cdH1cblx0LyoqXG5cdCogRW5hYmxlIHRocm93aW5nIGVycm9ycyBpbnN0ZWFkIG9mIHJldHVybmluZyB0aGVtLlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqL1xuXHR0aHJvd09uRXJyb3IoKSB7XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSB0cnVlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIFVwbG9hZHMgYSBmaWxlIHRvIGFuIGV4aXN0aW5nIGJ1Y2tldCBvciByZXBsYWNlcyBhbiBleGlzdGluZyBmaWxlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aCB3aXRoIGEgbmV3IG9uZS5cblx0KlxuXHQqIEBwYXJhbSBtZXRob2QgSFRUUCBtZXRob2QuXG5cdCogQHBhcmFtIHBhdGggVGhlIHJlbGF0aXZlIGZpbGUgcGF0aC4gU2hvdWxkIGJlIG9mIHRoZSBmb3JtYXQgYGZvbGRlci9zdWJmb2xkZXIvZmlsZW5hbWUucG5nYC4gVGhlIGJ1Y2tldCBtdXN0IGFscmVhZHkgZXhpc3QgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdXBsb2FkLlxuXHQqIEBwYXJhbSBmaWxlQm9keSBUaGUgYm9keSBvZiB0aGUgZmlsZSB0byBiZSBzdG9yZWQgaW4gdGhlIGJ1Y2tldC5cblx0Ki9cblx0YXN5bmMgdXBsb2FkT3JVcGRhdGUobWV0aG9kLCBwYXRoLCBmaWxlQm9keSwgZmlsZU9wdGlvbnMpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRsZXQgYm9keTtcblx0XHRcdGNvbnN0IG9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9GSUxFX09QVElPTlMpLCBmaWxlT3B0aW9ucyk7XG5cdFx0XHRsZXQgaGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBfdGhpcy5oZWFkZXJzKSwgbWV0aG9kID09PSBcIlBPU1RcIiAmJiB7IFwieC11cHNlcnRcIjogU3RyaW5nKG9wdGlvbnMudXBzZXJ0KSB9KTtcblx0XHRcdGNvbnN0IG1ldGFkYXRhID0gb3B0aW9ucy5tZXRhZGF0YTtcblx0XHRcdGlmICh0eXBlb2YgQmxvYiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBmaWxlQm9keSBpbnN0YW5jZW9mIEJsb2IpIHtcblx0XHRcdFx0Ym9keSA9IG5ldyBGb3JtRGF0YSgpO1xuXHRcdFx0XHRib2R5LmFwcGVuZChcImNhY2hlQ29udHJvbFwiLCBvcHRpb25zLmNhY2hlQ29udHJvbCk7XG5cdFx0XHRcdGlmIChtZXRhZGF0YSkgYm9keS5hcHBlbmQoXCJtZXRhZGF0YVwiLCBfdGhpcy5lbmNvZGVNZXRhZGF0YShtZXRhZGF0YSkpO1xuXHRcdFx0XHRib2R5LmFwcGVuZChcIlwiLCBmaWxlQm9keSk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBGb3JtRGF0YSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBmaWxlQm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG5cdFx0XHRcdGJvZHkgPSBmaWxlQm9keTtcblx0XHRcdFx0aWYgKCFib2R5LmhhcyhcImNhY2hlQ29udHJvbFwiKSkgYm9keS5hcHBlbmQoXCJjYWNoZUNvbnRyb2xcIiwgb3B0aW9ucy5jYWNoZUNvbnRyb2wpO1xuXHRcdFx0XHRpZiAobWV0YWRhdGEgJiYgIWJvZHkuaGFzKFwibWV0YWRhdGFcIikpIGJvZHkuYXBwZW5kKFwibWV0YWRhdGFcIiwgX3RoaXMuZW5jb2RlTWV0YWRhdGEobWV0YWRhdGEpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJvZHkgPSBmaWxlQm9keTtcblx0XHRcdFx0aGVhZGVyc1tcImNhY2hlLWNvbnRyb2xcIl0gPSBgbWF4LWFnZT0ke29wdGlvbnMuY2FjaGVDb250cm9sfWA7XG5cdFx0XHRcdGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPSBvcHRpb25zLmNvbnRlbnRUeXBlO1xuXHRcdFx0XHRpZiAobWV0YWRhdGEpIGhlYWRlcnNbXCJ4LW1ldGFkYXRhXCJdID0gX3RoaXMudG9CYXNlNjQoX3RoaXMuZW5jb2RlTWV0YWRhdGEobWV0YWRhdGEpKTtcblx0XHRcdFx0aWYgKCh0eXBlb2YgUmVhZGFibGVTdHJlYW0gIT09IFwidW5kZWZpbmVkXCIgJiYgYm9keSBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtIHx8IGJvZHkgJiYgdHlwZW9mIGJvZHkgPT09IFwib2JqZWN0XCIgJiYgXCJwaXBlXCIgaW4gYm9keSAmJiB0eXBlb2YgYm9keS5waXBlID09PSBcImZ1bmN0aW9uXCIpICYmICFvcHRpb25zLmR1cGxleCkgb3B0aW9ucy5kdXBsZXggPSBcImhhbGZcIjtcblx0XHRcdH1cblx0XHRcdGlmIChmaWxlT3B0aW9ucyA9PT0gbnVsbCB8fCBmaWxlT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlsZU9wdGlvbnMuaGVhZGVycykgaGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBoZWFkZXJzKSwgZmlsZU9wdGlvbnMuaGVhZGVycyk7XG5cdFx0XHRjb25zdCBjbGVhblBhdGggPSBfdGhpcy5fcmVtb3ZlRW1wdHlGb2xkZXJzKHBhdGgpO1xuXHRcdFx0Y29uc3QgX3BhdGggPSBfdGhpcy5fZ2V0RmluYWxQYXRoKGNsZWFuUGF0aCk7XG5cdFx0XHRjb25zdCBkYXRhID0gYXdhaXQgKG1ldGhvZCA9PSBcIlBVVFwiID8gcHV0IDogcG9zdCQxKShfdGhpcy5mZXRjaCwgYCR7X3RoaXMudXJsfS9vYmplY3QvJHtfcGF0aH1gLCBib2R5LCBfb2JqZWN0U3ByZWFkMih7IGhlYWRlcnMgfSwgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kdXBsZXgpID8geyBkdXBsZXg6IG9wdGlvbnMuZHVwbGV4IH0gOiB7fSkpO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YToge1xuXHRcdFx0XHRcdHBhdGg6IGNsZWFuUGF0aCxcblx0XHRcdFx0XHRpZDogZGF0YS5JZCxcblx0XHRcdFx0XHRmdWxsUGF0aDogZGF0YS5LZXlcblx0XHRcdFx0fSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqXG5cdCogVXBsb2FkcyBhIGZpbGUgdG8gYW4gZXhpc3RpbmcgYnVja2V0LlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBwYXRoIFRoZSBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgZmlsZSBuYW1lLiBTaG91bGQgYmUgb2YgdGhlIGZvcm1hdCBgZm9sZGVyL3N1YmZvbGRlci9maWxlbmFtZS5wbmdgLiBUaGUgYnVja2V0IG11c3QgYWxyZWFkeSBleGlzdCBiZWZvcmUgYXR0ZW1wdGluZyB0byB1cGxvYWQuXG5cdCogQHBhcmFtIGZpbGVCb2R5IFRoZSBib2R5IG9mIHRoZSBmaWxlIHRvIGJlIHN0b3JlZCBpbiB0aGUgYnVja2V0LlxuXHQqIEBwYXJhbSBmaWxlT3B0aW9ucyBPcHRpb25hbCBmaWxlIHVwbG9hZCBvcHRpb25zIGluY2x1ZGluZyBjYWNoZUNvbnRyb2wsIGNvbnRlbnRUeXBlLCB1cHNlcnQsIGFuZCBtZXRhZGF0YS5cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBmaWxlIHBhdGgsIGlkLCBhbmQgZnVsbFBhdGggb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIFVwbG9hZCBmaWxlXG5cdCogYGBganNcblx0KiBjb25zdCBhdmF0YXJGaWxlID0gZXZlbnQudGFyZ2V0LmZpbGVzWzBdXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAudXBsb2FkKCdwdWJsaWMvYXZhdGFyMS5wbmcnLCBhdmF0YXJGaWxlLCB7XG5cdCogICAgIGNhY2hlQ29udHJvbDogJzM2MDAnLFxuXHQqICAgICB1cHNlcnQ6IGZhbHNlXG5cdCogICB9KVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiB7XG5cdCogICAgIFwicGF0aFwiOiBcInB1YmxpYy9hdmF0YXIxLnBuZ1wiLFxuXHQqICAgICBcImZ1bGxQYXRoXCI6IFwiYXZhdGFycy9wdWJsaWMvYXZhdGFyMS5wbmdcIlxuXHQqICAgfSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0KlxuXHQqIEBleGFtcGxlIFVwbG9hZCBmaWxlIHVzaW5nIGBBcnJheUJ1ZmZlcmAgZnJvbSBiYXNlNjQgZmlsZSBkYXRhXG5cdCogYGBganNcblx0KiBpbXBvcnQgeyBkZWNvZGUgfSBmcm9tICdiYXNlNjQtYXJyYXlidWZmZXInXG5cdCpcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdhdmF0YXJzJylcblx0KiAgIC51cGxvYWQoJ3B1YmxpYy9hdmF0YXIxLnBuZycsIGRlY29kZSgnYmFzZTY0RmlsZURhdGEnKSwge1xuXHQqICAgICBjb250ZW50VHlwZTogJ2ltYWdlL3BuZydcblx0KiAgIH0pXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIHVwbG9hZChwYXRoLCBmaWxlQm9keSwgZmlsZU9wdGlvbnMpIHtcblx0XHRyZXR1cm4gdGhpcy51cGxvYWRPclVwZGF0ZShcIlBPU1RcIiwgcGF0aCwgZmlsZUJvZHksIGZpbGVPcHRpb25zKTtcblx0fVxuXHQvKipcblx0KiBVcGxvYWQgYSBmaWxlIHdpdGggYSB0b2tlbiBnZW5lcmF0ZWQgZnJvbSBgY3JlYXRlU2lnbmVkVXBsb2FkVXJsYC5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gcGF0aCBUaGUgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGZpbGUgbmFtZS4gU2hvdWxkIGJlIG9mIHRoZSBmb3JtYXQgYGZvbGRlci9zdWJmb2xkZXIvZmlsZW5hbWUucG5nYC4gVGhlIGJ1Y2tldCBtdXN0IGFscmVhZHkgZXhpc3QgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdXBsb2FkLlxuXHQqIEBwYXJhbSB0b2tlbiBUaGUgdG9rZW4gZ2VuZXJhdGVkIGZyb20gYGNyZWF0ZVNpZ25lZFVwbG9hZFVybGBcblx0KiBAcGFyYW0gZmlsZUJvZHkgVGhlIGJvZHkgb2YgdGhlIGZpbGUgdG8gYmUgc3RvcmVkIGluIHRoZSBidWNrZXQuXG5cdCogQHBhcmFtIGZpbGVPcHRpb25zIEhUVFAgaGVhZGVycyAoY2FjaGVDb250cm9sLCBjb250ZW50VHlwZSwgZXRjLikuXG5cdCogKipOb3RlOioqIFRoZSBgdXBzZXJ0YCBvcHRpb24gaGFzIG5vIGVmZmVjdCBoZXJlLiBUbyBlbmFibGUgdXBzZXJ0IGJlaGF2aW9yLFxuXHQqIHBhc3MgYHsgdXBzZXJ0OiB0cnVlIH1gIHdoZW4gY2FsbGluZyBgY3JlYXRlU2lnbmVkVXBsb2FkVXJsKClgIGluc3RlYWQuXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgZmlsZSBwYXRoIGFuZCBmdWxsUGF0aCBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgVXBsb2FkIHRvIGEgc2lnbmVkIFVSTFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAudXBsb2FkVG9TaWduZWRVcmwoJ2ZvbGRlci9jYXQuanBnJywgJ3Rva2VuLWZyb20tY3JlYXRlU2lnbmVkVXBsb2FkVXJsJywgZmlsZSlcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjoge1xuXHQqICAgICBcInBhdGhcIjogXCJmb2xkZXIvY2F0LmpwZ1wiLFxuXHQqICAgICBcImZ1bGxQYXRoXCI6IFwiYXZhdGFycy9mb2xkZXIvY2F0LmpwZ1wiXG5cdCogICB9LFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyB1cGxvYWRUb1NpZ25lZFVybChwYXRoLCB0b2tlbiwgZmlsZUJvZHksIGZpbGVPcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzMyA9IHRoaXM7XG5cdFx0Y29uc3QgY2xlYW5QYXRoID0gX3RoaXMzLl9yZW1vdmVFbXB0eUZvbGRlcnMocGF0aCk7XG5cdFx0Y29uc3QgX3BhdGggPSBfdGhpczMuX2dldEZpbmFsUGF0aChjbGVhblBhdGgpO1xuXHRcdGNvbnN0IHVybCA9IG5ldyBVUkwoX3RoaXMzLnVybCArIGAvb2JqZWN0L3VwbG9hZC9zaWduLyR7X3BhdGh9YCk7XG5cdFx0dXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJ0b2tlblwiLCB0b2tlbik7XG5cdFx0dHJ5IHtcblx0XHRcdGxldCBib2R5O1xuXHRcdFx0Y29uc3Qgb3B0aW9ucyA9IF9vYmplY3RTcHJlYWQyKHsgdXBzZXJ0OiBERUZBVUxUX0ZJTEVfT1BUSU9OUy51cHNlcnQgfSwgZmlsZU9wdGlvbnMpO1xuXHRcdFx0Y29uc3QgaGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBfdGhpczMuaGVhZGVycyksIHsgXCJ4LXVwc2VydFwiOiBTdHJpbmcob3B0aW9ucy51cHNlcnQpIH0pO1xuXHRcdFx0aWYgKHR5cGVvZiBCbG9iICE9PSBcInVuZGVmaW5lZFwiICYmIGZpbGVCb2R5IGluc3RhbmNlb2YgQmxvYikge1xuXHRcdFx0XHRib2R5ID0gbmV3IEZvcm1EYXRhKCk7XG5cdFx0XHRcdGJvZHkuYXBwZW5kKFwiY2FjaGVDb250cm9sXCIsIG9wdGlvbnMuY2FjaGVDb250cm9sKTtcblx0XHRcdFx0Ym9keS5hcHBlbmQoXCJcIiwgZmlsZUJvZHkpO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgRm9ybURhdGEgIT09IFwidW5kZWZpbmVkXCIgJiYgZmlsZUJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuXHRcdFx0XHRib2R5ID0gZmlsZUJvZHk7XG5cdFx0XHRcdGJvZHkuYXBwZW5kKFwiY2FjaGVDb250cm9sXCIsIG9wdGlvbnMuY2FjaGVDb250cm9sKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJvZHkgPSBmaWxlQm9keTtcblx0XHRcdFx0aGVhZGVyc1tcImNhY2hlLWNvbnRyb2xcIl0gPSBgbWF4LWFnZT0ke29wdGlvbnMuY2FjaGVDb250cm9sfWA7XG5cdFx0XHRcdGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPSBvcHRpb25zLmNvbnRlbnRUeXBlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YToge1xuXHRcdFx0XHRcdHBhdGg6IGNsZWFuUGF0aCxcblx0XHRcdFx0XHRmdWxsUGF0aDogKGF3YWl0IHB1dChfdGhpczMuZmV0Y2gsIHVybC50b1N0cmluZygpLCBib2R5LCB7IGhlYWRlcnMgfSkpLktleVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzMy5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqXG5cdCogQ3JlYXRlcyBhIHNpZ25lZCB1cGxvYWQgVVJMLlxuXHQqIFNpZ25lZCB1cGxvYWQgVVJMcyBjYW4gYmUgdXNlZCB0byB1cGxvYWQgZmlsZXMgdG8gdGhlIGJ1Y2tldCB3aXRob3V0IGZ1cnRoZXIgYXV0aGVudGljYXRpb24uXG5cdCogVGhleSBhcmUgdmFsaWQgZm9yIDIgaG91cnMuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIHBhdGggVGhlIGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBjdXJyZW50IGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuXHQqIEBwYXJhbSBvcHRpb25zLnVwc2VydCBJZiBzZXQgdG8gdHJ1ZSwgYWxsb3dzIHRoZSBmaWxlIHRvIGJlIG92ZXJ3cml0dGVuIGlmIGl0IGFscmVhZHkgZXhpc3RzLlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIHNpZ25lZCB1cGxvYWQgVVJMLCB0b2tlbiwgYW5kIHBhdGggb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIENyZWF0ZSBTaWduZWQgVXBsb2FkIFVSTFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAuY3JlYXRlU2lnbmVkVXBsb2FkVXJsKCdmb2xkZXIvY2F0LmpwZycpXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IHtcblx0KiAgICAgXCJzaWduZWRVcmxcIjogXCJodHRwczovL2V4YW1wbGUuc3VwYWJhc2UuY28vc3RvcmFnZS92MS9vYmplY3QvdXBsb2FkL3NpZ24vYXZhdGFycy9mb2xkZXIvY2F0LmpwZz90b2tlbj08VE9LRU4+XCIsXG5cdCogICAgIFwicGF0aFwiOiBcImZvbGRlci9jYXQuanBnXCIsXG5cdCogICAgIFwidG9rZW5cIjogXCI8VE9LRU4+XCJcblx0KiAgIH0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGNyZWF0ZVNpZ25lZFVwbG9hZFVybChwYXRoLCBvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzNCA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdGxldCBfcGF0aCA9IF90aGlzNC5fZ2V0RmluYWxQYXRoKHBhdGgpO1xuXHRcdFx0Y29uc3QgaGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKHt9LCBfdGhpczQuaGVhZGVycyk7XG5cdFx0XHRpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnVwc2VydCkgaGVhZGVyc1tcIngtdXBzZXJ0XCJdID0gXCJ0cnVlXCI7XG5cdFx0XHRjb25zdCBkYXRhID0gYXdhaXQgcG9zdCQxKF90aGlzNC5mZXRjaCwgYCR7X3RoaXM0LnVybH0vb2JqZWN0L3VwbG9hZC9zaWduLyR7X3BhdGh9YCwge30sIHsgaGVhZGVycyB9KTtcblx0XHRcdGNvbnN0IHVybCA9IG5ldyBVUkwoX3RoaXM0LnVybCArIGRhdGEudXJsKTtcblx0XHRcdGNvbnN0IHRva2VuID0gdXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJ0b2tlblwiKTtcblx0XHRcdGlmICghdG9rZW4pIHRocm93IG5ldyBTdG9yYWdlRXJyb3IoXCJObyB0b2tlbiByZXR1cm5lZCBieSBBUElcIik7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiB7XG5cdFx0XHRcdFx0c2lnbmVkVXJsOiB1cmwudG9TdHJpbmcoKSxcblx0XHRcdFx0XHRwYXRoLFxuXHRcdFx0XHRcdHRva2VuXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXM0LnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKipcblx0KiBSZXBsYWNlcyBhbiBleGlzdGluZyBmaWxlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aCB3aXRoIGEgbmV3IG9uZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gcGF0aCBUaGUgcmVsYXRpdmUgZmlsZSBwYXRoLiBTaG91bGQgYmUgb2YgdGhlIGZvcm1hdCBgZm9sZGVyL3N1YmZvbGRlci9maWxlbmFtZS5wbmdgLiBUaGUgYnVja2V0IG11c3QgYWxyZWFkeSBleGlzdCBiZWZvcmUgYXR0ZW1wdGluZyB0byB1cGRhdGUuXG5cdCogQHBhcmFtIGZpbGVCb2R5IFRoZSBib2R5IG9mIHRoZSBmaWxlIHRvIGJlIHN0b3JlZCBpbiB0aGUgYnVja2V0LlxuXHQqIEBwYXJhbSBmaWxlT3B0aW9ucyBPcHRpb25hbCBmaWxlIHVwbG9hZCBvcHRpb25zIGluY2x1ZGluZyBjYWNoZUNvbnRyb2wsIGNvbnRlbnRUeXBlLCB1cHNlcnQsIGFuZCBtZXRhZGF0YS5cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBmaWxlIHBhdGgsIGlkLCBhbmQgZnVsbFBhdGggb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIFVwZGF0ZSBmaWxlXG5cdCogYGBganNcblx0KiBjb25zdCBhdmF0YXJGaWxlID0gZXZlbnQudGFyZ2V0LmZpbGVzWzBdXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAudXBkYXRlKCdwdWJsaWMvYXZhdGFyMS5wbmcnLCBhdmF0YXJGaWxlLCB7XG5cdCogICAgIGNhY2hlQ29udHJvbDogJzM2MDAnLFxuXHQqICAgICB1cHNlcnQ6IHRydWVcblx0KiAgIH0pXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IHtcblx0KiAgICAgXCJwYXRoXCI6IFwicHVibGljL2F2YXRhcjEucG5nXCIsXG5cdCogICAgIFwiZnVsbFBhdGhcIjogXCJhdmF0YXJzL3B1YmxpYy9hdmF0YXIxLnBuZ1wiXG5cdCogICB9LFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqXG5cdCogQGV4YW1wbGUgVXBkYXRlIGZpbGUgdXNpbmcgYEFycmF5QnVmZmVyYCBmcm9tIGJhc2U2NCBmaWxlIGRhdGFcblx0KiBgYGBqc1xuXHQqIGltcG9ydCB7ZGVjb2RlfSBmcm9tICdiYXNlNjQtYXJyYXlidWZmZXInXG5cdCpcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdhdmF0YXJzJylcblx0KiAgIC51cGRhdGUoJ3B1YmxpYy9hdmF0YXIxLnBuZycsIGRlY29kZSgnYmFzZTY0RmlsZURhdGEnKSwge1xuXHQqICAgICBjb250ZW50VHlwZTogJ2ltYWdlL3BuZydcblx0KiAgIH0pXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIHVwZGF0ZShwYXRoLCBmaWxlQm9keSwgZmlsZU9wdGlvbnMpIHtcblx0XHRyZXR1cm4gdGhpcy51cGxvYWRPclVwZGF0ZShcIlBVVFwiLCBwYXRoLCBmaWxlQm9keSwgZmlsZU9wdGlvbnMpO1xuXHR9XG5cdC8qKlxuXHQqIE1vdmVzIGFuIGV4aXN0aW5nIGZpbGUgdG8gYSBuZXcgcGF0aCBpbiB0aGUgc2FtZSBidWNrZXQuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIGZyb21QYXRoIFRoZSBvcmlnaW5hbCBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgY3VycmVudCBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UucG5nYC5cblx0KiBAcGFyYW0gdG9QYXRoIFRoZSBuZXcgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIG5ldyBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UtbmV3LnBuZ2AuXG5cdCogQHBhcmFtIG9wdGlvbnMgVGhlIGRlc3RpbmF0aW9uIG9wdGlvbnMuXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgc3VjY2VzcyBtZXNzYWdlIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBNb3ZlIGZpbGVcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLm1vdmUoJ3B1YmxpYy9hdmF0YXIxLnBuZycsICdwcml2YXRlL2F2YXRhcjIucG5nJylcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjoge1xuXHQqICAgICBcIm1lc3NhZ2VcIjogXCJTdWNjZXNzZnVsbHkgbW92ZWRcIlxuXHQqICAgfSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgbW92ZShmcm9tUGF0aCwgdG9QYXRoLCBvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzNiA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHBvc3QkMShfdGhpczYuZmV0Y2gsIGAke190aGlzNi51cmx9L29iamVjdC9tb3ZlYCwge1xuXHRcdFx0XHRcdGJ1Y2tldElkOiBfdGhpczYuYnVja2V0SWQsXG5cdFx0XHRcdFx0c291cmNlS2V5OiBmcm9tUGF0aCxcblx0XHRcdFx0XHRkZXN0aW5hdGlvbktleTogdG9QYXRoLFxuXHRcdFx0XHRcdGRlc3RpbmF0aW9uQnVja2V0OiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVzdGluYXRpb25CdWNrZXRcblx0XHRcdFx0fSwgeyBoZWFkZXJzOiBfdGhpczYuaGVhZGVycyB9KSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczYuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQqIENvcGllcyBhbiBleGlzdGluZyBmaWxlIHRvIGEgbmV3IHBhdGggaW4gdGhlIHNhbWUgYnVja2V0LlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBmcm9tUGF0aCBUaGUgb3JpZ2luYWwgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG5cdCogQHBhcmFtIHRvUGF0aCBUaGUgbmV3IGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBuZXcgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLWNvcHkucG5nYC5cblx0KiBAcGFyYW0gb3B0aW9ucyBUaGUgZGVzdGluYXRpb24gb3B0aW9ucy5cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBjb3BpZWQgZmlsZSBwYXRoIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBDb3B5IGZpbGVcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmNvcHkoJ3B1YmxpYy9hdmF0YXIxLnBuZycsICdwcml2YXRlL2F2YXRhcjIucG5nJylcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjoge1xuXHQqICAgICBcInBhdGhcIjogXCJhdmF0YXJzL3ByaXZhdGUvYXZhdGFyMi5wbmdcIlxuXHQqICAgfSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgY29weShmcm9tUGF0aCwgdG9QYXRoLCBvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzNyA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IHsgcGF0aDogKGF3YWl0IHBvc3QkMShfdGhpczcuZmV0Y2gsIGAke190aGlzNy51cmx9L29iamVjdC9jb3B5YCwge1xuXHRcdFx0XHRcdGJ1Y2tldElkOiBfdGhpczcuYnVja2V0SWQsXG5cdFx0XHRcdFx0c291cmNlS2V5OiBmcm9tUGF0aCxcblx0XHRcdFx0XHRkZXN0aW5hdGlvbktleTogdG9QYXRoLFxuXHRcdFx0XHRcdGRlc3RpbmF0aW9uQnVja2V0OiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVzdGluYXRpb25CdWNrZXRcblx0XHRcdFx0fSwgeyBoZWFkZXJzOiBfdGhpczcuaGVhZGVycyB9KSkuS2V5IH0sXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXM3LnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKipcblx0KiBDcmVhdGVzIGEgc2lnbmVkIFVSTC4gVXNlIGEgc2lnbmVkIFVSTCB0byBzaGFyZSBhIGZpbGUgZm9yIGEgZml4ZWQgYW1vdW50IG9mIHRpbWUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIHBhdGggVGhlIGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBjdXJyZW50IGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuXHQqIEBwYXJhbSBleHBpcmVzSW4gVGhlIG51bWJlciBvZiBzZWNvbmRzIHVudGlsIHRoZSBzaWduZWQgVVJMIGV4cGlyZXMuIEZvciBleGFtcGxlLCBgNjBgIGZvciBhIFVSTCB3aGljaCBpcyB2YWxpZCBmb3Igb25lIG1pbnV0ZS5cblx0KiBAcGFyYW0gb3B0aW9ucy5kb3dubG9hZCB0cmlnZ2VycyB0aGUgZmlsZSBhcyBhIGRvd25sb2FkIGlmIHNldCB0byB0cnVlLiBTZXQgdGhpcyBwYXJhbWV0ZXIgYXMgdGhlIG5hbWUgb2YgdGhlIGZpbGUgaWYgeW91IHdhbnQgdG8gdHJpZ2dlciB0aGUgZG93bmxvYWQgd2l0aCBhIGRpZmZlcmVudCBmaWxlbmFtZS5cblx0KiBAcGFyYW0gb3B0aW9ucy50cmFuc2Zvcm0gVHJhbnNmb3JtIHRoZSBhc3NldCBiZWZvcmUgc2VydmluZyBpdCB0byB0aGUgY2xpZW50LlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIHNpZ25lZCBVUkwgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIENyZWF0ZSBTaWduZWQgVVJMXG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdhdmF0YXJzJylcblx0KiAgIC5jcmVhdGVTaWduZWRVcmwoJ2ZvbGRlci9hdmF0YXIxLnBuZycsIDYwKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiB7XG5cdCogICAgIFwic2lnbmVkVXJsXCI6IFwiaHR0cHM6Ly9leGFtcGxlLnN1cGFiYXNlLmNvL3N0b3JhZ2UvdjEvb2JqZWN0L3NpZ24vYXZhdGFycy9mb2xkZXIvYXZhdGFyMS5wbmc/dG9rZW49PFRPS0VOPlwiXG5cdCogICB9LFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqXG5cdCogQGV4YW1wbGUgQ3JlYXRlIGEgc2lnbmVkIFVSTCBmb3IgYW4gYXNzZXQgd2l0aCB0cmFuc2Zvcm1hdGlvbnNcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAuY3JlYXRlU2lnbmVkVXJsKCdmb2xkZXIvYXZhdGFyMS5wbmcnLCA2MCwge1xuXHQqICAgICB0cmFuc2Zvcm06IHtcblx0KiAgICAgICB3aWR0aDogMTAwLFxuXHQqICAgICAgIGhlaWdodDogMTAwLFxuXHQqICAgICB9XG5cdCogICB9KVxuXHQqIGBgYFxuXHQqXG5cdCogQGV4YW1wbGUgQ3JlYXRlIGEgc2lnbmVkIFVSTCB3aGljaCB0cmlnZ2VycyB0aGUgZG93bmxvYWQgb2YgdGhlIGFzc2V0XG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmNyZWF0ZVNpZ25lZFVybCgnZm9sZGVyL2F2YXRhcjEucG5nJywgNjAsIHtcblx0KiAgICAgZG93bmxvYWQ6IHRydWUsXG5cdCogICB9KVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBjcmVhdGVTaWduZWRVcmwocGF0aCwgZXhwaXJlc0luLCBvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzOCA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdGxldCBfcGF0aCA9IF90aGlzOC5fZ2V0RmluYWxQYXRoKHBhdGgpO1xuXHRcdFx0bGV0IGRhdGEgPSBhd2FpdCBwb3N0JDEoX3RoaXM4LmZldGNoLCBgJHtfdGhpczgudXJsfS9vYmplY3Qvc2lnbi8ke19wYXRofWAsIF9vYmplY3RTcHJlYWQyKHsgZXhwaXJlc0luIH0sIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhbnNmb3JtKSA/IHsgdHJhbnNmb3JtOiBvcHRpb25zLnRyYW5zZm9ybSB9IDoge30pLCB7IGhlYWRlcnM6IF90aGlzOC5oZWFkZXJzIH0pO1xuXHRcdFx0Y29uc3QgZG93bmxvYWRRdWVyeVBhcmFtID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kb3dubG9hZCkgPyBgJmRvd25sb2FkPSR7b3B0aW9ucy5kb3dubG9hZCA9PT0gdHJ1ZSA/IFwiXCIgOiBvcHRpb25zLmRvd25sb2FkfWAgOiBcIlwiO1xuXHRcdFx0ZGF0YSA9IHsgc2lnbmVkVXJsOiBlbmNvZGVVUkkoYCR7X3RoaXM4LnVybH0ke2RhdGEuc2lnbmVkVVJMfSR7ZG93bmxvYWRRdWVyeVBhcmFtfWApIH07XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzOC5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqXG5cdCogQ3JlYXRlcyBtdWx0aXBsZSBzaWduZWQgVVJMcy4gVXNlIGEgc2lnbmVkIFVSTCB0byBzaGFyZSBhIGZpbGUgZm9yIGEgZml4ZWQgYW1vdW50IG9mIHRpbWUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIHBhdGhzIFRoZSBmaWxlIHBhdGhzIHRvIGJlIGRvd25sb2FkZWQsIGluY2x1ZGluZyB0aGUgY3VycmVudCBmaWxlIG5hbWVzLiBGb3IgZXhhbXBsZSBgWydmb2xkZXIvaW1hZ2UucG5nJywgJ2ZvbGRlcjIvaW1hZ2UyLnBuZyddYC5cblx0KiBAcGFyYW0gZXhwaXJlc0luIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyB1bnRpbCB0aGUgc2lnbmVkIFVSTHMgZXhwaXJlLiBGb3IgZXhhbXBsZSwgYDYwYCBmb3IgVVJMcyB3aGljaCBhcmUgdmFsaWQgZm9yIG9uZSBtaW51dGUuXG5cdCogQHBhcmFtIG9wdGlvbnMuZG93bmxvYWQgdHJpZ2dlcnMgdGhlIGZpbGUgYXMgYSBkb3dubG9hZCBpZiBzZXQgdG8gdHJ1ZS4gU2V0IHRoaXMgcGFyYW1ldGVyIGFzIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGlmIHlvdSB3YW50IHRvIHRyaWdnZXIgdGhlIGRvd25sb2FkIHdpdGggYSBkaWZmZXJlbnQgZmlsZW5hbWUuXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIHNpZ25lZFVybCwgcGF0aCwgYW5kIGVycm9yIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBDcmVhdGUgU2lnbmVkIFVSTHNcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmNyZWF0ZVNpZ25lZFVybHMoWydmb2xkZXIvYXZhdGFyMS5wbmcnLCAnZm9sZGVyL2F2YXRhcjIucG5nJ10sIDYwKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiBbXG5cdCogICAgIHtcblx0KiAgICAgICBcImVycm9yXCI6IG51bGwsXG5cdCogICAgICAgXCJwYXRoXCI6IFwiZm9sZGVyL2F2YXRhcjEucG5nXCIsXG5cdCogICAgICAgXCJzaWduZWRVUkxcIjogXCIvb2JqZWN0L3NpZ24vYXZhdGFycy9mb2xkZXIvYXZhdGFyMS5wbmc/dG9rZW49PFRPS0VOPlwiLFxuXHQqICAgICAgIFwic2lnbmVkVXJsXCI6IFwiaHR0cHM6Ly9leGFtcGxlLnN1cGFiYXNlLmNvL3N0b3JhZ2UvdjEvb2JqZWN0L3NpZ24vYXZhdGFycy9mb2xkZXIvYXZhdGFyMS5wbmc/dG9rZW49PFRPS0VOPlwiXG5cdCogICAgIH0sXG5cdCogICAgIHtcblx0KiAgICAgICBcImVycm9yXCI6IG51bGwsXG5cdCogICAgICAgXCJwYXRoXCI6IFwiZm9sZGVyL2F2YXRhcjIucG5nXCIsXG5cdCogICAgICAgXCJzaWduZWRVUkxcIjogXCIvb2JqZWN0L3NpZ24vYXZhdGFycy9mb2xkZXIvYXZhdGFyMi5wbmc/dG9rZW49PFRPS0VOPlwiLFxuXHQqICAgICAgIFwic2lnbmVkVXJsXCI6IFwiaHR0cHM6Ly9leGFtcGxlLnN1cGFiYXNlLmNvL3N0b3JhZ2UvdjEvb2JqZWN0L3NpZ24vYXZhdGFycy9mb2xkZXIvYXZhdGFyMi5wbmc/dG9rZW49PFRPS0VOPlwiXG5cdCogICAgIH1cblx0KiAgIF0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGNyZWF0ZVNpZ25lZFVybHMocGF0aHMsIGV4cGlyZXNJbiwgb3B0aW9ucykge1xuXHRcdHZhciBfdGhpczkgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBkYXRhID0gYXdhaXQgcG9zdCQxKF90aGlzOS5mZXRjaCwgYCR7X3RoaXM5LnVybH0vb2JqZWN0L3NpZ24vJHtfdGhpczkuYnVja2V0SWR9YCwge1xuXHRcdFx0XHRleHBpcmVzSW4sXG5cdFx0XHRcdHBhdGhzXG5cdFx0XHR9LCB7IGhlYWRlcnM6IF90aGlzOS5oZWFkZXJzIH0pO1xuXHRcdFx0Y29uc3QgZG93bmxvYWRRdWVyeVBhcmFtID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kb3dubG9hZCkgPyBgJmRvd25sb2FkPSR7b3B0aW9ucy5kb3dubG9hZCA9PT0gdHJ1ZSA/IFwiXCIgOiBvcHRpb25zLmRvd25sb2FkfWAgOiBcIlwiO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogZGF0YS5tYXAoKGRhdHVtKSA9PiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZGF0dW0pLCB7fSwgeyBzaWduZWRVcmw6IGRhdHVtLnNpZ25lZFVSTCA/IGVuY29kZVVSSShgJHtfdGhpczkudXJsfSR7ZGF0dW0uc2lnbmVkVVJMfSR7ZG93bmxvYWRRdWVyeVBhcmFtfWApIDogbnVsbCB9KSksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXM5LnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKipcblx0KiBEb3dubG9hZHMgYSBmaWxlIGZyb20gYSBwcml2YXRlIGJ1Y2tldC4gRm9yIHB1YmxpYyBidWNrZXRzLCBtYWtlIGEgcmVxdWVzdCB0byB0aGUgVVJMIHJldHVybmVkIGZyb20gYGdldFB1YmxpY1VybGAgaW5zdGVhZC5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gcGF0aCBUaGUgZnVsbCBwYXRoIGFuZCBmaWxlIG5hbWUgb2YgdGhlIGZpbGUgdG8gYmUgZG93bmxvYWRlZC4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuXHQqIEBwYXJhbSBvcHRpb25zLnRyYW5zZm9ybSBUcmFuc2Zvcm0gdGhlIGFzc2V0IGJlZm9yZSBzZXJ2aW5nIGl0IHRvIHRoZSBjbGllbnQuXG5cdCogQHJldHVybnMgQmxvYkRvd25sb2FkQnVpbGRlciBpbnN0YW5jZSBmb3IgZG93bmxvYWRpbmcgdGhlIGZpbGVcblx0KlxuXHQqIEBleGFtcGxlIERvd25sb2FkIGZpbGVcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmRvd25sb2FkKCdmb2xkZXIvYXZhdGFyMS5wbmcnKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiA8QkxPQj4sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCpcblx0KiBAZXhhbXBsZSBEb3dubG9hZCBmaWxlIHdpdGggdHJhbnNmb3JtYXRpb25zXG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdhdmF0YXJzJylcblx0KiAgIC5kb3dubG9hZCgnZm9sZGVyL2F2YXRhcjEucG5nJywge1xuXHQqICAgICB0cmFuc2Zvcm06IHtcblx0KiAgICAgICB3aWR0aDogMTAwLFxuXHQqICAgICAgIGhlaWdodDogMTAwLFxuXHQqICAgICAgIHF1YWxpdHk6IDgwXG5cdCogICAgIH1cblx0KiAgIH0pXG5cdCogYGBgXG5cdCovXG5cdGRvd25sb2FkKHBhdGgsIG9wdGlvbnMpIHtcblx0XHRjb25zdCByZW5kZXJQYXRoID0gdHlwZW9mIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhbnNmb3JtKSAhPT0gXCJ1bmRlZmluZWRcIiA/IFwicmVuZGVyL2ltYWdlL2F1dGhlbnRpY2F0ZWRcIiA6IFwib2JqZWN0XCI7XG5cdFx0Y29uc3QgdHJhbnNmb3JtYXRpb25RdWVyeSA9IHRoaXMudHJhbnNmb3JtT3B0c1RvUXVlcnlTdHJpbmcoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50cmFuc2Zvcm0pIHx8IHt9KTtcblx0XHRjb25zdCBxdWVyeVN0cmluZyA9IHRyYW5zZm9ybWF0aW9uUXVlcnkgPyBgPyR7dHJhbnNmb3JtYXRpb25RdWVyeX1gIDogXCJcIjtcblx0XHRjb25zdCBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChwYXRoKTtcblx0XHRjb25zdCBkb3dubG9hZEZuID0gKCkgPT4gZ2V0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS8ke3JlbmRlclBhdGh9LyR7X3BhdGh9JHtxdWVyeVN0cmluZ31gLCB7XG5cdFx0XHRoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG5cdFx0XHRub1Jlc29sdmVKc29uOiB0cnVlXG5cdFx0fSk7XG5cdFx0cmV0dXJuIG5ldyBCbG9iRG93bmxvYWRCdWlsZGVyKGRvd25sb2FkRm4sIHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yKTtcblx0fVxuXHQvKipcblx0KiBSZXRyaWV2ZXMgdGhlIGRldGFpbHMgb2YgYW4gZXhpc3RpbmcgZmlsZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gcGF0aCBUaGUgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIGZpbGUgbWV0YWRhdGEgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIEdldCBmaWxlIGluZm9cblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmluZm8oJ2ZvbGRlci9hdmF0YXIxLnBuZycpXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGluZm8ocGF0aCkge1xuXHRcdHZhciBfdGhpczEwID0gdGhpcztcblx0XHRjb25zdCBfcGF0aCA9IF90aGlzMTAuX2dldEZpbmFsUGF0aChwYXRoKTtcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogcmVjdXJzaXZlVG9DYW1lbChhd2FpdCBnZXQoX3RoaXMxMC5mZXRjaCwgYCR7X3RoaXMxMC51cmx9L29iamVjdC9pbmZvLyR7X3BhdGh9YCwgeyBoZWFkZXJzOiBfdGhpczEwLmhlYWRlcnMgfSkpLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzMTAuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQqIENoZWNrcyB0aGUgZXhpc3RlbmNlIG9mIGEgZmlsZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gcGF0aCBUaGUgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIGJvb2xlYW4gaW5kaWNhdGluZyBmaWxlIGV4aXN0ZW5jZSBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgQ2hlY2sgZmlsZSBleGlzdGVuY2Vcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmV4aXN0cygnZm9sZGVyL2F2YXRhcjEucG5nJylcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgZXhpc3RzKHBhdGgpIHtcblx0XHR2YXIgX3RoaXMxMSA9IHRoaXM7XG5cdFx0Y29uc3QgX3BhdGggPSBfdGhpczExLl9nZXRGaW5hbFBhdGgocGF0aCk7XG5cdFx0dHJ5IHtcblx0XHRcdGF3YWl0IGhlYWQoX3RoaXMxMS5mZXRjaCwgYCR7X3RoaXMxMS51cmx9L29iamVjdC8ke19wYXRofWAsIHsgaGVhZGVyczogX3RoaXMxMS5oZWFkZXJzIH0pO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogdHJ1ZSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczExLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpICYmIGVycm9yIGluc3RhbmNlb2YgU3RvcmFnZVVua25vd25FcnJvcikge1xuXHRcdFx0XHRjb25zdCBvcmlnaW5hbEVycm9yID0gZXJyb3Iub3JpZ2luYWxFcnJvcjtcblx0XHRcdFx0aWYgKFs0MDAsIDQwNF0uaW5jbHVkZXMob3JpZ2luYWxFcnJvciA9PT0gbnVsbCB8fCBvcmlnaW5hbEVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbEVycm9yLnN0YXR1cykpIHJldHVybiB7XG5cdFx0XHRcdFx0ZGF0YTogZmFsc2UsXG5cdFx0XHRcdFx0ZXJyb3Jcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKipcblx0KiBBIHNpbXBsZSBjb252ZW5pZW5jZSBmdW5jdGlvbiB0byBnZXQgdGhlIFVSTCBmb3IgYW4gYXNzZXQgaW4gYSBwdWJsaWMgYnVja2V0LiBJZiB5b3UgZG8gbm90IHdhbnQgdG8gdXNlIHRoaXMgZnVuY3Rpb24sIHlvdSBjYW4gY29uc3RydWN0IHRoZSBwdWJsaWMgVVJMIGJ5IGNvbmNhdGVuYXRpbmcgdGhlIGJ1Y2tldCBVUkwgd2l0aCB0aGUgcGF0aCB0byB0aGUgYXNzZXQuXG5cdCogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCB2ZXJpZnkgaWYgdGhlIGJ1Y2tldCBpcyBwdWJsaWMuIElmIGEgcHVibGljIFVSTCBpcyBjcmVhdGVkIGZvciBhIGJ1Y2tldCB3aGljaCBpcyBub3QgcHVibGljLCB5b3Ugd2lsbCBub3QgYmUgYWJsZSB0byBkb3dubG9hZCB0aGUgYXNzZXQuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIHBhdGggVGhlIHBhdGggYW5kIG5hbWUgb2YgdGhlIGZpbGUgdG8gZ2VuZXJhdGUgdGhlIHB1YmxpYyBVUkwgZm9yLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG5cdCogQHBhcmFtIG9wdGlvbnMuZG93bmxvYWQgVHJpZ2dlcnMgdGhlIGZpbGUgYXMgYSBkb3dubG9hZCBpZiBzZXQgdG8gdHJ1ZS4gU2V0IHRoaXMgcGFyYW1ldGVyIGFzIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGlmIHlvdSB3YW50IHRvIHRyaWdnZXIgdGhlIGRvd25sb2FkIHdpdGggYSBkaWZmZXJlbnQgZmlsZW5hbWUuXG5cdCogQHBhcmFtIG9wdGlvbnMudHJhbnNmb3JtIFRyYW5zZm9ybSB0aGUgYXNzZXQgYmVmb3JlIHNlcnZpbmcgaXQgdG8gdGhlIGNsaWVudC5cblx0KiBAcmV0dXJucyBPYmplY3Qgd2l0aCBwdWJsaWMgVVJMXG5cdCpcblx0KiBAZXhhbXBsZSBSZXR1cm5zIHRoZSBVUkwgZm9yIGFuIGFzc2V0IGluIGEgcHVibGljIGJ1Y2tldFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhIH0gPSBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdwdWJsaWMtYnVja2V0Jylcblx0KiAgIC5nZXRQdWJsaWNVcmwoJ2ZvbGRlci9hdmF0YXIxLnBuZycpXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IHtcblx0KiAgICAgXCJwdWJsaWNVcmxcIjogXCJodHRwczovL2V4YW1wbGUuc3VwYWJhc2UuY28vc3RvcmFnZS92MS9vYmplY3QvcHVibGljL3B1YmxpYy1idWNrZXQvZm9sZGVyL2F2YXRhcjEucG5nXCJcblx0KiAgIH1cblx0KiB9XG5cdCogYGBgXG5cdCpcblx0KiBAZXhhbXBsZSBSZXR1cm5zIHRoZSBVUkwgZm9yIGFuIGFzc2V0IGluIGEgcHVibGljIGJ1Y2tldCB3aXRoIHRyYW5zZm9ybWF0aW9uc1xuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhIH0gPSBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdwdWJsaWMtYnVja2V0Jylcblx0KiAgIC5nZXRQdWJsaWNVcmwoJ2ZvbGRlci9hdmF0YXIxLnBuZycsIHtcblx0KiAgICAgdHJhbnNmb3JtOiB7XG5cdCogICAgICAgd2lkdGg6IDEwMCxcblx0KiAgICAgICBoZWlnaHQ6IDEwMCxcblx0KiAgICAgfVxuXHQqICAgfSlcblx0KiBgYGBcblx0KlxuXHQqIEBleGFtcGxlIFJldHVybnMgdGhlIFVSTCB3aGljaCB0cmlnZ2VycyB0aGUgZG93bmxvYWQgb2YgYW4gYXNzZXQgaW4gYSBwdWJsaWMgYnVja2V0XG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEgfSA9IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ3B1YmxpYy1idWNrZXQnKVxuXHQqICAgLmdldFB1YmxpY1VybCgnZm9sZGVyL2F2YXRhcjEucG5nJywge1xuXHQqICAgICBkb3dubG9hZDogdHJ1ZSxcblx0KiAgIH0pXG5cdCogYGBgXG5cdCovXG5cdGdldFB1YmxpY1VybChwYXRoLCBvcHRpb25zKSB7XG5cdFx0Y29uc3QgX3BhdGggPSB0aGlzLl9nZXRGaW5hbFBhdGgocGF0aCk7XG5cdFx0Y29uc3QgX3F1ZXJ5U3RyaW5nID0gW107XG5cdFx0Y29uc3QgZG93bmxvYWRRdWVyeVBhcmFtID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kb3dubG9hZCkgPyBgZG93bmxvYWQ9JHtvcHRpb25zLmRvd25sb2FkID09PSB0cnVlID8gXCJcIiA6IG9wdGlvbnMuZG93bmxvYWR9YCA6IFwiXCI7XG5cdFx0aWYgKGRvd25sb2FkUXVlcnlQYXJhbSAhPT0gXCJcIikgX3F1ZXJ5U3RyaW5nLnB1c2goZG93bmxvYWRRdWVyeVBhcmFtKTtcblx0XHRjb25zdCByZW5kZXJQYXRoID0gdHlwZW9mIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhbnNmb3JtKSAhPT0gXCJ1bmRlZmluZWRcIiA/IFwicmVuZGVyL2ltYWdlXCIgOiBcIm9iamVjdFwiO1xuXHRcdGNvbnN0IHRyYW5zZm9ybWF0aW9uUXVlcnkgPSB0aGlzLnRyYW5zZm9ybU9wdHNUb1F1ZXJ5U3RyaW5nKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhbnNmb3JtKSB8fCB7fSk7XG5cdFx0aWYgKHRyYW5zZm9ybWF0aW9uUXVlcnkgIT09IFwiXCIpIF9xdWVyeVN0cmluZy5wdXNoKHRyYW5zZm9ybWF0aW9uUXVlcnkpO1xuXHRcdGxldCBxdWVyeVN0cmluZyA9IF9xdWVyeVN0cmluZy5qb2luKFwiJlwiKTtcblx0XHRpZiAocXVlcnlTdHJpbmcgIT09IFwiXCIpIHF1ZXJ5U3RyaW5nID0gYD8ke3F1ZXJ5U3RyaW5nfWA7XG5cdFx0cmV0dXJuIHsgZGF0YTogeyBwdWJsaWNVcmw6IGVuY29kZVVSSShgJHt0aGlzLnVybH0vJHtyZW5kZXJQYXRofS9wdWJsaWMvJHtfcGF0aH0ke3F1ZXJ5U3RyaW5nfWApIH0gfTtcblx0fVxuXHQvKipcblx0KiBEZWxldGVzIGZpbGVzIHdpdGhpbiB0aGUgc2FtZSBidWNrZXRcblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gcGF0aHMgQW4gYXJyYXkgb2YgZmlsZXMgdG8gZGVsZXRlLCBpbmNsdWRpbmcgdGhlIHBhdGggYW5kIGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgW2AnZm9sZGVyL2ltYWdlLnBuZydgXS5cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBhcnJheSBvZiBkZWxldGVkIGZpbGUgb2JqZWN0cyBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgRGVsZXRlIGZpbGVcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLnJlbW92ZShbJ2ZvbGRlci9hdmF0YXIxLnBuZyddKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiBbXSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgcmVtb3ZlKHBhdGhzKSB7XG5cdFx0dmFyIF90aGlzMTIgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCByZW1vdmUoX3RoaXMxMi5mZXRjaCwgYCR7X3RoaXMxMi51cmx9L29iamVjdC8ke190aGlzMTIuYnVja2V0SWR9YCwgeyBwcmVmaXhlczogcGF0aHMgfSwgeyBoZWFkZXJzOiBfdGhpczEyLmhlYWRlcnMgfSksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMxMi5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqXG5cdCogR2V0IGZpbGUgbWV0YWRhdGFcblx0KiBAcGFyYW0gaWQgdGhlIGZpbGUgaWQgdG8gcmV0cmlldmUgbWV0YWRhdGFcblx0Ki9cblx0LyoqXG5cdCogVXBkYXRlIGZpbGUgbWV0YWRhdGFcblx0KiBAcGFyYW0gaWQgdGhlIGZpbGUgaWQgdG8gdXBkYXRlIG1ldGFkYXRhXG5cdCogQHBhcmFtIG1ldGEgdGhlIG5ldyBmaWxlIG1ldGFkYXRhXG5cdCovXG5cdC8qKlxuXHQqIExpc3RzIGFsbCB0aGUgZmlsZXMgYW5kIGZvbGRlcnMgd2l0aGluIGEgcGF0aCBvZiB0aGUgYnVja2V0LlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBwYXRoIFRoZSBmb2xkZXIgcGF0aC5cblx0KiBAcGFyYW0gb3B0aW9ucyBTZWFyY2ggb3B0aW9ucyBpbmNsdWRpbmcgbGltaXQgKGRlZmF1bHRzIHRvIDEwMCksIG9mZnNldCwgc29ydEJ5LCBhbmQgc2VhcmNoXG5cdCogQHBhcmFtIHBhcmFtZXRlcnMgT3B0aW9uYWwgZmV0Y2ggcGFyYW1ldGVycyBpbmNsdWRpbmcgc2lnbmFsIGZvciBjYW5jZWxsYXRpb25cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBhcnJheSBvZiBmaWxlcyBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgTGlzdCBmaWxlcyBpbiBhIGJ1Y2tldFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAubGlzdCgnZm9sZGVyJywge1xuXHQqICAgICBsaW1pdDogMTAwLFxuXHQqICAgICBvZmZzZXQ6IDAsXG5cdCogICAgIHNvcnRCeTogeyBjb2x1bW46ICduYW1lJywgb3JkZXI6ICdhc2MnIH0sXG5cdCogICB9KVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiBbXG5cdCogICAgIHtcblx0KiAgICAgICBcIm5hbWVcIjogXCJhdmF0YXIxLnBuZ1wiLFxuXHQqICAgICAgIFwiaWRcIjogXCJlNjY4Y2Y3Zi04MjFiLTRhMmYtOWRjZS03ZGZhNWRkMWNmZDJcIixcblx0KiAgICAgICBcInVwZGF0ZWRfYXRcIjogXCIyMDI0LTA1LTIyVDIzOjA2OjA1LjU4MFpcIixcblx0KiAgICAgICBcImNyZWF0ZWRfYXRcIjogXCIyMDI0LTA1LTIyVDIzOjA0OjM0LjQ0M1pcIixcblx0KiAgICAgICBcImxhc3RfYWNjZXNzZWRfYXRcIjogXCIyMDI0LTA1LTIyVDIzOjA0OjM0LjQ0M1pcIixcblx0KiAgICAgICBcIm1ldGFkYXRhXCI6IHtcblx0KiAgICAgICAgIFwiZVRhZ1wiOiBcIlxcXCJjNWU4YzU1MzIzNWQ5YWYzMGVmNGY2ZTI4MDc5MGI5MlxcXCJcIixcblx0KiAgICAgICAgIFwic2l6ZVwiOiAzMjE3NSxcblx0KiAgICAgICAgIFwibWltZXR5cGVcIjogXCJpbWFnZS9wbmdcIixcblx0KiAgICAgICAgIFwiY2FjaGVDb250cm9sXCI6IFwibWF4LWFnZT0zNjAwXCIsXG5cdCogICAgICAgICBcImxhc3RNb2RpZmllZFwiOiBcIjIwMjQtMDUtMjJUMjM6MDY6MDUuNTc0WlwiLFxuXHQqICAgICAgICAgXCJjb250ZW50TGVuZ3RoXCI6IDMyMTc1LFxuXHQqICAgICAgICAgXCJodHRwU3RhdHVzQ29kZVwiOiAyMDBcblx0KiAgICAgICB9XG5cdCogICAgIH1cblx0KiAgIF0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCpcblx0KiBAZXhhbXBsZSBTZWFyY2ggZmlsZXMgaW4gYSBidWNrZXRcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmxpc3QoJ2ZvbGRlcicsIHtcblx0KiAgICAgbGltaXQ6IDEwMCxcblx0KiAgICAgb2Zmc2V0OiAwLFxuXHQqICAgICBzb3J0Qnk6IHsgY29sdW1uOiAnbmFtZScsIG9yZGVyOiAnYXNjJyB9LFxuXHQqICAgICBzZWFyY2g6ICdqb24nXG5cdCogICB9KVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBsaXN0KHBhdGgsIG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcblx0XHR2YXIgX3RoaXMxMyA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IGJvZHkgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9TRUFSQ0hfT1BUSU9OUyksIG9wdGlvbnMpLCB7fSwgeyBwcmVmaXg6IHBhdGggfHwgXCJcIiB9KTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHBvc3QkMShfdGhpczEzLmZldGNoLCBgJHtfdGhpczEzLnVybH0vb2JqZWN0L2xpc3QvJHtfdGhpczEzLmJ1Y2tldElkfWAsIGJvZHksIHsgaGVhZGVyczogX3RoaXMxMy5oZWFkZXJzIH0sIHBhcmFtZXRlcnMpLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzMTMuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQqIEBleHBlcmltZW50YWwgdGhpcyBtZXRob2Qgc2lnbmF0dXJlIG1pZ2h0IGNoYW5nZSBpbiB0aGUgZnV0dXJlXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIG9wdGlvbnMgc2VhcmNoIG9wdGlvbnNcblx0KiBAcGFyYW0gcGFyYW1ldGVyc1xuXHQqL1xuXHRhc3luYyBsaXN0VjIob3B0aW9ucywgcGFyYW1ldGVycykge1xuXHRcdHZhciBfdGhpczE0ID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgYm9keSA9IF9vYmplY3RTcHJlYWQyKHt9LCBvcHRpb25zKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHBvc3QkMShfdGhpczE0LmZldGNoLCBgJHtfdGhpczE0LnVybH0vb2JqZWN0L2xpc3QtdjIvJHtfdGhpczE0LmJ1Y2tldElkfWAsIGJvZHksIHsgaGVhZGVyczogX3RoaXMxNC5oZWFkZXJzIH0sIHBhcmFtZXRlcnMpLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzMTQuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdGVuY29kZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKTtcblx0fVxuXHR0b0Jhc2U2NChkYXRhKSB7XG5cdFx0aWYgKHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBCdWZmZXIuZnJvbShkYXRhKS50b1N0cmluZyhcImJhc2U2NFwiKTtcblx0XHRyZXR1cm4gYnRvYShkYXRhKTtcblx0fVxuXHRfZ2V0RmluYWxQYXRoKHBhdGgpIHtcblx0XHRyZXR1cm4gYCR7dGhpcy5idWNrZXRJZH0vJHtwYXRoLnJlcGxhY2UoL15cXC8rLywgXCJcIil9YDtcblx0fVxuXHRfcmVtb3ZlRW1wdHlGb2xkZXJzKHBhdGgpIHtcblx0XHRyZXR1cm4gcGF0aC5yZXBsYWNlKC9eXFwvfFxcLyQvZywgXCJcIikucmVwbGFjZSgvXFwvKy9nLCBcIi9cIik7XG5cdH1cblx0dHJhbnNmb3JtT3B0c1RvUXVlcnlTdHJpbmcodHJhbnNmb3JtKSB7XG5cdFx0Y29uc3QgcGFyYW1zID0gW107XG5cdFx0aWYgKHRyYW5zZm9ybS53aWR0aCkgcGFyYW1zLnB1c2goYHdpZHRoPSR7dHJhbnNmb3JtLndpZHRofWApO1xuXHRcdGlmICh0cmFuc2Zvcm0uaGVpZ2h0KSBwYXJhbXMucHVzaChgaGVpZ2h0PSR7dHJhbnNmb3JtLmhlaWdodH1gKTtcblx0XHRpZiAodHJhbnNmb3JtLnJlc2l6ZSkgcGFyYW1zLnB1c2goYHJlc2l6ZT0ke3RyYW5zZm9ybS5yZXNpemV9YCk7XG5cdFx0aWYgKHRyYW5zZm9ybS5mb3JtYXQpIHBhcmFtcy5wdXNoKGBmb3JtYXQ9JHt0cmFuc2Zvcm0uZm9ybWF0fWApO1xuXHRcdGlmICh0cmFuc2Zvcm0ucXVhbGl0eSkgcGFyYW1zLnB1c2goYHF1YWxpdHk9JHt0cmFuc2Zvcm0ucXVhbGl0eX1gKTtcblx0XHRyZXR1cm4gcGFyYW1zLmpvaW4oXCImXCIpO1xuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvbGliL3ZlcnNpb24udHNcbmNvbnN0IHZlcnNpb24gPSBcIjIuOTEuMFwiO1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvbGliL2NvbnN0YW50cy50c1xuY29uc3QgREVGQVVMVF9IRUFERVJTJDEgPSB7IFwiWC1DbGllbnQtSW5mb1wiOiBgc3RvcmFnZS1qcy8ke3ZlcnNpb259YCB9O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvcGFja2FnZXMvU3RvcmFnZUJ1Y2tldEFwaS50c1xudmFyIFN0b3JhZ2VCdWNrZXRBcGkgPSBjbGFzcyB7XG5cdGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycyA9IHt9LCBmZXRjaCQxLCBvcHRzKSB7XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSBmYWxzZTtcblx0XHRjb25zdCBiYXNlVXJsID0gbmV3IFVSTCh1cmwpO1xuXHRcdGlmIChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMudXNlTmV3SG9zdG5hbWUpIHtcblx0XHRcdGlmICgvc3VwYWJhc2VcXC4oY298aW58cmVkKSQvLnRlc3QoYmFzZVVybC5ob3N0bmFtZSkgJiYgIWJhc2VVcmwuaG9zdG5hbWUuaW5jbHVkZXMoXCJzdG9yYWdlLnN1cGFiYXNlLlwiKSkgYmFzZVVybC5ob3N0bmFtZSA9IGJhc2VVcmwuaG9zdG5hbWUucmVwbGFjZShcInN1cGFiYXNlLlwiLCBcInN0b3JhZ2Uuc3VwYWJhc2UuXCIpO1xuXHRcdH1cblx0XHR0aGlzLnVybCA9IGJhc2VVcmwuaHJlZi5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG5cdFx0dGhpcy5oZWFkZXJzID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIERFRkFVTFRfSEVBREVSUyQxKSwgaGVhZGVycyk7XG5cdFx0dGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaCQxKGZldGNoJDEpO1xuXHR9XG5cdC8qKlxuXHQqIEVuYWJsZSB0aHJvd2luZyBlcnJvcnMgaW5zdGVhZCBvZiByZXR1cm5pbmcgdGhlbS5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0Ki9cblx0dGhyb3dPbkVycm9yKCkge1xuXHRcdHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gdHJ1ZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBSZXRyaWV2ZXMgdGhlIGRldGFpbHMgb2YgYWxsIFN0b3JhZ2UgYnVja2V0cyB3aXRoaW4gYW4gZXhpc3RpbmcgcHJvamVjdC5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gb3B0aW9ucyBRdWVyeSBwYXJhbWV0ZXJzIGZvciBsaXN0aW5nIGJ1Y2tldHNcblx0KiBAcGFyYW0gb3B0aW9ucy5saW1pdCBNYXhpbXVtIG51bWJlciBvZiBidWNrZXRzIHRvIHJldHVyblxuXHQqIEBwYXJhbSBvcHRpb25zLm9mZnNldCBOdW1iZXIgb2YgYnVja2V0cyB0byBza2lwXG5cdCogQHBhcmFtIG9wdGlvbnMuc29ydENvbHVtbiBDb2x1bW4gdG8gc29ydCBieSAoJ2lkJywgJ25hbWUnLCAnY3JlYXRlZF9hdCcsICd1cGRhdGVkX2F0Jylcblx0KiBAcGFyYW0gb3B0aW9ucy5zb3J0T3JkZXIgU29ydCBvcmRlciAoJ2FzYycgb3IgJ2Rlc2MnKVxuXHQqIEBwYXJhbSBvcHRpb25zLnNlYXJjaCBTZWFyY2ggdGVybSB0byBmaWx0ZXIgYnVja2V0IG5hbWVzXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgYXJyYXkgb2YgYnVja2V0cyBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgTGlzdCBidWNrZXRzXG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5saXN0QnVja2V0cygpXG5cdCogYGBgXG5cdCpcblx0KiBAZXhhbXBsZSBMaXN0IGJ1Y2tldHMgd2l0aCBvcHRpb25zXG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5saXN0QnVja2V0cyh7XG5cdCogICAgIGxpbWl0OiAxMCxcblx0KiAgICAgb2Zmc2V0OiAwLFxuXHQqICAgICBzb3J0Q29sdW1uOiAnY3JlYXRlZF9hdCcsXG5cdCogICAgIHNvcnRPcmRlcjogJ2Rlc2MnLFxuXHQqICAgICBzZWFyY2g6ICdwcm9kJ1xuXHQqICAgfSlcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgbGlzdEJ1Y2tldHMob3B0aW9ucykge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHF1ZXJ5U3RyaW5nID0gX3RoaXMubGlzdEJ1Y2tldE9wdGlvbnNUb1F1ZXJ5U3RyaW5nKG9wdGlvbnMpO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgZ2V0KF90aGlzLmZldGNoLCBgJHtfdGhpcy51cmx9L2J1Y2tldCR7cXVlcnlTdHJpbmd9YCwgeyBoZWFkZXJzOiBfdGhpcy5oZWFkZXJzIH0pLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKipcblx0KiBSZXRyaWV2ZXMgdGhlIGRldGFpbHMgb2YgYW4gZXhpc3RpbmcgU3RvcmFnZSBidWNrZXQuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgYnVja2V0IHlvdSB3b3VsZCBsaWtlIHRvIHJldHJpZXZlLlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIGJ1Y2tldCBkZXRhaWxzIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBHZXQgYnVja2V0XG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5nZXRCdWNrZXQoJ2F2YXRhcnMnKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiB7XG5cdCogICAgIFwiaWRcIjogXCJhdmF0YXJzXCIsXG5cdCogICAgIFwibmFtZVwiOiBcImF2YXRhcnNcIixcblx0KiAgICAgXCJvd25lclwiOiBcIlwiLFxuXHQqICAgICBcInB1YmxpY1wiOiBmYWxzZSxcblx0KiAgICAgXCJmaWxlX3NpemVfbGltaXRcIjogMTAyNCxcblx0KiAgICAgXCJhbGxvd2VkX21pbWVfdHlwZXNcIjogW1xuXHQqICAgICAgIFwiaW1hZ2UvcG5nXCJcblx0KiAgICAgXSxcblx0KiAgICAgXCJjcmVhdGVkX2F0XCI6IFwiMjAyNC0wNS0yMlQyMjoyNjowNS4xMDBaXCIsXG5cdCogICAgIFwidXBkYXRlZF9hdFwiOiBcIjIwMjQtMDUtMjJUMjI6MjY6MDUuMTAwWlwiXG5cdCogICB9LFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBnZXRCdWNrZXQoaWQpIHtcblx0XHR2YXIgX3RoaXMyID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgZ2V0KF90aGlzMi5mZXRjaCwgYCR7X3RoaXMyLnVybH0vYnVja2V0LyR7aWR9YCwgeyBoZWFkZXJzOiBfdGhpczIuaGVhZGVycyB9KSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczIuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQqIENyZWF0ZXMgYSBuZXcgU3RvcmFnZSBidWNrZXRcblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gaWQgQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGJ1Y2tldCB5b3UgYXJlIGNyZWF0aW5nLlxuXHQqIEBwYXJhbSBvcHRpb25zLnB1YmxpYyBUaGUgdmlzaWJpbGl0eSBvZiB0aGUgYnVja2V0LiBQdWJsaWMgYnVja2V0cyBkb24ndCByZXF1aXJlIGFuIGF1dGhvcml6YXRpb24gdG9rZW4gdG8gZG93bmxvYWQgb2JqZWN0cywgYnV0IHN0aWxsIHJlcXVpcmUgYSB2YWxpZCB0b2tlbiBmb3IgYWxsIG90aGVyIG9wZXJhdGlvbnMuIEJ5IGRlZmF1bHQsIGJ1Y2tldHMgYXJlIHByaXZhdGUuXG5cdCogQHBhcmFtIG9wdGlvbnMuZmlsZVNpemVMaW1pdCBzcGVjaWZpZXMgdGhlIG1heCBmaWxlIHNpemUgaW4gYnl0ZXMgdGhhdCBjYW4gYmUgdXBsb2FkZWQgdG8gdGhpcyBidWNrZXQuXG5cdCogVGhlIGdsb2JhbCBmaWxlIHNpemUgbGltaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRoaXMgdmFsdWUuXG5cdCogVGhlIGRlZmF1bHQgdmFsdWUgaXMgbnVsbCwgd2hpY2ggZG9lc24ndCBzZXQgYSBwZXIgYnVja2V0IGZpbGUgc2l6ZSBsaW1pdC5cblx0KiBAcGFyYW0gb3B0aW9ucy5hbGxvd2VkTWltZVR5cGVzIHNwZWNpZmllcyB0aGUgYWxsb3dlZCBtaW1lIHR5cGVzIHRoYXQgdGhpcyBidWNrZXQgY2FuIGFjY2VwdCBkdXJpbmcgdXBsb2FkLlxuXHQqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIG51bGwsIHdoaWNoIGFsbG93cyBmaWxlcyB3aXRoIGFsbCBtaW1lIHR5cGVzIHRvIGJlIHVwbG9hZGVkLlxuXHQqIEVhY2ggbWltZSB0eXBlIHNwZWNpZmllZCBjYW4gYmUgYSB3aWxkY2FyZCwgZS5nLiBpbWFnZS8qLCBvciBhIHNwZWNpZmljIG1pbWUgdHlwZSwgZS5nLiBpbWFnZS9wbmcuXG5cdCogQHBhcmFtIG9wdGlvbnMudHlwZSAocHJpdmF0ZS1iZXRhKSBzcGVjaWZpZXMgdGhlIGJ1Y2tldCB0eXBlLiBzZWUgYEJ1Y2tldFR5cGVgIGZvciBtb3JlIGRldGFpbHMuXG5cdCogICAtIGRlZmF1bHQgYnVja2V0IHR5cGUgaXMgYFNUQU5EQVJEYFxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIG5ld2x5IGNyZWF0ZWQgYnVja2V0IG5hbWUgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIENyZWF0ZSBidWNrZXRcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmNyZWF0ZUJ1Y2tldCgnYXZhdGFycycsIHtcblx0KiAgICAgcHVibGljOiBmYWxzZSxcblx0KiAgICAgYWxsb3dlZE1pbWVUeXBlczogWydpbWFnZS9wbmcnXSxcblx0KiAgICAgZmlsZVNpemVMaW1pdDogMTAyNFxuXHQqICAgfSlcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjoge1xuXHQqICAgICBcIm5hbWVcIjogXCJhdmF0YXJzXCJcblx0KiAgIH0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGNyZWF0ZUJ1Y2tldChpZCwgb3B0aW9ucyA9IHsgcHVibGljOiBmYWxzZSB9KSB7XG5cdFx0dmFyIF90aGlzMyA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHBvc3QkMShfdGhpczMuZmV0Y2gsIGAke190aGlzMy51cmx9L2J1Y2tldGAsIHtcblx0XHRcdFx0XHRpZCxcblx0XHRcdFx0XHRuYW1lOiBpZCxcblx0XHRcdFx0XHR0eXBlOiBvcHRpb25zLnR5cGUsXG5cdFx0XHRcdFx0cHVibGljOiBvcHRpb25zLnB1YmxpYyxcblx0XHRcdFx0XHRmaWxlX3NpemVfbGltaXQ6IG9wdGlvbnMuZmlsZVNpemVMaW1pdCxcblx0XHRcdFx0XHRhbGxvd2VkX21pbWVfdHlwZXM6IG9wdGlvbnMuYWxsb3dlZE1pbWVUeXBlc1xuXHRcdFx0XHR9LCB7IGhlYWRlcnM6IF90aGlzMy5oZWFkZXJzIH0pLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzMy5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqXG5cdCogVXBkYXRlcyBhIFN0b3JhZ2UgYnVja2V0XG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIGlkIEEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBidWNrZXQgeW91IGFyZSB1cGRhdGluZy5cblx0KiBAcGFyYW0gb3B0aW9ucy5wdWJsaWMgVGhlIHZpc2liaWxpdHkgb2YgdGhlIGJ1Y2tldC4gUHVibGljIGJ1Y2tldHMgZG9uJ3QgcmVxdWlyZSBhbiBhdXRob3JpemF0aW9uIHRva2VuIHRvIGRvd25sb2FkIG9iamVjdHMsIGJ1dCBzdGlsbCByZXF1aXJlIGEgdmFsaWQgdG9rZW4gZm9yIGFsbCBvdGhlciBvcGVyYXRpb25zLlxuXHQqIEBwYXJhbSBvcHRpb25zLmZpbGVTaXplTGltaXQgc3BlY2lmaWVzIHRoZSBtYXggZmlsZSBzaXplIGluIGJ5dGVzIHRoYXQgY2FuIGJlIHVwbG9hZGVkIHRvIHRoaXMgYnVja2V0LlxuXHQqIFRoZSBnbG9iYWwgZmlsZSBzaXplIGxpbWl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciB0aGlzIHZhbHVlLlxuXHQqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIG51bGwsIHdoaWNoIGRvZXNuJ3Qgc2V0IGEgcGVyIGJ1Y2tldCBmaWxlIHNpemUgbGltaXQuXG5cdCogQHBhcmFtIG9wdGlvbnMuYWxsb3dlZE1pbWVUeXBlcyBzcGVjaWZpZXMgdGhlIGFsbG93ZWQgbWltZSB0eXBlcyB0aGF0IHRoaXMgYnVja2V0IGNhbiBhY2NlcHQgZHVyaW5nIHVwbG9hZC5cblx0KiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBudWxsLCB3aGljaCBhbGxvd3MgZmlsZXMgd2l0aCBhbGwgbWltZSB0eXBlcyB0byBiZSB1cGxvYWRlZC5cblx0KiBFYWNoIG1pbWUgdHlwZSBzcGVjaWZpZWQgY2FuIGJlIGEgd2lsZGNhcmQsIGUuZy4gaW1hZ2UvKiwgb3IgYSBzcGVjaWZpYyBtaW1lIHR5cGUsIGUuZy4gaW1hZ2UvcG5nLlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIHN1Y2Nlc3MgbWVzc2FnZSBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgVXBkYXRlIGJ1Y2tldFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAudXBkYXRlQnVja2V0KCdhdmF0YXJzJywge1xuXHQqICAgICBwdWJsaWM6IGZhbHNlLFxuXHQqICAgICBhbGxvd2VkTWltZVR5cGVzOiBbJ2ltYWdlL3BuZyddLFxuXHQqICAgICBmaWxlU2l6ZUxpbWl0OiAxMDI0XG5cdCogICB9KVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiB7XG5cdCogICAgIFwibWVzc2FnZVwiOiBcIlN1Y2Nlc3NmdWxseSB1cGRhdGVkXCJcblx0KiAgIH0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIHVwZGF0ZUJ1Y2tldChpZCwgb3B0aW9ucykge1xuXHRcdHZhciBfdGhpczQgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBwdXQoX3RoaXM0LmZldGNoLCBgJHtfdGhpczQudXJsfS9idWNrZXQvJHtpZH1gLCB7XG5cdFx0XHRcdFx0aWQsXG5cdFx0XHRcdFx0bmFtZTogaWQsXG5cdFx0XHRcdFx0cHVibGljOiBvcHRpb25zLnB1YmxpYyxcblx0XHRcdFx0XHRmaWxlX3NpemVfbGltaXQ6IG9wdGlvbnMuZmlsZVNpemVMaW1pdCxcblx0XHRcdFx0XHRhbGxvd2VkX21pbWVfdHlwZXM6IG9wdGlvbnMuYWxsb3dlZE1pbWVUeXBlc1xuXHRcdFx0XHR9LCB7IGhlYWRlcnM6IF90aGlzNC5oZWFkZXJzIH0pLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzNC5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqXG5cdCogUmVtb3ZlcyBhbGwgb2JqZWN0cyBpbnNpZGUgYSBzaW5nbGUgYnVja2V0LlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBpZCBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGJ1Y2tldCB5b3Ugd291bGQgbGlrZSB0byBlbXB0eS5cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggc3VjY2VzcyBtZXNzYWdlIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBFbXB0eSBidWNrZXRcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmVtcHR5QnVja2V0KCdhdmF0YXJzJylcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjoge1xuXHQqICAgICBcIm1lc3NhZ2VcIjogXCJTdWNjZXNzZnVsbHkgZW1wdGllZFwiXG5cdCogICB9LFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBlbXB0eUJ1Y2tldChpZCkge1xuXHRcdHZhciBfdGhpczUgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBwb3N0JDEoX3RoaXM1LmZldGNoLCBgJHtfdGhpczUudXJsfS9idWNrZXQvJHtpZH0vZW1wdHlgLCB7fSwgeyBoZWFkZXJzOiBfdGhpczUuaGVhZGVycyB9KSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczUuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQqIERlbGV0ZXMgYW4gZXhpc3RpbmcgYnVja2V0LiBBIGJ1Y2tldCBjYW4ndCBiZSBkZWxldGVkIHdpdGggZXhpc3Rpbmcgb2JqZWN0cyBpbnNpZGUgaXQuXG5cdCogWW91IG11c3QgZmlyc3QgYGVtcHR5KClgIHRoZSBidWNrZXQuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgYnVja2V0IHlvdSB3b3VsZCBsaWtlIHRvIGRlbGV0ZS5cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggc3VjY2VzcyBtZXNzYWdlIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBEZWxldGUgYnVja2V0XG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5kZWxldGVCdWNrZXQoJ2F2YXRhcnMnKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiB7XG5cdCogICAgIFwibWVzc2FnZVwiOiBcIlN1Y2Nlc3NmdWxseSBkZWxldGVkXCJcblx0KiAgIH0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGRlbGV0ZUJ1Y2tldChpZCkge1xuXHRcdHZhciBfdGhpczYgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCByZW1vdmUoX3RoaXM2LmZldGNoLCBgJHtfdGhpczYudXJsfS9idWNrZXQvJHtpZH1gLCB7fSwgeyBoZWFkZXJzOiBfdGhpczYuaGVhZGVycyB9KSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczYuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdGxpc3RCdWNrZXRPcHRpb25zVG9RdWVyeVN0cmluZyhvcHRpb25zKSB7XG5cdFx0Y29uc3QgcGFyYW1zID0ge307XG5cdFx0aWYgKG9wdGlvbnMpIHtcblx0XHRcdGlmIChcImxpbWl0XCIgaW4gb3B0aW9ucykgcGFyYW1zLmxpbWl0ID0gU3RyaW5nKG9wdGlvbnMubGltaXQpO1xuXHRcdFx0aWYgKFwib2Zmc2V0XCIgaW4gb3B0aW9ucykgcGFyYW1zLm9mZnNldCA9IFN0cmluZyhvcHRpb25zLm9mZnNldCk7XG5cdFx0XHRpZiAob3B0aW9ucy5zZWFyY2gpIHBhcmFtcy5zZWFyY2ggPSBvcHRpb25zLnNlYXJjaDtcblx0XHRcdGlmIChvcHRpb25zLnNvcnRDb2x1bW4pIHBhcmFtcy5zb3J0Q29sdW1uID0gb3B0aW9ucy5zb3J0Q29sdW1uO1xuXHRcdFx0aWYgKG9wdGlvbnMuc29ydE9yZGVyKSBwYXJhbXMuc29ydE9yZGVyID0gb3B0aW9ucy5zb3J0T3JkZXI7XG5cdFx0fVxuXHRcdHJldHVybiBPYmplY3Qua2V5cyhwYXJhbXMpLmxlbmd0aCA+IDAgPyBcIj9cIiArIG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1zKS50b1N0cmluZygpIDogXCJcIjtcblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3BhY2thZ2VzL1N0b3JhZ2VBbmFseXRpY3NDbGllbnQudHNcbi8qKlxuKiBDbGllbnQgY2xhc3MgZm9yIG1hbmFnaW5nIEFuYWx5dGljcyBCdWNrZXRzIHVzaW5nIEljZWJlcmcgdGFibGVzXG4qIFByb3ZpZGVzIG1ldGhvZHMgZm9yIGNyZWF0aW5nLCBsaXN0aW5nLCBhbmQgZGVsZXRpbmcgYW5hbHl0aWNzIGJ1Y2tldHNcbiovXG52YXIgU3RvcmFnZUFuYWx5dGljc0NsaWVudCA9IGNsYXNzIHtcblx0LyoqXG5cdCogQGFscGhhXG5cdCpcblx0KiBDcmVhdGVzIGEgbmV3IFN0b3JhZ2VBbmFseXRpY3NDbGllbnQgaW5zdGFuY2Vcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgQW5hbHl0aWNzIEJ1Y2tldHNcblx0KiBAcGFyYW0gdXJsIC0gVGhlIGJhc2UgVVJMIGZvciB0aGUgc3RvcmFnZSBBUElcblx0KiBAcGFyYW0gaGVhZGVycyAtIEhUVFAgaGVhZGVycyB0byBpbmNsdWRlIGluIHJlcXVlc3RzXG5cdCogQHBhcmFtIGZldGNoIC0gT3B0aW9uYWwgY3VzdG9tIGZldGNoIGltcGxlbWVudGF0aW9uXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCBjbGllbnQgPSBuZXcgU3RvcmFnZUFuYWx5dGljc0NsaWVudCh1cmwsIGhlYWRlcnMpXG5cdCogYGBgXG5cdCovXG5cdGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycyA9IHt9LCBmZXRjaCQxKSB7XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSBmYWxzZTtcblx0XHR0aGlzLnVybCA9IHVybC5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG5cdFx0dGhpcy5oZWFkZXJzID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIERFRkFVTFRfSEVBREVSUyQxKSwgaGVhZGVycyk7XG5cdFx0dGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaCQxKGZldGNoJDEpO1xuXHR9XG5cdC8qKlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogRW5hYmxlIHRocm93aW5nIGVycm9ycyBpbnN0ZWFkIG9mIHJldHVybmluZyB0aGVtIGluIHRoZSByZXNwb25zZVxuXHQqIFdoZW4gZW5hYmxlZCwgZmFpbGVkIG9wZXJhdGlvbnMgd2lsbCB0aHJvdyBpbnN0ZWFkIG9mIHJldHVybmluZyB7IGRhdGE6IG51bGwsIGVycm9yIH1cblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgQW5hbHl0aWNzIEJ1Y2tldHNcblx0KiBAcmV0dXJucyBUaGlzIGluc3RhbmNlIGZvciBtZXRob2QgY2hhaW5pbmdcblx0Ki9cblx0dGhyb3dPbkVycm9yKCkge1xuXHRcdHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gdHJ1ZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBAYWxwaGFcblx0KlxuXHQqIENyZWF0ZXMgYSBuZXcgYW5hbHl0aWNzIGJ1Y2tldCB1c2luZyBJY2ViZXJnIHRhYmxlc1xuXHQqIEFuYWx5dGljcyBidWNrZXRzIGFyZSBvcHRpbWl6ZWQgZm9yIGFuYWx5dGljYWwgcXVlcmllcyBhbmQgZGF0YSBwcm9jZXNzaW5nXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IEFuYWx5dGljcyBCdWNrZXRzXG5cdCogQHBhcmFtIG5hbWUgQSB1bmlxdWUgbmFtZSBmb3IgdGhlIGJ1Y2tldCB5b3UgYXJlIGNyZWF0aW5nXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgbmV3bHkgY3JlYXRlZCBhbmFseXRpY3MgYnVja2V0IG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBDcmVhdGUgYW5hbHl0aWNzIGJ1Y2tldFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuYW5hbHl0aWNzXG5cdCogICAuY3JlYXRlQnVja2V0KCdhbmFseXRpY3MtZGF0YScpXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IHtcblx0KiAgICAgXCJuYW1lXCI6IFwiYW5hbHl0aWNzLWRhdGFcIixcblx0KiAgICAgXCJ0eXBlXCI6IFwiQU5BTFlUSUNTXCIsXG5cdCogICAgIFwiZm9ybWF0XCI6IFwiaWNlYmVyZ1wiLFxuXHQqICAgICBcImNyZWF0ZWRfYXRcIjogXCIyMDI0LTA1LTIyVDIyOjI2OjA1LjEwMFpcIixcblx0KiAgICAgXCJ1cGRhdGVkX2F0XCI6IFwiMjAyNC0wNS0yMlQyMjoyNjowNS4xMDBaXCJcblx0KiAgIH0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGNyZWF0ZUJ1Y2tldChuYW1lKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgcG9zdCQxKF90aGlzLmZldGNoLCBgJHtfdGhpcy51cmx9L2J1Y2tldGAsIHsgbmFtZSB9LCB7IGhlYWRlcnM6IF90aGlzLmhlYWRlcnMgfSksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogUmV0cmlldmVzIHRoZSBkZXRhaWxzIG9mIGFsbCBBbmFseXRpY3MgU3RvcmFnZSBidWNrZXRzIHdpdGhpbiBhbiBleGlzdGluZyBwcm9qZWN0XG5cdCogT25seSByZXR1cm5zIGJ1Y2tldHMgb2YgdHlwZSAnQU5BTFlUSUNTJ1xuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBBbmFseXRpY3MgQnVja2V0c1xuXHQqIEBwYXJhbSBvcHRpb25zIFF1ZXJ5IHBhcmFtZXRlcnMgZm9yIGxpc3RpbmcgYnVja2V0c1xuXHQqIEBwYXJhbSBvcHRpb25zLmxpbWl0IE1heGltdW0gbnVtYmVyIG9mIGJ1Y2tldHMgdG8gcmV0dXJuXG5cdCogQHBhcmFtIG9wdGlvbnMub2Zmc2V0IE51bWJlciBvZiBidWNrZXRzIHRvIHNraXBcblx0KiBAcGFyYW0gb3B0aW9ucy5zb3J0Q29sdW1uIENvbHVtbiB0byBzb3J0IGJ5ICgnbmFtZScsICdjcmVhdGVkX2F0JywgJ3VwZGF0ZWRfYXQnKVxuXHQqIEBwYXJhbSBvcHRpb25zLnNvcnRPcmRlciBTb3J0IG9yZGVyICgnYXNjJyBvciAnZGVzYycpXG5cdCogQHBhcmFtIG9wdGlvbnMuc2VhcmNoIFNlYXJjaCB0ZXJtIHRvIGZpbHRlciBidWNrZXQgbmFtZXNcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBhcnJheSBvZiBhbmFseXRpY3MgYnVja2V0cyBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgTGlzdCBhbmFseXRpY3MgYnVja2V0c1xuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuYW5hbHl0aWNzXG5cdCogICAubGlzdEJ1Y2tldHMoe1xuXHQqICAgICBsaW1pdDogMTAsXG5cdCogICAgIG9mZnNldDogMCxcblx0KiAgICAgc29ydENvbHVtbjogJ2NyZWF0ZWRfYXQnLFxuXHQqICAgICBzb3J0T3JkZXI6ICdkZXNjJ1xuXHQqICAgfSlcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjogW1xuXHQqICAgICB7XG5cdCogICAgICAgXCJuYW1lXCI6IFwiYW5hbHl0aWNzLWRhdGFcIixcblx0KiAgICAgICBcInR5cGVcIjogXCJBTkFMWVRJQ1NcIixcblx0KiAgICAgICBcImZvcm1hdFwiOiBcImljZWJlcmdcIixcblx0KiAgICAgICBcImNyZWF0ZWRfYXRcIjogXCIyMDI0LTA1LTIyVDIyOjI2OjA1LjEwMFpcIixcblx0KiAgICAgICBcInVwZGF0ZWRfYXRcIjogXCIyMDI0LTA1LTIyVDIyOjI2OjA1LjEwMFpcIlxuXHQqICAgICB9XG5cdCogICBdLFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBsaXN0QnVja2V0cyhvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzMiA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuXHRcdFx0aWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubGltaXQpICE9PSB2b2lkIDApIHF1ZXJ5UGFyYW1zLnNldChcImxpbWl0XCIsIG9wdGlvbnMubGltaXQudG9TdHJpbmcoKSk7XG5cdFx0XHRpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vZmZzZXQpICE9PSB2b2lkIDApIHF1ZXJ5UGFyYW1zLnNldChcIm9mZnNldFwiLCBvcHRpb25zLm9mZnNldC50b1N0cmluZygpKTtcblx0XHRcdGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc29ydENvbHVtbikgcXVlcnlQYXJhbXMuc2V0KFwic29ydENvbHVtblwiLCBvcHRpb25zLnNvcnRDb2x1bW4pO1xuXHRcdFx0aWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zb3J0T3JkZXIpIHF1ZXJ5UGFyYW1zLnNldChcInNvcnRPcmRlclwiLCBvcHRpb25zLnNvcnRPcmRlcik7XG5cdFx0XHRpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNlYXJjaCkgcXVlcnlQYXJhbXMuc2V0KFwic2VhcmNoXCIsIG9wdGlvbnMuc2VhcmNoKTtcblx0XHRcdGNvbnN0IHF1ZXJ5U3RyaW5nID0gcXVlcnlQYXJhbXMudG9TdHJpbmcoKTtcblx0XHRcdGNvbnN0IHVybCA9IHF1ZXJ5U3RyaW5nID8gYCR7X3RoaXMyLnVybH0vYnVja2V0PyR7cXVlcnlTdHJpbmd9YCA6IGAke190aGlzMi51cmx9L2J1Y2tldGA7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBnZXQoX3RoaXMyLmZldGNoLCB1cmwsIHsgaGVhZGVyczogX3RoaXMyLmhlYWRlcnMgfSksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMyLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKipcblx0KiBAYWxwaGFcblx0KlxuXHQqIERlbGV0ZXMgYW4gZXhpc3RpbmcgYW5hbHl0aWNzIGJ1Y2tldFxuXHQqIEEgYnVja2V0IGNhbid0IGJlIGRlbGV0ZWQgd2l0aCBleGlzdGluZyBvYmplY3RzIGluc2lkZSBpdFxuXHQqIFlvdSBtdXN0IGZpcnN0IGVtcHR5IHRoZSBidWNrZXQgYmVmb3JlIGRlbGV0aW9uXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IEFuYWx5dGljcyBCdWNrZXRzXG5cdCogQHBhcmFtIGJ1Y2tldE5hbWUgVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBidWNrZXQgeW91IHdvdWxkIGxpa2UgdG8gZGVsZXRlXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgc3VjY2VzcyBtZXNzYWdlIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBEZWxldGUgYW5hbHl0aWNzIGJ1Y2tldFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuYW5hbHl0aWNzXG5cdCogICAuZGVsZXRlQnVja2V0KCdhbmFseXRpY3MtZGF0YScpXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IHtcblx0KiAgICAgXCJtZXNzYWdlXCI6IFwiU3VjY2Vzc2Z1bGx5IGRlbGV0ZWRcIlxuXHQqICAgfSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgZGVsZXRlQnVja2V0KGJ1Y2tldE5hbWUpIHtcblx0XHR2YXIgX3RoaXMzID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgcmVtb3ZlKF90aGlzMy5mZXRjaCwgYCR7X3RoaXMzLnVybH0vYnVja2V0LyR7YnVja2V0TmFtZX1gLCB7fSwgeyBoZWFkZXJzOiBfdGhpczMuaGVhZGVycyB9KSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczMuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogR2V0IGFuIEljZWJlcmcgUkVTVCBDYXRhbG9nIGNsaWVudCBjb25maWd1cmVkIGZvciBhIHNwZWNpZmljIGFuYWx5dGljcyBidWNrZXRcblx0KiBVc2UgdGhpcyB0byBwZXJmb3JtIGFkdmFuY2VkIHRhYmxlIGFuZCBuYW1lc3BhY2Ugb3BlcmF0aW9ucyB3aXRoaW4gdGhlIGJ1Y2tldFxuXHQqIFRoZSByZXR1cm5lZCBjbGllbnQgcHJvdmlkZXMgZnVsbCBhY2Nlc3MgdG8gdGhlIEFwYWNoZSBJY2ViZXJnIFJFU1QgQ2F0YWxvZyBBUElcblx0KiB3aXRoIHRoZSBTdXBhYmFzZSBgeyBkYXRhLCBlcnJvciB9YCBwYXR0ZXJuIGZvciBjb25zaXN0ZW50IGVycm9yIGhhbmRsaW5nIG9uIGFsbCBvcGVyYXRpb25zLlxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBBbmFseXRpY3MgQnVja2V0c1xuXHQqIEBwYXJhbSBidWNrZXROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGFuYWx5dGljcyBidWNrZXQgKHdhcmVob3VzZSkgdG8gY29ubmVjdCB0b1xuXHQqIEByZXR1cm5zIFRoZSB3cmFwcGVkIEljZWJlcmcgY2F0YWxvZyBjbGllbnRcblx0KiBAdGhyb3dzIHtTdG9yYWdlRXJyb3J9IElmIHRoZSBidWNrZXQgbmFtZSBpcyBpbnZhbGlkXG5cdCpcblx0KiBAZXhhbXBsZSBHZXQgY2F0YWxvZyBhbmQgY3JlYXRlIHRhYmxlXG5cdCogYGBganNcblx0KiAvLyBGaXJzdCwgY3JlYXRlIGFuIGFuYWx5dGljcyBidWNrZXRcblx0KiBjb25zdCB7IGRhdGE6IGJ1Y2tldCwgZXJyb3I6IGJ1Y2tldEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5hbmFseXRpY3Ncblx0KiAgIC5jcmVhdGVCdWNrZXQoJ2FuYWx5dGljcy1kYXRhJylcblx0KlxuXHQqIC8vIEdldCB0aGUgSWNlYmVyZyBjYXRhbG9nIGZvciB0aGF0IGJ1Y2tldFxuXHQqIGNvbnN0IGNhdGFsb2cgPSBzdXBhYmFzZS5zdG9yYWdlLmFuYWx5dGljcy5mcm9tKCdhbmFseXRpY3MtZGF0YScpXG5cdCpcblx0KiAvLyBDcmVhdGUgYSBuYW1lc3BhY2Vcblx0KiBjb25zdCB7IGVycm9yOiBuc0Vycm9yIH0gPSBhd2FpdCBjYXRhbG9nLmNyZWF0ZU5hbWVzcGFjZSh7IG5hbWVzcGFjZTogWydkZWZhdWx0J10gfSlcblx0KlxuXHQqIC8vIENyZWF0ZSBhIHRhYmxlIHdpdGggc2NoZW1hXG5cdCogY29uc3QgeyBkYXRhOiB0YWJsZU1ldGFkYXRhLCBlcnJvcjogdGFibGVFcnJvciB9ID0gYXdhaXQgY2F0YWxvZy5jcmVhdGVUYWJsZShcblx0KiAgIHsgbmFtZXNwYWNlOiBbJ2RlZmF1bHQnXSB9LFxuXHQqICAge1xuXHQqICAgICBuYW1lOiAnZXZlbnRzJyxcblx0KiAgICAgc2NoZW1hOiB7XG5cdCogICAgICAgdHlwZTogJ3N0cnVjdCcsXG5cdCogICAgICAgZmllbGRzOiBbXG5cdCogICAgICAgICB7IGlkOiAxLCBuYW1lOiAnaWQnLCB0eXBlOiAnbG9uZycsIHJlcXVpcmVkOiB0cnVlIH0sXG5cdCogICAgICAgICB7IGlkOiAyLCBuYW1lOiAndGltZXN0YW1wJywgdHlwZTogJ3RpbWVzdGFtcCcsIHJlcXVpcmVkOiB0cnVlIH0sXG5cdCogICAgICAgICB7IGlkOiAzLCBuYW1lOiAndXNlcl9pZCcsIHR5cGU6ICdzdHJpbmcnLCByZXF1aXJlZDogZmFsc2UgfVxuXHQqICAgICAgIF0sXG5cdCogICAgICAgJ3NjaGVtYS1pZCc6IDAsXG5cdCogICAgICAgJ2lkZW50aWZpZXItZmllbGQtaWRzJzogWzFdXG5cdCogICAgIH0sXG5cdCogICAgICdwYXJ0aXRpb24tc3BlYyc6IHtcblx0KiAgICAgICAnc3BlYy1pZCc6IDAsXG5cdCogICAgICAgZmllbGRzOiBbXVxuXHQqICAgICB9LFxuXHQqICAgICAnd3JpdGUtb3JkZXInOiB7XG5cdCogICAgICAgJ29yZGVyLWlkJzogMCxcblx0KiAgICAgICBmaWVsZHM6IFtdXG5cdCogICAgIH0sXG5cdCogICAgIHByb3BlcnRpZXM6IHtcblx0KiAgICAgICAnd3JpdGUuZm9ybWF0LmRlZmF1bHQnOiAncGFycXVldCdcblx0KiAgICAgfVxuXHQqICAgfVxuXHQqIClcblx0KiBgYGBcblx0KlxuXHQqIEBleGFtcGxlIExpc3QgdGFibGVzIGluIG5hbWVzcGFjZVxuXHQqIGBgYGpzXG5cdCogY29uc3QgY2F0YWxvZyA9IHN1cGFiYXNlLnN0b3JhZ2UuYW5hbHl0aWNzLmZyb20oJ2FuYWx5dGljcy1kYXRhJylcblx0KlxuXHQqIC8vIExpc3QgYWxsIHRhYmxlcyBpbiB0aGUgZGVmYXVsdCBuYW1lc3BhY2Vcblx0KiBjb25zdCB7IGRhdGE6IHRhYmxlcywgZXJyb3I6IGxpc3RFcnJvciB9ID0gYXdhaXQgY2F0YWxvZy5saXN0VGFibGVzKHsgbmFtZXNwYWNlOiBbJ2RlZmF1bHQnXSB9KVxuXHQqIGlmIChsaXN0RXJyb3IpIHtcblx0KiAgIGlmIChsaXN0RXJyb3IuaXNOb3RGb3VuZCgpKSB7XG5cdCogICAgIGNvbnNvbGUubG9nKCdOYW1lc3BhY2Ugbm90IGZvdW5kJylcblx0KiAgIH1cblx0KiAgIHJldHVyblxuXHQqIH1cblx0KiBjb25zb2xlLmxvZyh0YWJsZXMpIC8vIFt7IG5hbWVzcGFjZTogWydkZWZhdWx0J10sIG5hbWU6ICdldmVudHMnIH1dXG5cdCogYGBgXG5cdCpcblx0KiBAZXhhbXBsZSBXb3JraW5nIHdpdGggbmFtZXNwYWNlc1xuXHQqIGBgYGpzXG5cdCogY29uc3QgY2F0YWxvZyA9IHN1cGFiYXNlLnN0b3JhZ2UuYW5hbHl0aWNzLmZyb20oJ2FuYWx5dGljcy1kYXRhJylcblx0KlxuXHQqIC8vIExpc3QgYWxsIG5hbWVzcGFjZXNcblx0KiBjb25zdCB7IGRhdGE6IG5hbWVzcGFjZXMgfSA9IGF3YWl0IGNhdGFsb2cubGlzdE5hbWVzcGFjZXMoKVxuXHQqXG5cdCogLy8gQ3JlYXRlIG5hbWVzcGFjZSB3aXRoIHByb3BlcnRpZXNcblx0KiBhd2FpdCBjYXRhbG9nLmNyZWF0ZU5hbWVzcGFjZShcblx0KiAgIHsgbmFtZXNwYWNlOiBbJ3Byb2R1Y3Rpb24nXSB9LFxuXHQqICAgeyBwcm9wZXJ0aWVzOiB7IG93bmVyOiAnZGF0YS10ZWFtJywgZW52OiAncHJvZCcgfSB9XG5cdCogKVxuXHQqIGBgYFxuXHQqXG5cdCogQGV4YW1wbGUgQ2xlYW51cCBvcGVyYXRpb25zXG5cdCogYGBganNcblx0KiBjb25zdCBjYXRhbG9nID0gc3VwYWJhc2Uuc3RvcmFnZS5hbmFseXRpY3MuZnJvbSgnYW5hbHl0aWNzLWRhdGEnKVxuXHQqXG5cdCogLy8gRHJvcCB0YWJsZSB3aXRoIHB1cmdlIG9wdGlvbiAocmVtb3ZlcyBhbGwgZGF0YSlcblx0KiBjb25zdCB7IGVycm9yOiBkcm9wRXJyb3IgfSA9IGF3YWl0IGNhdGFsb2cuZHJvcFRhYmxlKFxuXHQqICAgeyBuYW1lc3BhY2U6IFsnZGVmYXVsdCddLCBuYW1lOiAnZXZlbnRzJyB9LFxuXHQqICAgeyBwdXJnZTogdHJ1ZSB9XG5cdCogKVxuXHQqXG5cdCogaWYgKGRyb3BFcnJvcj8uaXNOb3RGb3VuZCgpKSB7XG5cdCogICBjb25zb2xlLmxvZygnVGFibGUgZG9lcyBub3QgZXhpc3QnKVxuXHQqIH1cblx0KlxuXHQqIC8vIERyb3AgbmFtZXNwYWNlIChtdXN0IGJlIGVtcHR5KVxuXHQqIGF3YWl0IGNhdGFsb2cuZHJvcE5hbWVzcGFjZSh7IG5hbWVzcGFjZTogWydkZWZhdWx0J10gfSlcblx0KiBgYGBcblx0KlxuXHQqIEByZW1hcmtzXG5cdCogVGhpcyBtZXRob2QgcHJvdmlkZXMgYSBicmlkZ2UgYmV0d2VlbiBTdXBhYmFzZSdzIGJ1Y2tldCBtYW5hZ2VtZW50IGFuZCB0aGUgc3RhbmRhcmRcblx0KiBBcGFjaGUgSWNlYmVyZyBSRVNUIENhdGFsb2cgQVBJLiBUaGUgYnVja2V0IG5hbWUgbWFwcyB0byB0aGUgSWNlYmVyZyB3YXJlaG91c2UgcGFyYW1ldGVyLlxuXHQqIEFsbCBhdXRoZW50aWNhdGlvbiBhbmQgY29uZmlndXJhdGlvbiBpcyBoYW5kbGVkIGF1dG9tYXRpY2FsbHkgdXNpbmcgeW91ciBTdXBhYmFzZSBjcmVkZW50aWFscy5cblx0KlxuXHQqICoqRXJyb3IgSGFuZGxpbmcqKjogSW52YWxpZCBidWNrZXQgbmFtZXMgdGhyb3cgaW1tZWRpYXRlbHkuIEFsbCBjYXRhbG9nXG5cdCogb3BlcmF0aW9ucyByZXR1cm4gYHsgZGF0YSwgZXJyb3IgfWAgd2hlcmUgZXJyb3JzIGFyZSBgSWNlYmVyZ0Vycm9yYCBpbnN0YW5jZXMgZnJvbSBpY2ViZXJnLWpzLlxuXHQqIFVzZSBoZWxwZXIgbWV0aG9kcyBsaWtlIGBlcnJvci5pc05vdEZvdW5kKClgIG9yIGNoZWNrIGBlcnJvci5zdGF0dXNgIGZvciBzcGVjaWZpYyBlcnJvciBoYW5kbGluZy5cblx0KiBVc2UgYC50aHJvd09uRXJyb3IoKWAgb24gdGhlIGFuYWx5dGljcyBjbGllbnQgaWYgeW91IHByZWZlciBleGNlcHRpb25zIGZvciBjYXRhbG9nIG9wZXJhdGlvbnMuXG5cdCpcblx0KiAqKkNsZWFudXAgT3BlcmF0aW9ucyoqOiBXaGVuIHVzaW5nIGBkcm9wVGFibGVgLCB0aGUgYHB1cmdlOiB0cnVlYCBvcHRpb24gcGVybWFuZW50bHlcblx0KiBkZWxldGVzIGFsbCB0YWJsZSBkYXRhLiBXaXRob3V0IGl0LCB0aGUgdGFibGUgaXMgbWFya2VkIGFzIGRlbGV0ZWQgYnV0IGRhdGEgcmVtYWlucy5cblx0KlxuXHQqICoqTGlicmFyeSBEZXBlbmRlbmN5Kio6IFRoZSByZXR1cm5lZCBjYXRhbG9nIHdyYXBzIGBJY2ViZXJnUmVzdENhdGFsb2dgIGZyb20gaWNlYmVyZy1qcy5cblx0KiBGb3IgY29tcGxldGUgQVBJIGRvY3VtZW50YXRpb24gYW5kIGFkdmFuY2VkIHVzYWdlLCByZWZlciB0byB0aGVcblx0KiBbaWNlYmVyZy1qcyBkb2N1bWVudGF0aW9uXShodHRwczovL3N1cGFiYXNlLmdpdGh1Yi5pby9pY2ViZXJnLWpzLykuXG5cdCovXG5cdGZyb20oYnVja2V0TmFtZSkge1xuXHRcdHZhciBfdGhpczQgPSB0aGlzO1xuXHRcdGlmICghaXNWYWxpZEJ1Y2tldE5hbWUoYnVja2V0TmFtZSkpIHRocm93IG5ldyBTdG9yYWdlRXJyb3IoXCJJbnZhbGlkIGJ1Y2tldCBuYW1lOiBGaWxlLCBmb2xkZXIsIGFuZCBidWNrZXQgbmFtZXMgbXVzdCBmb2xsb3cgQVdTIG9iamVjdCBrZXkgbmFtaW5nIGd1aWRlbGluZXMgYW5kIHNob3VsZCBhdm9pZCB0aGUgdXNlIG9mIGFueSBvdGhlciBjaGFyYWN0ZXJzLlwiKTtcblx0XHRjb25zdCBjYXRhbG9nID0gbmV3IEljZWJlcmdSZXN0Q2F0YWxvZyh7XG5cdFx0XHRiYXNlVXJsOiB0aGlzLnVybCxcblx0XHRcdGNhdGFsb2dOYW1lOiBidWNrZXROYW1lLFxuXHRcdFx0YXV0aDoge1xuXHRcdFx0XHR0eXBlOiBcImN1c3RvbVwiLFxuXHRcdFx0XHRnZXRIZWFkZXJzOiBhc3luYyAoKSA9PiBfdGhpczQuaGVhZGVyc1xuXHRcdFx0fSxcblx0XHRcdGZldGNoOiB0aGlzLmZldGNoXG5cdFx0fSk7XG5cdFx0Y29uc3Qgc2hvdWxkVGhyb3dPbkVycm9yID0gdGhpcy5zaG91bGRUaHJvd09uRXJyb3I7XG5cdFx0cmV0dXJuIG5ldyBQcm94eShjYXRhbG9nLCB7IGdldCh0YXJnZXQsIHByb3ApIHtcblx0XHRcdGNvbnN0IHZhbHVlID0gdGFyZ2V0W3Byb3BdO1xuXHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdmFsdWU7XG5cdFx0XHRyZXR1cm4gYXN5bmMgKC4uLmFyZ3MpID0+IHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0ZGF0YTogYXdhaXQgdmFsdWUuYXBwbHkodGFyZ2V0LCBhcmdzKSxcblx0XHRcdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHRpZiAoc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0XHRcdGVycm9yXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9IH0pO1xuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvbGliL3ZlY3RvcnMvY29uc3RhbnRzLnRzXG5jb25zdCBERUZBVUxUX0hFQURFUlMgPSB7XG5cdFwiWC1DbGllbnQtSW5mb1wiOiBgc3RvcmFnZS1qcy8ke3ZlcnNpb259YCxcblx0XCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9saWIvdmVjdG9ycy9lcnJvcnMudHNcbi8qKlxuKiBCYXNlIGVycm9yIGNsYXNzIGZvciBhbGwgU3RvcmFnZSBWZWN0b3JzIGVycm9yc1xuKi9cbnZhciBTdG9yYWdlVmVjdG9yc0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG5cdGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcblx0XHRzdXBlcihtZXNzYWdlKTtcblx0XHR0aGlzLl9faXNTdG9yYWdlVmVjdG9yc0Vycm9yID0gdHJ1ZTtcblx0XHR0aGlzLm5hbWUgPSBcIlN0b3JhZ2VWZWN0b3JzRXJyb3JcIjtcblx0fVxufTtcbi8qKlxuKiBUeXBlIGd1YXJkIHRvIGNoZWNrIGlmIGFuIGVycm9yIGlzIGEgU3RvcmFnZVZlY3RvcnNFcnJvclxuKiBAcGFyYW0gZXJyb3IgLSBUaGUgZXJyb3IgdG8gY2hlY2tcbiogQHJldHVybnMgVHJ1ZSBpZiB0aGUgZXJyb3IgaXMgYSBTdG9yYWdlVmVjdG9yc0Vycm9yXG4qL1xuZnVuY3Rpb24gaXNTdG9yYWdlVmVjdG9yc0Vycm9yKGVycm9yKSB7XG5cdHJldHVybiB0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgJiYgZXJyb3IgIT09IG51bGwgJiYgXCJfX2lzU3RvcmFnZVZlY3RvcnNFcnJvclwiIGluIGVycm9yO1xufVxuLyoqXG4qIEFQSSBlcnJvciByZXR1cm5lZCBmcm9tIFMzIFZlY3RvcnMgc2VydmljZVxuKiBJbmNsdWRlcyBIVFRQIHN0YXR1cyBjb2RlIGFuZCBzZXJ2aWNlLXNwZWNpZmljIGVycm9yIGNvZGVcbiovXG52YXIgU3RvcmFnZVZlY3RvcnNBcGlFcnJvciA9IGNsYXNzIGV4dGVuZHMgU3RvcmFnZVZlY3RvcnNFcnJvciB7XG5cdGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1cywgc3RhdHVzQ29kZSkge1xuXHRcdHN1cGVyKG1lc3NhZ2UpO1xuXHRcdHRoaXMubmFtZSA9IFwiU3RvcmFnZVZlY3RvcnNBcGlFcnJvclwiO1xuXHRcdHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuXHRcdHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG5cdH1cblx0dG9KU09OKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRuYW1lOiB0aGlzLm5hbWUsXG5cdFx0XHRtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG5cdFx0XHRzdGF0dXM6IHRoaXMuc3RhdHVzLFxuXHRcdFx0c3RhdHVzQ29kZTogdGhpcy5zdGF0dXNDb2RlXG5cdFx0fTtcblx0fVxufTtcbi8qKlxuKiBVbmtub3duIGVycm9yIHRoYXQgZG9lc24ndCBtYXRjaCBleHBlY3RlZCBlcnJvciBwYXR0ZXJuc1xuKiBXcmFwcyB0aGUgb3JpZ2luYWwgZXJyb3IgZm9yIGRlYnVnZ2luZ1xuKi9cbnZhciBTdG9yYWdlVmVjdG9yc1Vua25vd25FcnJvciA9IGNsYXNzIGV4dGVuZHMgU3RvcmFnZVZlY3RvcnNFcnJvciB7XG5cdGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9yaWdpbmFsRXJyb3IpIHtcblx0XHRzdXBlcihtZXNzYWdlKTtcblx0XHR0aGlzLm5hbWUgPSBcIlN0b3JhZ2VWZWN0b3JzVW5rbm93bkVycm9yXCI7XG5cdFx0dGhpcy5vcmlnaW5hbEVycm9yID0gb3JpZ2luYWxFcnJvcjtcblx0fVxufTtcbi8qKlxuKiBFcnJvciBjb2RlcyBzcGVjaWZpYyB0byBTMyBWZWN0b3JzIEFQSVxuKiBNYXBzIEFXUyBzZXJ2aWNlIGVycm9ycyB0byBhcHBsaWNhdGlvbi1mcmllbmRseSBlcnJvciBjb2Rlc1xuKi9cbmxldCBTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbihTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSQxKSB7XG5cdC8qKiBJbnRlcm5hbCBzZXJ2ZXIgZmF1bHQgKEhUVFAgNTAwKSAqL1xuXHRTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSQxW1wiSW50ZXJuYWxFcnJvclwiXSA9IFwiSW50ZXJuYWxFcnJvclwiO1xuXHQvKiogUmVzb3VyY2UgYWxyZWFkeSBleGlzdHMgLyBjb25mbGljdCAoSFRUUCA0MDkpICovXG5cdFN0b3JhZ2VWZWN0b3JzRXJyb3JDb2RlJDFbXCJTM1ZlY3RvckNvbmZsaWN0RXhjZXB0aW9uXCJdID0gXCJTM1ZlY3RvckNvbmZsaWN0RXhjZXB0aW9uXCI7XG5cdC8qKiBSZXNvdXJjZSBub3QgZm91bmQgKEhUVFAgNDA0KSAqL1xuXHRTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSQxW1wiUzNWZWN0b3JOb3RGb3VuZEV4Y2VwdGlvblwiXSA9IFwiUzNWZWN0b3JOb3RGb3VuZEV4Y2VwdGlvblwiO1xuXHQvKiogRGVsZXRlIGJ1Y2tldCB3aGlsZSBub3QgZW1wdHkgKEhUVFAgNDAwKSAqL1xuXHRTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSQxW1wiUzNWZWN0b3JCdWNrZXROb3RFbXB0eVwiXSA9IFwiUzNWZWN0b3JCdWNrZXROb3RFbXB0eVwiO1xuXHQvKiogRXhjZWVkcyBidWNrZXQgcXVvdGEvbGltaXQgKEhUVFAgNDAwKSAqL1xuXHRTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSQxW1wiUzNWZWN0b3JNYXhCdWNrZXRzRXhjZWVkZWRcIl0gPSBcIlMzVmVjdG9yTWF4QnVja2V0c0V4Y2VlZGVkXCI7XG5cdC8qKiBFeGNlZWRzIGluZGV4IHF1b3RhL2xpbWl0IChIVFRQIDQwMCkgKi9cblx0U3RvcmFnZVZlY3RvcnNFcnJvckNvZGUkMVtcIlMzVmVjdG9yTWF4SW5kZXhlc0V4Y2VlZGVkXCJdID0gXCJTM1ZlY3Rvck1heEluZGV4ZXNFeGNlZWRlZFwiO1xuXHRyZXR1cm4gU3RvcmFnZVZlY3RvcnNFcnJvckNvZGUkMTtcbn0oe30pO1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvbGliL3ZlY3RvcnMvaGVscGVycy50c1xuLyoqXG4qIFJlc29sdmVzIHRoZSBmZXRjaCBpbXBsZW1lbnRhdGlvbiB0byB1c2VcbiogVXNlcyBjdXN0b20gZmV0Y2ggaWYgcHJvdmlkZWQsIG90aGVyd2lzZSB1c2VzIG5hdGl2ZSBmZXRjaFxuKlxuKiBAcGFyYW0gY3VzdG9tRmV0Y2ggLSBPcHRpb25hbCBjdXN0b20gZmV0Y2ggaW1wbGVtZW50YXRpb25cbiogQHJldHVybnMgUmVzb2x2ZWQgZmV0Y2ggZnVuY3Rpb25cbiovXG5jb25zdCByZXNvbHZlRmV0Y2ggPSAoY3VzdG9tRmV0Y2gpID0+IHtcblx0aWYgKGN1c3RvbUZldGNoKSByZXR1cm4gKC4uLmFyZ3MpID0+IGN1c3RvbUZldGNoKC4uLmFyZ3MpO1xuXHRyZXR1cm4gKC4uLmFyZ3MpID0+IGZldGNoKC4uLmFyZ3MpO1xufTtcbi8qKlxuKiBSZXNvbHZlcyB0aGUgUmVzcG9uc2UgY29uc3RydWN0b3IgdG8gdXNlXG4qIFJldHVybnMgbmF0aXZlIFJlc3BvbnNlIGNvbnN0cnVjdG9yXG4qXG4qIEByZXR1cm5zIFJlc3BvbnNlIGNvbnN0cnVjdG9yXG4qL1xuY29uc3QgcmVzb2x2ZVJlc3BvbnNlID0gKCkgPT4ge1xuXHRyZXR1cm4gUmVzcG9uc2U7XG59O1xuLyoqXG4qIERldGVybWluZSBpZiBpbnB1dCBpcyBhIHBsYWluIG9iamVjdFxuKiBBbiBvYmplY3QgaXMgcGxhaW4gaWYgaXQncyBjcmVhdGVkIGJ5IGVpdGhlciB7fSwgbmV3IE9iamVjdCgpLCBvciBPYmplY3QuY3JlYXRlKG51bGwpXG4qXG4qIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrXG4qIEByZXR1cm5zIFRydWUgaWYgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3RcbiogQHNvdXJjZSBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL2lzLXBsYWluLW9ialxuKi9cbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAodmFsdWUpID0+IHtcblx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuXHRyZXR1cm4gKHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGUgfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvdHlwZSkgPT09IG51bGwpICYmICEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIHZhbHVlKSAmJiAhKFN5bWJvbC5pdGVyYXRvciBpbiB2YWx1ZSk7XG59O1xuLyoqXG4qIE5vcm1hbGl6ZXMgYSBudW1iZXIgYXJyYXkgdG8gZmxvYXQzMiBmb3JtYXRcbiogRW5zdXJlcyBhbGwgdmVjdG9yIHZhbHVlcyBhcmUgdmFsaWQgMzItYml0IGZsb2F0c1xuKlxuKiBAcGFyYW0gdmFsdWVzIC0gQXJyYXkgb2YgbnVtYmVycyB0byBub3JtYWxpemVcbiogQHJldHVybnMgTm9ybWFsaXplZCBmbG9hdDMyIGFycmF5XG4qL1xuY29uc3Qgbm9ybWFsaXplVG9GbG9hdDMyID0gKHZhbHVlcykgPT4ge1xuXHRyZXR1cm4gQXJyYXkuZnJvbShuZXcgRmxvYXQzMkFycmF5KHZhbHVlcykpO1xufTtcbi8qKlxuKiBWYWxpZGF0ZXMgdmVjdG9yIGRpbWVuc2lvbnMgbWF0Y2ggZXhwZWN0ZWQgZGltZW5zaW9uXG4qIFRocm93cyBlcnJvciBpZiBkaW1lbnNpb25zIGRvbid0IG1hdGNoXG4qXG4qIEBwYXJhbSB2ZWN0b3IgLSBWZWN0b3IgZGF0YSB0byB2YWxpZGF0ZVxuKiBAcGFyYW0gZXhwZWN0ZWREaW1lbnNpb24gLSBFeHBlY3RlZCB2ZWN0b3IgZGltZW5zaW9uXG4qIEB0aHJvd3MgRXJyb3IgaWYgZGltZW5zaW9ucyBkb24ndCBtYXRjaFxuKi9cbmNvbnN0IHZhbGlkYXRlVmVjdG9yRGltZW5zaW9uID0gKHZlY3RvciwgZXhwZWN0ZWREaW1lbnNpb24pID0+IHtcblx0aWYgKGV4cGVjdGVkRGltZW5zaW9uICE9PSB2b2lkIDAgJiYgdmVjdG9yLmZsb2F0MzIubGVuZ3RoICE9PSBleHBlY3RlZERpbWVuc2lvbikgdGhyb3cgbmV3IEVycm9yKGBWZWN0b3IgZGltZW5zaW9uIG1pc21hdGNoOiBleHBlY3RlZCAke2V4cGVjdGVkRGltZW5zaW9ufSwgZ290ICR7dmVjdG9yLmZsb2F0MzIubGVuZ3RofWApO1xufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2xpYi92ZWN0b3JzL2ZldGNoLnRzXG4vKipcbiogRXh0cmFjdHMgZXJyb3IgbWVzc2FnZSBmcm9tIHZhcmlvdXMgZXJyb3IgcmVzcG9uc2UgZm9ybWF0c1xuKiBAcGFyYW0gZXJyIC0gRXJyb3Igb2JqZWN0IGZyb20gQVBJXG4qIEByZXR1cm5zIEh1bWFuLXJlYWRhYmxlIGVycm9yIG1lc3NhZ2VcbiovXG5jb25zdCBfZ2V0RXJyb3JNZXNzYWdlID0gKGVycikgPT4gZXJyLm1zZyB8fCBlcnIubWVzc2FnZSB8fCBlcnIuZXJyb3JfZGVzY3JpcHRpb24gfHwgZXJyLmVycm9yIHx8IEpTT04uc3RyaW5naWZ5KGVycik7XG4vKipcbiogSGFuZGxlcyBmZXRjaCBlcnJvcnMgYW5kIGNvbnZlcnRzIHRoZW0gdG8gU3RvcmFnZVZlY3RvcnMgZXJyb3IgdHlwZXNcbiogQHBhcmFtIGVycm9yIC0gVGhlIGVycm9yIGNhdWdodCBmcm9tIGZldGNoXG4qIEBwYXJhbSByZWplY3QgLSBQcm9taXNlIHJlamVjdGlvbiBmdW5jdGlvblxuKiBAcGFyYW0gb3B0aW9ucyAtIEZldGNoIG9wdGlvbnMgdGhhdCBtYXkgYWZmZWN0IGVycm9yIGhhbmRsaW5nXG4qL1xuY29uc3QgaGFuZGxlRXJyb3IgPSBhc3luYyAoZXJyb3IsIHJlamVjdCwgb3B0aW9ucykgPT4ge1xuXHRpZiAoZXJyb3IgJiYgdHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiICYmIFwic3RhdHVzXCIgaW4gZXJyb3IgJiYgXCJva1wiIGluIGVycm9yICYmIHR5cGVvZiBlcnJvci5zdGF0dXMgPT09IFwibnVtYmVyXCIgJiYgIShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubm9SZXNvbHZlSnNvbikpIHtcblx0XHRjb25zdCBzdGF0dXMgPSBlcnJvci5zdGF0dXMgfHwgNTAwO1xuXHRcdGNvbnN0IHJlc3BvbnNlRXJyb3IgPSBlcnJvcjtcblx0XHRpZiAodHlwZW9mIHJlc3BvbnNlRXJyb3IuanNvbiA9PT0gXCJmdW5jdGlvblwiKSByZXNwb25zZUVycm9yLmpzb24oKS50aGVuKChlcnIpID0+IHtcblx0XHRcdGNvbnN0IHN0YXR1c0NvZGUgPSAoZXJyID09PSBudWxsIHx8IGVyciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyLnN0YXR1c0NvZGUpIHx8IChlcnIgPT09IG51bGwgfHwgZXJyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnIuY29kZSkgfHwgc3RhdHVzICsgXCJcIjtcblx0XHRcdHJlamVjdChuZXcgU3RvcmFnZVZlY3RvcnNBcGlFcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGVyciksIHN0YXR1cywgc3RhdHVzQ29kZSkpO1xuXHRcdH0pLmNhdGNoKCgpID0+IHtcblx0XHRcdGNvbnN0IHN0YXR1c0NvZGUgPSBzdGF0dXMgKyBcIlwiO1xuXHRcdFx0cmVqZWN0KG5ldyBTdG9yYWdlVmVjdG9yc0FwaUVycm9yKHJlc3BvbnNlRXJyb3Iuc3RhdHVzVGV4dCB8fCBgSFRUUCAke3N0YXR1c30gZXJyb3JgLCBzdGF0dXMsIHN0YXR1c0NvZGUpKTtcblx0XHR9KTtcblx0XHRlbHNlIHtcblx0XHRcdGNvbnN0IHN0YXR1c0NvZGUgPSBzdGF0dXMgKyBcIlwiO1xuXHRcdFx0cmVqZWN0KG5ldyBTdG9yYWdlVmVjdG9yc0FwaUVycm9yKHJlc3BvbnNlRXJyb3Iuc3RhdHVzVGV4dCB8fCBgSFRUUCAke3N0YXR1c30gZXJyb3JgLCBzdGF0dXMsIHN0YXR1c0NvZGUpKTtcblx0XHR9XG5cdH0gZWxzZSByZWplY3QobmV3IFN0b3JhZ2VWZWN0b3JzVW5rbm93bkVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZXJyb3IpLCBlcnJvcikpO1xufTtcbi8qKlxuKiBCdWlsZHMgcmVxdWVzdCBwYXJhbWV0ZXJzIGZvciBmZXRjaCBjYWxsc1xuKiBAcGFyYW0gbWV0aG9kIC0gSFRUUCBtZXRob2RcbiogQHBhcmFtIG9wdGlvbnMgLSBDdXN0b20gZmV0Y2ggb3B0aW9uc1xuKiBAcGFyYW0gcGFyYW1ldGVycyAtIEFkZGl0aW9uYWwgZmV0Y2ggcGFyYW1ldGVycyBsaWtlIEFib3J0U2lnbmFsXG4qIEBwYXJhbSBib2R5IC0gUmVxdWVzdCBib2R5ICh3aWxsIGJlIEpTT04gc3RyaW5naWZpZWQgaWYgcGxhaW4gb2JqZWN0KVxuKiBAcmV0dXJucyBDb21wbGV0ZSBmZXRjaCByZXF1ZXN0IHBhcmFtZXRlcnNcbiovXG5jb25zdCBfZ2V0UmVxdWVzdFBhcmFtcyA9IChtZXRob2QsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpID0+IHtcblx0Y29uc3QgcGFyYW1zID0ge1xuXHRcdG1ldGhvZCxcblx0XHRoZWFkZXJzOiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMpIHx8IHt9XG5cdH07XG5cdGlmIChtZXRob2QgPT09IFwiR0VUXCIgfHwgIWJvZHkpIHJldHVybiBwYXJhbXM7XG5cdGlmIChpc1BsYWluT2JqZWN0KGJvZHkpKSB7XG5cdFx0cGFyYW1zLmhlYWRlcnMgPSBfb2JqZWN0U3ByZWFkMih7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzKTtcblx0XHRwYXJhbXMuYm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkpO1xuXHR9IGVsc2UgcGFyYW1zLmJvZHkgPSBib2R5O1xuXHRyZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHBhcmFtcyksIHBhcmFtZXRlcnMpO1xufTtcbi8qKlxuKiBJbnRlcm5hbCByZXF1ZXN0IGhhbmRsZXIgdGhhdCB3cmFwcyBmZXRjaCB3aXRoIGVycm9yIGhhbmRsaW5nXG4qIEBwYXJhbSBmZXRjaGVyIC0gRmV0Y2ggZnVuY3Rpb24gdG8gdXNlXG4qIEBwYXJhbSBtZXRob2QgLSBIVFRQIG1ldGhvZFxuKiBAcGFyYW0gdXJsIC0gUmVxdWVzdCBVUkxcbiogQHBhcmFtIG9wdGlvbnMgLSBDdXN0b20gZmV0Y2ggb3B0aW9uc1xuKiBAcGFyYW0gcGFyYW1ldGVycyAtIEFkZGl0aW9uYWwgZmV0Y2ggcGFyYW1ldGVyc1xuKiBAcGFyYW0gYm9keSAtIFJlcXVlc3QgYm9keVxuKiBAcmV0dXJucyBQcm9taXNlIHdpdGggcGFyc2VkIHJlc3BvbnNlIG9yIGVycm9yXG4qL1xuYXN5bmMgZnVuY3Rpb24gX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgbWV0aG9kLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRmZXRjaGVyKHVybCwgX2dldFJlcXVlc3RQYXJhbXMobWV0aG9kLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KSkudGhlbigocmVzdWx0KSA9PiB7XG5cdFx0XHRpZiAoIXJlc3VsdC5vaykgdGhyb3cgcmVzdWx0O1xuXHRcdFx0aWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ub1Jlc29sdmVKc29uKSByZXR1cm4gcmVzdWx0O1xuXHRcdFx0Y29uc3QgY29udGVudFR5cGUgPSByZXN1bHQuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik7XG5cdFx0XHRpZiAoIWNvbnRlbnRUeXBlIHx8ICFjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHJldHVybiB7fTtcblx0XHRcdHJldHVybiByZXN1bHQuanNvbigpO1xuXHRcdH0pLnRoZW4oKGRhdGEpID0+IHJlc29sdmUoZGF0YSkpLmNhdGNoKChlcnJvcikgPT4gaGFuZGxlRXJyb3IoZXJyb3IsIHJlamVjdCwgb3B0aW9ucykpO1xuXHR9KTtcbn1cbi8qKlxuKiBQZXJmb3JtcyBhIFBPU1QgcmVxdWVzdFxuKiBAcGFyYW0gZmV0Y2hlciAtIEZldGNoIGZ1bmN0aW9uIHRvIHVzZVxuKiBAcGFyYW0gdXJsIC0gUmVxdWVzdCBVUkxcbiogQHBhcmFtIGJvZHkgLSBSZXF1ZXN0IGJvZHkgdG8gYmUgSlNPTiBzdHJpbmdpZmllZFxuKiBAcGFyYW0gb3B0aW9ucyAtIEN1c3RvbSBmZXRjaCBvcHRpb25zXG4qIEBwYXJhbSBwYXJhbWV0ZXJzIC0gQWRkaXRpb25hbCBmZXRjaCBwYXJhbWV0ZXJzXG4qIEByZXR1cm5zIFByb21pc2Ugd2l0aCBwYXJzZWQgcmVzcG9uc2VcbiovXG5hc3luYyBmdW5jdGlvbiBwb3N0KGZldGNoZXIsIHVybCwgYm9keSwgb3B0aW9ucywgcGFyYW1ldGVycykge1xuXHRyZXR1cm4gX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgXCJQT1NUXCIsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSk7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9saWIvdmVjdG9ycy9WZWN0b3JJbmRleEFwaS50c1xuLyoqXG4qIEBoaWRkZW5cbiogQmFzZSBpbXBsZW1lbnRhdGlvbiBmb3IgdmVjdG9yIGluZGV4IG9wZXJhdGlvbnMuXG4qIFVzZSB7QGxpbmsgVmVjdG9yQnVja2V0U2NvcGV9IHZpYSBgc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2J1Y2tldCcpYCBpbnN0ZWFkLlxuKi9cbnZhciBWZWN0b3JJbmRleEFwaSA9IGNsYXNzIHtcblx0LyoqIENyZWF0ZXMgYSBuZXcgVmVjdG9ySW5kZXhBcGkgaW5zdGFuY2UgKi9cblx0Y29uc3RydWN0b3IodXJsLCBoZWFkZXJzID0ge30sIGZldGNoJDEpIHtcblx0XHR0aGlzLnNob3VsZFRocm93T25FcnJvciA9IGZhbHNlO1xuXHRcdHRoaXMudXJsID0gdXJsLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcblx0XHR0aGlzLmhlYWRlcnMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9IRUFERVJTKSwgaGVhZGVycyk7XG5cdFx0dGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaChmZXRjaCQxKTtcblx0fVxuXHQvKiogRW5hYmxlIHRocm93aW5nIGVycm9ycyBpbnN0ZWFkIG9mIHJldHVybmluZyB0aGVtIGluIHRoZSByZXNwb25zZSAqL1xuXHR0aHJvd09uRXJyb3IoKSB7XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSB0cnVlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKiBDcmVhdGVzIGEgbmV3IHZlY3RvciBpbmRleCB3aXRoaW4gYSBidWNrZXQgKi9cblx0YXN5bmMgY3JlYXRlSW5kZXgob3B0aW9ucykge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHBvc3QoX3RoaXMuZmV0Y2gsIGAke190aGlzLnVybH0vQ3JlYXRlSW5kZXhgLCBvcHRpb25zLCB7IGhlYWRlcnM6IF90aGlzLmhlYWRlcnMgfSkgfHwge30sXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VWZWN0b3JzRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKiogUmV0cmlldmVzIG1ldGFkYXRhIGZvciBhIHNwZWNpZmljIHZlY3RvciBpbmRleCAqL1xuXHRhc3luYyBnZXRJbmRleCh2ZWN0b3JCdWNrZXROYW1lLCBpbmRleE5hbWUpIHtcblx0XHR2YXIgX3RoaXMyID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgcG9zdChfdGhpczIuZmV0Y2gsIGAke190aGlzMi51cmx9L0dldEluZGV4YCwge1xuXHRcdFx0XHRcdHZlY3RvckJ1Y2tldE5hbWUsXG5cdFx0XHRcdFx0aW5kZXhOYW1lXG5cdFx0XHRcdH0sIHsgaGVhZGVyczogX3RoaXMyLmhlYWRlcnMgfSksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMyLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlVmVjdG9yc0Vycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqIExpc3RzIHZlY3RvciBpbmRleGVzIHdpdGhpbiBhIGJ1Y2tldCB3aXRoIG9wdGlvbmFsIGZpbHRlcmluZyBhbmQgcGFnaW5hdGlvbiAqL1xuXHRhc3luYyBsaXN0SW5kZXhlcyhvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzMyA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHBvc3QoX3RoaXMzLmZldGNoLCBgJHtfdGhpczMudXJsfS9MaXN0SW5kZXhlc2AsIG9wdGlvbnMsIHsgaGVhZGVyczogX3RoaXMzLmhlYWRlcnMgfSksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMzLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlVmVjdG9yc0Vycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqIERlbGV0ZXMgYSB2ZWN0b3IgaW5kZXggYW5kIGFsbCBpdHMgZGF0YSAqL1xuXHRhc3luYyBkZWxldGVJbmRleCh2ZWN0b3JCdWNrZXROYW1lLCBpbmRleE5hbWUpIHtcblx0XHR2YXIgX3RoaXM0ID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgcG9zdChfdGhpczQuZmV0Y2gsIGAke190aGlzNC51cmx9L0RlbGV0ZUluZGV4YCwge1xuXHRcdFx0XHRcdHZlY3RvckJ1Y2tldE5hbWUsXG5cdFx0XHRcdFx0aW5kZXhOYW1lXG5cdFx0XHRcdH0sIHsgaGVhZGVyczogX3RoaXM0LmhlYWRlcnMgfSkgfHwge30sXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXM0LnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlVmVjdG9yc0Vycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9saWIvdmVjdG9ycy9WZWN0b3JEYXRhQXBpLnRzXG4vKipcbiogQGhpZGRlblxuKiBCYXNlIGltcGxlbWVudGF0aW9uIGZvciB2ZWN0b3IgZGF0YSBvcGVyYXRpb25zLlxuKiBVc2Uge0BsaW5rIFZlY3RvckluZGV4U2NvcGV9IHZpYSBgc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2J1Y2tldCcpLmluZGV4KCdpZHgnKWAgaW5zdGVhZC5cbiovXG52YXIgVmVjdG9yRGF0YUFwaSA9IGNsYXNzIHtcblx0LyoqIENyZWF0ZXMgYSBuZXcgVmVjdG9yRGF0YUFwaSBpbnN0YW5jZSAqL1xuXHRjb25zdHJ1Y3Rvcih1cmwsIGhlYWRlcnMgPSB7fSwgZmV0Y2gkMSkge1xuXHRcdHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gZmFsc2U7XG5cdFx0dGhpcy51cmwgPSB1cmwucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuXHRcdHRoaXMuaGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBERUZBVUxUX0hFQURFUlMpLCBoZWFkZXJzKTtcblx0XHR0aGlzLmZldGNoID0gcmVzb2x2ZUZldGNoKGZldGNoJDEpO1xuXHR9XG5cdC8qKiBFbmFibGUgdGhyb3dpbmcgZXJyb3JzIGluc3RlYWQgb2YgcmV0dXJuaW5nIHRoZW0gaW4gdGhlIHJlc3BvbnNlICovXG5cdHRocm93T25FcnJvcigpIHtcblx0XHR0aGlzLnNob3VsZFRocm93T25FcnJvciA9IHRydWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqIEluc2VydHMgb3IgdXBkYXRlcyB2ZWN0b3JzIGluIGJhdGNoICgxLTUwMCBwZXIgcmVxdWVzdCkgKi9cblx0YXN5bmMgcHV0VmVjdG9ycyhvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0aWYgKG9wdGlvbnMudmVjdG9ycy5sZW5ndGggPCAxIHx8IG9wdGlvbnMudmVjdG9ycy5sZW5ndGggPiA1MDApIHRocm93IG5ldyBFcnJvcihcIlZlY3RvciBiYXRjaCBzaXplIG11c3QgYmUgYmV0d2VlbiAxIGFuZCA1MDAgaXRlbXNcIik7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBwb3N0KF90aGlzLmZldGNoLCBgJHtfdGhpcy51cmx9L1B1dFZlY3RvcnNgLCBvcHRpb25zLCB7IGhlYWRlcnM6IF90aGlzLmhlYWRlcnMgfSkgfHwge30sXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VWZWN0b3JzRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKiogUmV0cmlldmVzIHZlY3RvcnMgYnkgdGhlaXIga2V5cyBpbiBiYXRjaCAqL1xuXHRhc3luYyBnZXRWZWN0b3JzKG9wdGlvbnMpIHtcblx0XHR2YXIgX3RoaXMyID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgcG9zdChfdGhpczIuZmV0Y2gsIGAke190aGlzMi51cmx9L0dldFZlY3RvcnNgLCBvcHRpb25zLCB7IGhlYWRlcnM6IF90aGlzMi5oZWFkZXJzIH0pLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzMi5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZVZlY3RvcnNFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKiBMaXN0cyB2ZWN0b3JzIGluIGFuIGluZGV4IHdpdGggcGFnaW5hdGlvbiAqL1xuXHRhc3luYyBsaXN0VmVjdG9ycyhvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzMyA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdGlmIChvcHRpb25zLnNlZ21lbnRDb3VudCAhPT0gdm9pZCAwKSB7XG5cdFx0XHRcdGlmIChvcHRpb25zLnNlZ21lbnRDb3VudCA8IDEgfHwgb3B0aW9ucy5zZWdtZW50Q291bnQgPiAxNikgdGhyb3cgbmV3IEVycm9yKFwic2VnbWVudENvdW50IG11c3QgYmUgYmV0d2VlbiAxIGFuZCAxNlwiKTtcblx0XHRcdFx0aWYgKG9wdGlvbnMuc2VnbWVudEluZGV4ICE9PSB2b2lkIDApIHtcblx0XHRcdFx0XHRpZiAob3B0aW9ucy5zZWdtZW50SW5kZXggPCAwIHx8IG9wdGlvbnMuc2VnbWVudEluZGV4ID49IG9wdGlvbnMuc2VnbWVudENvdW50KSB0aHJvdyBuZXcgRXJyb3IoYHNlZ21lbnRJbmRleCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgJHtvcHRpb25zLnNlZ21lbnRDb3VudCAtIDF9YCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHBvc3QoX3RoaXMzLmZldGNoLCBgJHtfdGhpczMudXJsfS9MaXN0VmVjdG9yc2AsIG9wdGlvbnMsIHsgaGVhZGVyczogX3RoaXMzLmhlYWRlcnMgfSksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMzLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlVmVjdG9yc0Vycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqIFF1ZXJpZXMgZm9yIHNpbWlsYXIgdmVjdG9ycyB1c2luZyBhcHByb3hpbWF0ZSBuZWFyZXN0IG5laWdoYm9yIHNlYXJjaCAqL1xuXHRhc3luYyBxdWVyeVZlY3RvcnMob3B0aW9ucykge1xuXHRcdHZhciBfdGhpczQgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBwb3N0KF90aGlzNC5mZXRjaCwgYCR7X3RoaXM0LnVybH0vUXVlcnlWZWN0b3JzYCwgb3B0aW9ucywgeyBoZWFkZXJzOiBfdGhpczQuaGVhZGVycyB9KSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczQuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VWZWN0b3JzRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKiogRGVsZXRlcyB2ZWN0b3JzIGJ5IHRoZWlyIGtleXMgaW4gYmF0Y2ggKDEtNTAwIHBlciByZXF1ZXN0KSAqL1xuXHRhc3luYyBkZWxldGVWZWN0b3JzKG9wdGlvbnMpIHtcblx0XHR2YXIgX3RoaXM1ID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0aWYgKG9wdGlvbnMua2V5cy5sZW5ndGggPCAxIHx8IG9wdGlvbnMua2V5cy5sZW5ndGggPiA1MDApIHRocm93IG5ldyBFcnJvcihcIktleXMgYmF0Y2ggc2l6ZSBtdXN0IGJlIGJldHdlZW4gMSBhbmQgNTAwIGl0ZW1zXCIpO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgcG9zdChfdGhpczUuZmV0Y2gsIGAke190aGlzNS51cmx9L0RlbGV0ZVZlY3RvcnNgLCBvcHRpb25zLCB7IGhlYWRlcnM6IF90aGlzNS5oZWFkZXJzIH0pIHx8IHt9LFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzNS5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZVZlY3RvcnNFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvbGliL3ZlY3RvcnMvVmVjdG9yQnVja2V0QXBpLnRzXG4vKipcbiogQGhpZGRlblxuKiBCYXNlIGltcGxlbWVudGF0aW9uIGZvciB2ZWN0b3IgYnVja2V0IG9wZXJhdGlvbnMuXG4qIFVzZSB7QGxpbmsgU3RvcmFnZVZlY3RvcnNDbGllbnR9IHZpYSBgc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzYCBpbnN0ZWFkLlxuKi9cbnZhciBWZWN0b3JCdWNrZXRBcGkgPSBjbGFzcyB7XG5cdC8qKiBDcmVhdGVzIGEgbmV3IFZlY3RvckJ1Y2tldEFwaSBpbnN0YW5jZSAqL1xuXHRjb25zdHJ1Y3Rvcih1cmwsIGhlYWRlcnMgPSB7fSwgZmV0Y2gkMSkge1xuXHRcdHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gZmFsc2U7XG5cdFx0dGhpcy51cmwgPSB1cmwucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuXHRcdHRoaXMuaGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBERUZBVUxUX0hFQURFUlMpLCBoZWFkZXJzKTtcblx0XHR0aGlzLmZldGNoID0gcmVzb2x2ZUZldGNoKGZldGNoJDEpO1xuXHR9XG5cdC8qKiBFbmFibGUgdGhyb3dpbmcgZXJyb3JzIGluc3RlYWQgb2YgcmV0dXJuaW5nIHRoZW0gaW4gdGhlIHJlc3BvbnNlICovXG5cdHRocm93T25FcnJvcigpIHtcblx0XHR0aGlzLnNob3VsZFRocm93T25FcnJvciA9IHRydWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqIENyZWF0ZXMgYSBuZXcgdmVjdG9yIGJ1Y2tldCAqL1xuXHRhc3luYyBjcmVhdGVCdWNrZXQodmVjdG9yQnVja2V0TmFtZSkge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHBvc3QoX3RoaXMuZmV0Y2gsIGAke190aGlzLnVybH0vQ3JlYXRlVmVjdG9yQnVja2V0YCwgeyB2ZWN0b3JCdWNrZXROYW1lIH0sIHsgaGVhZGVyczogX3RoaXMuaGVhZGVycyB9KSB8fCB7fSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZVZlY3RvcnNFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKiBSZXRyaWV2ZXMgbWV0YWRhdGEgZm9yIGEgc3BlY2lmaWMgdmVjdG9yIGJ1Y2tldCAqL1xuXHRhc3luYyBnZXRCdWNrZXQodmVjdG9yQnVja2V0TmFtZSkge1xuXHRcdHZhciBfdGhpczIgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBwb3N0KF90aGlzMi5mZXRjaCwgYCR7X3RoaXMyLnVybH0vR2V0VmVjdG9yQnVja2V0YCwgeyB2ZWN0b3JCdWNrZXROYW1lIH0sIHsgaGVhZGVyczogX3RoaXMyLmhlYWRlcnMgfSksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMyLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlVmVjdG9yc0Vycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqIExpc3RzIHZlY3RvciBidWNrZXRzIHdpdGggb3B0aW9uYWwgZmlsdGVyaW5nIGFuZCBwYWdpbmF0aW9uICovXG5cdGFzeW5jIGxpc3RCdWNrZXRzKG9wdGlvbnMgPSB7fSkge1xuXHRcdHZhciBfdGhpczMgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBwb3N0KF90aGlzMy5mZXRjaCwgYCR7X3RoaXMzLnVybH0vTGlzdFZlY3RvckJ1Y2tldHNgLCBvcHRpb25zLCB7IGhlYWRlcnM6IF90aGlzMy5oZWFkZXJzIH0pLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzMy5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZVZlY3RvcnNFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKiBEZWxldGVzIGEgdmVjdG9yIGJ1Y2tldCAobXVzdCBiZSBlbXB0eSBmaXJzdCkgKi9cblx0YXN5bmMgZGVsZXRlQnVja2V0KHZlY3RvckJ1Y2tldE5hbWUpIHtcblx0XHR2YXIgX3RoaXM0ID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgcG9zdChfdGhpczQuZmV0Y2gsIGAke190aGlzNC51cmx9L0RlbGV0ZVZlY3RvckJ1Y2tldGAsIHsgdmVjdG9yQnVja2V0TmFtZSB9LCB7IGhlYWRlcnM6IF90aGlzNC5oZWFkZXJzIH0pIHx8IHt9LFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzNC5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZVZlY3RvcnNFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvbGliL3ZlY3RvcnMvU3RvcmFnZVZlY3RvcnNDbGllbnQudHNcbi8qKlxuKlxuKiBAYWxwaGFcbipcbiogTWFpbiBjbGllbnQgZm9yIGludGVyYWN0aW5nIHdpdGggUzMgVmVjdG9ycyBBUElcbiogUHJvdmlkZXMgYWNjZXNzIHRvIGJ1Y2tldCwgaW5kZXgsIGFuZCB2ZWN0b3IgZGF0YSBvcGVyYXRpb25zXG4qXG4qICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG4qXG4qICoqVXNhZ2UgUGF0dGVybnM6KipcbipcbiogYGBgdHlwZXNjcmlwdFxuKiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuKiAgLnN0b3JhZ2VcbiogIC52ZWN0b3JzXG4qICAuY3JlYXRlQnVja2V0KCdlbWJlZGRpbmdzLXByb2QnKVxuKlxuKiAvLyBBY2Nlc3MgaW5kZXggb3BlcmF0aW9ucyB2aWEgYnVja2V0c1xuKiBjb25zdCBidWNrZXQgPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJylcbiogYXdhaXQgYnVja2V0LmNyZWF0ZUluZGV4KHtcbiogICBpbmRleE5hbWU6ICdkb2N1bWVudHMnLFxuKiAgIGRhdGFUeXBlOiAnZmxvYXQzMicsXG4qICAgZGltZW5zaW9uOiAxNTM2LFxuKiAgIGRpc3RhbmNlTWV0cmljOiAnY29zaW5lJ1xuKiB9KVxuKlxuKiAvLyBBY2Nlc3MgdmVjdG9yIG9wZXJhdGlvbnMgdmlhIGluZGV4XG4qIGNvbnN0IGluZGV4ID0gYnVja2V0LmluZGV4KCdkb2N1bWVudHMnKVxuKiBhd2FpdCBpbmRleC5wdXRWZWN0b3JzKHtcbiogICB2ZWN0b3JzOiBbXG4qICAgICB7IGtleTogJ2RvYy0xJywgZGF0YTogeyBmbG9hdDMyOiBbLi4uXSB9LCBtZXRhZGF0YTogeyB0aXRsZTogJ0ludHJvJyB9IH1cbiogICBdXG4qIH0pXG4qXG4qIC8vIFF1ZXJ5IHNpbWlsYXIgdmVjdG9yc1xuKiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGluZGV4LnF1ZXJ5VmVjdG9ycyh7XG4qICAgcXVlcnlWZWN0b3I6IHsgZmxvYXQzMjogWy4uLl0gfSxcbiogICB0b3BLOiA1LFxuKiAgIHJldHVybkRpc3RhbmNlOiB0cnVlXG4qIH0pXG4qIGBgYFxuKi9cbnZhciBTdG9yYWdlVmVjdG9yc0NsaWVudCA9IGNsYXNzIGV4dGVuZHMgVmVjdG9yQnVja2V0QXBpIHtcblx0LyoqXG5cdCogQGFscGhhXG5cdCpcblx0KiBDcmVhdGVzIGEgU3RvcmFnZVZlY3RvcnNDbGllbnQgdGhhdCBjYW4gbWFuYWdlIGJ1Y2tldHMsIGluZGV4ZXMsIGFuZCB2ZWN0b3JzLlxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEBwYXJhbSB1cmwgLSBCYXNlIFVSTCBvZiB0aGUgU3RvcmFnZSBWZWN0b3JzIFJFU1QgQVBJLlxuXHQqIEBwYXJhbSBvcHRpb25zLmhlYWRlcnMgLSBPcHRpb25hbCBoZWFkZXJzIChmb3IgZXhhbXBsZSBgQXV0aG9yaXphdGlvbmApIGFwcGxpZWQgdG8gZXZlcnkgcmVxdWVzdC5cblx0KiBAcGFyYW0gb3B0aW9ucy5mZXRjaCAtIE9wdGlvbmFsIGN1c3RvbSBgZmV0Y2hgIGltcGxlbWVudGF0aW9uIGZvciBub24tYnJvd3NlciBydW50aW1lcy5cblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGNsaWVudCA9IG5ldyBTdG9yYWdlVmVjdG9yc0NsaWVudCh1cmwsIG9wdGlvbnMpXG5cdCogYGBgXG5cdCovXG5cdGNvbnN0cnVjdG9yKHVybCwgb3B0aW9ucyA9IHt9KSB7XG5cdFx0c3VwZXIodXJsLCBvcHRpb25zLmhlYWRlcnMgfHwge30sIG9wdGlvbnMuZmV0Y2gpO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBBY2Nlc3Mgb3BlcmF0aW9ucyBmb3IgYSBzcGVjaWZpYyB2ZWN0b3IgYnVja2V0XG5cdCogUmV0dXJucyBhIHNjb3BlZCBjbGllbnQgZm9yIGluZGV4IGFuZCB2ZWN0b3Igb3BlcmF0aW9ucyB3aXRoaW4gdGhlIGJ1Y2tldFxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEBwYXJhbSB2ZWN0b3JCdWNrZXROYW1lIC0gTmFtZSBvZiB0aGUgdmVjdG9yIGJ1Y2tldFxuXHQqIEByZXR1cm5zIEJ1Y2tldC1zY29wZWQgY2xpZW50IHdpdGggaW5kZXggYW5kIHZlY3RvciBvcGVyYXRpb25zXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCBidWNrZXQgPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJylcblx0KiBgYGBcblx0Ki9cblx0ZnJvbSh2ZWN0b3JCdWNrZXROYW1lKSB7XG5cdFx0cmV0dXJuIG5ldyBWZWN0b3JCdWNrZXRTY29wZSh0aGlzLnVybCwgdGhpcy5oZWFkZXJzLCB2ZWN0b3JCdWNrZXROYW1lLCB0aGlzLmZldGNoKTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogQ3JlYXRlcyBhIG5ldyB2ZWN0b3IgYnVja2V0XG5cdCogVmVjdG9yIGJ1Y2tldHMgYXJlIGNvbnRhaW5lcnMgZm9yIHZlY3RvciBpbmRleGVzIGFuZCB0aGVpciBkYXRhXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIHZlY3RvckJ1Y2tldE5hbWUgLSBVbmlxdWUgbmFtZSBmb3IgdGhlIHZlY3RvciBidWNrZXRcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggZW1wdHkgcmVzcG9uc2Ugb24gc3VjY2VzcyBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAudmVjdG9yc1xuXHQqICAgLmNyZWF0ZUJ1Y2tldCgnZW1iZWRkaW5ncy1wcm9kJylcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgY3JlYXRlQnVja2V0KHZlY3RvckJ1Y2tldE5hbWUpIHtcblx0XHR2YXIgX3N1cGVycHJvcF9nZXRDcmVhdGVCdWNrZXQgPSAoKSA9PiBzdXBlci5jcmVhdGVCdWNrZXQsIF90aGlzID0gdGhpcztcblx0XHRyZXR1cm4gX3N1cGVycHJvcF9nZXRDcmVhdGVCdWNrZXQoKS5jYWxsKF90aGlzLCB2ZWN0b3JCdWNrZXROYW1lKTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogUmV0cmlldmVzIG1ldGFkYXRhIGZvciBhIHNwZWNpZmljIHZlY3RvciBidWNrZXRcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gdmVjdG9yQnVja2V0TmFtZSAtIE5hbWUgb2YgdGhlIHZlY3RvciBidWNrZXRcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggYnVja2V0IG1ldGFkYXRhIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC52ZWN0b3JzXG5cdCogICAuZ2V0QnVja2V0KCdlbWJlZGRpbmdzLXByb2QnKVxuXHQqXG5cdCogY29uc29sZS5sb2coJ0J1Y2tldCBjcmVhdGVkOicsIGRhdGE/LnZlY3RvckJ1Y2tldC5jcmVhdGlvblRpbWUpXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGdldEJ1Y2tldCh2ZWN0b3JCdWNrZXROYW1lKSB7XG5cdFx0dmFyIF9zdXBlcnByb3BfZ2V0R2V0QnVja2V0ID0gKCkgPT4gc3VwZXIuZ2V0QnVja2V0LCBfdGhpczIgPSB0aGlzO1xuXHRcdHJldHVybiBfc3VwZXJwcm9wX2dldEdldEJ1Y2tldCgpLmNhbGwoX3RoaXMyLCB2ZWN0b3JCdWNrZXROYW1lKTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogTGlzdHMgYWxsIHZlY3RvciBidWNrZXRzIHdpdGggb3B0aW9uYWwgZmlsdGVyaW5nIGFuZCBwYWdpbmF0aW9uXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBmaWx0ZXJzIChwcmVmaXgsIG1heFJlc3VsdHMsIG5leHRUb2tlbilcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggbGlzdCBvZiBidWNrZXRzIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC52ZWN0b3JzXG5cdCogICAubGlzdEJ1Y2tldHMoeyBwcmVmaXg6ICdlbWJlZGRpbmdzLScgfSlcblx0KlxuXHQqIGRhdGE/LnZlY3RvckJ1Y2tldHMuZm9yRWFjaChidWNrZXQgPT4ge1xuXHQqICAgY29uc29sZS5sb2coYnVja2V0LnZlY3RvckJ1Y2tldE5hbWUpXG5cdCogfSlcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgbGlzdEJ1Y2tldHMob3B0aW9ucyA9IHt9KSB7XG5cdFx0dmFyIF9zdXBlcnByb3BfZ2V0TGlzdEJ1Y2tldHMgPSAoKSA9PiBzdXBlci5saXN0QnVja2V0cywgX3RoaXMzID0gdGhpcztcblx0XHRyZXR1cm4gX3N1cGVycHJvcF9nZXRMaXN0QnVja2V0cygpLmNhbGwoX3RoaXMzLCBvcHRpb25zKTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogRGVsZXRlcyBhIHZlY3RvciBidWNrZXQgKGJ1Y2tldCBtdXN0IGJlIGVtcHR5KVxuXHQqIEFsbCBpbmRleGVzIG11c3QgYmUgZGVsZXRlZCBiZWZvcmUgZGVsZXRpbmcgdGhlIGJ1Y2tldFxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEBwYXJhbSB2ZWN0b3JCdWNrZXROYW1lIC0gTmFtZSBvZiB0aGUgdmVjdG9yIGJ1Y2tldCB0byBkZWxldGVcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggZW1wdHkgcmVzcG9uc2Ugb24gc3VjY2VzcyBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAudmVjdG9yc1xuXHQqICAgLmRlbGV0ZUJ1Y2tldCgnZW1iZWRkaW5ncy1vbGQnKVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBkZWxldGVCdWNrZXQodmVjdG9yQnVja2V0TmFtZSkge1xuXHRcdHZhciBfc3VwZXJwcm9wX2dldERlbGV0ZUJ1Y2tldCA9ICgpID0+IHN1cGVyLmRlbGV0ZUJ1Y2tldCwgX3RoaXM0ID0gdGhpcztcblx0XHRyZXR1cm4gX3N1cGVycHJvcF9nZXREZWxldGVCdWNrZXQoKS5jYWxsKF90aGlzNCwgdmVjdG9yQnVja2V0TmFtZSk7XG5cdH1cbn07XG4vKipcbipcbiogQGFscGhhXG4qXG4qIFNjb3BlZCBjbGllbnQgZm9yIG9wZXJhdGlvbnMgd2l0aGluIGEgc3BlY2lmaWMgdmVjdG9yIGJ1Y2tldFxuKiBQcm92aWRlcyBpbmRleCBtYW5hZ2VtZW50IGFuZCBhY2Nlc3MgdG8gdmVjdG9yIG9wZXJhdGlvbnNcbipcbiogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cbiovXG52YXIgVmVjdG9yQnVja2V0U2NvcGUgPSBjbGFzcyBleHRlbmRzIFZlY3RvckluZGV4QXBpIHtcblx0LyoqXG5cdCogQGFscGhhXG5cdCpcblx0KiBDcmVhdGVzIGEgaGVscGVyIHRoYXQgYXV0b21hdGljYWxseSBzY29wZXMgYWxsIGluZGV4IG9wZXJhdGlvbnMgdG8gdGhlIHByb3ZpZGVkIGJ1Y2tldC5cblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCBidWNrZXQgPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJylcblx0KiBgYGBcblx0Ki9cblx0Y29uc3RydWN0b3IodXJsLCBoZWFkZXJzLCB2ZWN0b3JCdWNrZXROYW1lLCBmZXRjaCQxKSB7XG5cdFx0c3VwZXIodXJsLCBoZWFkZXJzLCBmZXRjaCQxKTtcblx0XHR0aGlzLnZlY3RvckJ1Y2tldE5hbWUgPSB2ZWN0b3JCdWNrZXROYW1lO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBDcmVhdGVzIGEgbmV3IHZlY3RvciBpbmRleCBpbiB0aGlzIGJ1Y2tldFxuXHQqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGF1dG9tYXRpY2FsbHkgaW5jbHVkZXMgdGhlIGJ1Y2tldCBuYW1lXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBJbmRleCBjb25maWd1cmF0aW9uICh2ZWN0b3JCdWNrZXROYW1lIGlzIGF1dG9tYXRpY2FsbHkgc2V0KVxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBlbXB0eSByZXNwb25zZSBvbiBzdWNjZXNzIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCBidWNrZXQgPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJylcblx0KiBhd2FpdCBidWNrZXQuY3JlYXRlSW5kZXgoe1xuXHQqICAgaW5kZXhOYW1lOiAnZG9jdW1lbnRzLW9wZW5haScsXG5cdCogICBkYXRhVHlwZTogJ2Zsb2F0MzInLFxuXHQqICAgZGltZW5zaW9uOiAxNTM2LFxuXHQqICAgZGlzdGFuY2VNZXRyaWM6ICdjb3NpbmUnLFxuXHQqICAgbWV0YWRhdGFDb25maWd1cmF0aW9uOiB7XG5cdCogICAgIG5vbkZpbHRlcmFibGVNZXRhZGF0YUtleXM6IFsncmF3X3RleHQnXVxuXHQqICAgfVxuXHQqIH0pXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGNyZWF0ZUluZGV4KG9wdGlvbnMpIHtcblx0XHR2YXIgX3N1cGVycHJvcF9nZXRDcmVhdGVJbmRleCA9ICgpID0+IHN1cGVyLmNyZWF0ZUluZGV4LCBfdGhpczUgPSB0aGlzO1xuXHRcdHJldHVybiBfc3VwZXJwcm9wX2dldENyZWF0ZUluZGV4KCkuY2FsbChfdGhpczUsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBvcHRpb25zKSwge30sIHsgdmVjdG9yQnVja2V0TmFtZTogX3RoaXM1LnZlY3RvckJ1Y2tldE5hbWUgfSkpO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBMaXN0cyBpbmRleGVzIGluIHRoaXMgYnVja2V0XG5cdCogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgYXV0b21hdGljYWxseSBpbmNsdWRlcyB0aGUgYnVja2V0IG5hbWVcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gb3B0aW9ucyAtIExpc3Rpbmcgb3B0aW9ucyAodmVjdG9yQnVja2V0TmFtZSBpcyBhdXRvbWF0aWNhbGx5IHNldClcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBpbmRleGVzIGFycmF5IGFuZCBwYWdpbmF0aW9uIHRva2VuIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCBidWNrZXQgPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJylcblx0KiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGJ1Y2tldC5saXN0SW5kZXhlcyh7IHByZWZpeDogJ2RvY3VtZW50cy0nIH0pXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGxpc3RJbmRleGVzKG9wdGlvbnMgPSB7fSkge1xuXHRcdHZhciBfc3VwZXJwcm9wX2dldExpc3RJbmRleGVzID0gKCkgPT4gc3VwZXIubGlzdEluZGV4ZXMsIF90aGlzNiA9IHRoaXM7XG5cdFx0cmV0dXJuIF9zdXBlcnByb3BfZ2V0TGlzdEluZGV4ZXMoKS5jYWxsKF90aGlzNiwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG9wdGlvbnMpLCB7fSwgeyB2ZWN0b3JCdWNrZXROYW1lOiBfdGhpczYudmVjdG9yQnVja2V0TmFtZSB9KSk7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIFJldHJpZXZlcyBtZXRhZGF0YSBmb3IgYSBzcGVjaWZpYyBpbmRleCBpbiB0aGlzIGJ1Y2tldFxuXHQqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGF1dG9tYXRpY2FsbHkgaW5jbHVkZXMgdGhlIGJ1Y2tldCBuYW1lXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIGluZGV4TmFtZSAtIE5hbWUgb2YgdGhlIGluZGV4IHRvIHJldHJpZXZlXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIGluZGV4IG1ldGFkYXRhIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCBidWNrZXQgPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJylcblx0KiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGJ1Y2tldC5nZXRJbmRleCgnZG9jdW1lbnRzLW9wZW5haScpXG5cdCogY29uc29sZS5sb2coJ0RpbWVuc2lvbjonLCBkYXRhPy5pbmRleC5kaW1lbnNpb24pXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGdldEluZGV4KGluZGV4TmFtZSkge1xuXHRcdHZhciBfc3VwZXJwcm9wX2dldEdldEluZGV4ID0gKCkgPT4gc3VwZXIuZ2V0SW5kZXgsIF90aGlzNyA9IHRoaXM7XG5cdFx0cmV0dXJuIF9zdXBlcnByb3BfZ2V0R2V0SW5kZXgoKS5jYWxsKF90aGlzNywgX3RoaXM3LnZlY3RvckJ1Y2tldE5hbWUsIGluZGV4TmFtZSk7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIERlbGV0ZXMgYW4gaW5kZXggZnJvbSB0aGlzIGJ1Y2tldFxuXHQqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGF1dG9tYXRpY2FsbHkgaW5jbHVkZXMgdGhlIGJ1Y2tldCBuYW1lXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIGluZGV4TmFtZSAtIE5hbWUgb2YgdGhlIGluZGV4IHRvIGRlbGV0ZVxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBlbXB0eSByZXNwb25zZSBvbiBzdWNjZXNzIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCBidWNrZXQgPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJylcblx0KiBhd2FpdCBidWNrZXQuZGVsZXRlSW5kZXgoJ29sZC1pbmRleCcpXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGRlbGV0ZUluZGV4KGluZGV4TmFtZSkge1xuXHRcdHZhciBfc3VwZXJwcm9wX2dldERlbGV0ZUluZGV4ID0gKCkgPT4gc3VwZXIuZGVsZXRlSW5kZXgsIF90aGlzOCA9IHRoaXM7XG5cdFx0cmV0dXJuIF9zdXBlcnByb3BfZ2V0RGVsZXRlSW5kZXgoKS5jYWxsKF90aGlzOCwgX3RoaXM4LnZlY3RvckJ1Y2tldE5hbWUsIGluZGV4TmFtZSk7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIEFjY2VzcyBvcGVyYXRpb25zIGZvciBhIHNwZWNpZmljIGluZGV4IHdpdGhpbiB0aGlzIGJ1Y2tldFxuXHQqIFJldHVybnMgYSBzY29wZWQgY2xpZW50IGZvciB2ZWN0b3IgZGF0YSBvcGVyYXRpb25zXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIGluZGV4TmFtZSAtIE5hbWUgb2YgdGhlIGluZGV4XG5cdCogQHJldHVybnMgSW5kZXgtc2NvcGVkIGNsaWVudCB3aXRoIHZlY3RvciBkYXRhIG9wZXJhdGlvbnNcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGluZGV4ID0gc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpLmluZGV4KCdkb2N1bWVudHMtb3BlbmFpJylcblx0KlxuXHQqIC8vIEluc2VydCB2ZWN0b3JzXG5cdCogYXdhaXQgaW5kZXgucHV0VmVjdG9ycyh7XG5cdCogICB2ZWN0b3JzOiBbXG5cdCogICAgIHsga2V5OiAnZG9jLTEnLCBkYXRhOiB7IGZsb2F0MzI6IFsuLi5dIH0sIG1ldGFkYXRhOiB7IHRpdGxlOiAnSW50cm8nIH0gfVxuXHQqICAgXVxuXHQqIH0pXG5cdCpcblx0KiAvLyBRdWVyeSBzaW1pbGFyIHZlY3RvcnNcblx0KiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGluZGV4LnF1ZXJ5VmVjdG9ycyh7XG5cdCogICBxdWVyeVZlY3RvcjogeyBmbG9hdDMyOiBbLi4uXSB9LFxuXHQqICAgdG9wSzogNVxuXHQqIH0pXG5cdCogYGBgXG5cdCovXG5cdGluZGV4KGluZGV4TmFtZSkge1xuXHRcdHJldHVybiBuZXcgVmVjdG9ySW5kZXhTY29wZSh0aGlzLnVybCwgdGhpcy5oZWFkZXJzLCB0aGlzLnZlY3RvckJ1Y2tldE5hbWUsIGluZGV4TmFtZSwgdGhpcy5mZXRjaCk7XG5cdH1cbn07XG4vKipcbipcbiogQGFscGhhXG4qXG4qIFNjb3BlZCBjbGllbnQgZm9yIG9wZXJhdGlvbnMgd2l0aGluIGEgc3BlY2lmaWMgdmVjdG9yIGluZGV4XG4qIFByb3ZpZGVzIHZlY3RvciBkYXRhIG9wZXJhdGlvbnMgKHB1dCwgZ2V0LCBsaXN0LCBxdWVyeSwgZGVsZXRlKVxuKlxuKiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuKi9cbnZhciBWZWN0b3JJbmRleFNjb3BlID0gY2xhc3MgZXh0ZW5kcyBWZWN0b3JEYXRhQXBpIHtcblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIENyZWF0ZXMgYSBoZWxwZXIgdGhhdCBhdXRvbWF0aWNhbGx5IHNjb3BlcyBhbGwgdmVjdG9yIG9wZXJhdGlvbnMgdG8gdGhlIHByb3ZpZGVkIGJ1Y2tldC9pbmRleCBuYW1lcy5cblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCBpbmRleCA9IHN1cGFiYXNlLnN0b3JhZ2UudmVjdG9ycy5mcm9tKCdlbWJlZGRpbmdzLXByb2QnKS5pbmRleCgnZG9jdW1lbnRzLW9wZW5haScpXG5cdCogYGBgXG5cdCovXG5cdGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycywgdmVjdG9yQnVja2V0TmFtZSwgaW5kZXhOYW1lLCBmZXRjaCQxKSB7XG5cdFx0c3VwZXIodXJsLCBoZWFkZXJzLCBmZXRjaCQxKTtcblx0XHR0aGlzLnZlY3RvckJ1Y2tldE5hbWUgPSB2ZWN0b3JCdWNrZXROYW1lO1xuXHRcdHRoaXMuaW5kZXhOYW1lID0gaW5kZXhOYW1lO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBJbnNlcnRzIG9yIHVwZGF0ZXMgdmVjdG9ycyBpbiB0aGlzIGluZGV4XG5cdCogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgYXV0b21hdGljYWxseSBpbmNsdWRlcyBidWNrZXQgYW5kIGluZGV4IG5hbWVzXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBWZWN0b3IgaW5zZXJ0aW9uIG9wdGlvbnMgKGJ1Y2tldCBhbmQgaW5kZXggbmFtZXMgYXV0b21hdGljYWxseSBzZXQpXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIGVtcHR5IHJlc3BvbnNlIG9uIHN1Y2Nlc3Mgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGluZGV4ID0gc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpLmluZGV4KCdkb2N1bWVudHMtb3BlbmFpJylcblx0KiBhd2FpdCBpbmRleC5wdXRWZWN0b3JzKHtcblx0KiAgIHZlY3RvcnM6IFtcblx0KiAgICAge1xuXHQqICAgICAgIGtleTogJ2RvYy0xJyxcblx0KiAgICAgICBkYXRhOiB7IGZsb2F0MzI6IFswLjEsIDAuMiwgLi4uXSB9LFxuXHQqICAgICAgIG1ldGFkYXRhOiB7IHRpdGxlOiAnSW50cm9kdWN0aW9uJywgcGFnZTogMSB9XG5cdCogICAgIH1cblx0KiAgIF1cblx0KiB9KVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBwdXRWZWN0b3JzKG9wdGlvbnMpIHtcblx0XHR2YXIgX3N1cGVycHJvcF9nZXRQdXRWZWN0b3JzID0gKCkgPT4gc3VwZXIucHV0VmVjdG9ycywgX3RoaXM5ID0gdGhpcztcblx0XHRyZXR1cm4gX3N1cGVycHJvcF9nZXRQdXRWZWN0b3JzKCkuY2FsbChfdGhpczksIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBvcHRpb25zKSwge30sIHtcblx0XHRcdHZlY3RvckJ1Y2tldE5hbWU6IF90aGlzOS52ZWN0b3JCdWNrZXROYW1lLFxuXHRcdFx0aW5kZXhOYW1lOiBfdGhpczkuaW5kZXhOYW1lXG5cdFx0fSkpO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBSZXRyaWV2ZXMgdmVjdG9ycyBieSBrZXlzIGZyb20gdGhpcyBpbmRleFxuXHQqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGF1dG9tYXRpY2FsbHkgaW5jbHVkZXMgYnVja2V0IGFuZCBpbmRleCBuYW1lc1xuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEBwYXJhbSBvcHRpb25zIC0gVmVjdG9yIHJldHJpZXZhbCBvcHRpb25zIChidWNrZXQgYW5kIGluZGV4IG5hbWVzIGF1dG9tYXRpY2FsbHkgc2V0KVxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIHZlY3RvcnMgYXJyYXkgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGluZGV4ID0gc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpLmluZGV4KCdkb2N1bWVudHMtb3BlbmFpJylcblx0KiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGluZGV4LmdldFZlY3RvcnMoe1xuXHQqICAga2V5czogWydkb2MtMScsICdkb2MtMiddLFxuXHQqICAgcmV0dXJuTWV0YWRhdGE6IHRydWVcblx0KiB9KVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBnZXRWZWN0b3JzKG9wdGlvbnMpIHtcblx0XHR2YXIgX3N1cGVycHJvcF9nZXRHZXRWZWN0b3JzID0gKCkgPT4gc3VwZXIuZ2V0VmVjdG9ycywgX3RoaXMxMCA9IHRoaXM7XG5cdFx0cmV0dXJuIF9zdXBlcnByb3BfZ2V0R2V0VmVjdG9ycygpLmNhbGwoX3RoaXMxMCwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG9wdGlvbnMpLCB7fSwge1xuXHRcdFx0dmVjdG9yQnVja2V0TmFtZTogX3RoaXMxMC52ZWN0b3JCdWNrZXROYW1lLFxuXHRcdFx0aW5kZXhOYW1lOiBfdGhpczEwLmluZGV4TmFtZVxuXHRcdH0pKTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogTGlzdHMgdmVjdG9ycyBpbiB0aGlzIGluZGV4IHdpdGggcGFnaW5hdGlvblxuXHQqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGF1dG9tYXRpY2FsbHkgaW5jbHVkZXMgYnVja2V0IGFuZCBpbmRleCBuYW1lc1xuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEBwYXJhbSBvcHRpb25zIC0gTGlzdGluZyBvcHRpb25zIChidWNrZXQgYW5kIGluZGV4IG5hbWVzIGF1dG9tYXRpY2FsbHkgc2V0KVxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIHZlY3RvcnMgYXJyYXkgYW5kIHBhZ2luYXRpb24gdG9rZW4gb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGluZGV4ID0gc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpLmluZGV4KCdkb2N1bWVudHMtb3BlbmFpJylcblx0KiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGluZGV4Lmxpc3RWZWN0b3JzKHtcblx0KiAgIG1heFJlc3VsdHM6IDUwMCxcblx0KiAgIHJldHVybk1ldGFkYXRhOiB0cnVlXG5cdCogfSlcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgbGlzdFZlY3RvcnMob3B0aW9ucyA9IHt9KSB7XG5cdFx0dmFyIF9zdXBlcnByb3BfZ2V0TGlzdFZlY3RvcnMgPSAoKSA9PiBzdXBlci5saXN0VmVjdG9ycywgX3RoaXMxMSA9IHRoaXM7XG5cdFx0cmV0dXJuIF9zdXBlcnByb3BfZ2V0TGlzdFZlY3RvcnMoKS5jYWxsKF90aGlzMTEsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBvcHRpb25zKSwge30sIHtcblx0XHRcdHZlY3RvckJ1Y2tldE5hbWU6IF90aGlzMTEudmVjdG9yQnVja2V0TmFtZSxcblx0XHRcdGluZGV4TmFtZTogX3RoaXMxMS5pbmRleE5hbWVcblx0XHR9KSk7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIFF1ZXJpZXMgZm9yIHNpbWlsYXIgdmVjdG9ycyBpbiB0aGlzIGluZGV4XG5cdCogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgYXV0b21hdGljYWxseSBpbmNsdWRlcyBidWNrZXQgYW5kIGluZGV4IG5hbWVzXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBRdWVyeSBvcHRpb25zIChidWNrZXQgYW5kIGluZGV4IG5hbWVzIGF1dG9tYXRpY2FsbHkgc2V0KVxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIG1hdGNoZXMgYXJyYXkgb2Ygc2ltaWxhciB2ZWN0b3JzIG9yZGVyZWQgYnkgZGlzdGFuY2Ugb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGluZGV4ID0gc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpLmluZGV4KCdkb2N1bWVudHMtb3BlbmFpJylcblx0KiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGluZGV4LnF1ZXJ5VmVjdG9ycyh7XG5cdCogICBxdWVyeVZlY3RvcjogeyBmbG9hdDMyOiBbMC4xLCAwLjIsIC4uLl0gfSxcblx0KiAgIHRvcEs6IDUsXG5cdCogICBmaWx0ZXI6IHsgY2F0ZWdvcnk6ICd0ZWNobmljYWwnIH0sXG5cdCogICByZXR1cm5EaXN0YW5jZTogdHJ1ZSxcblx0KiAgIHJldHVybk1ldGFkYXRhOiB0cnVlXG5cdCogfSlcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgcXVlcnlWZWN0b3JzKG9wdGlvbnMpIHtcblx0XHR2YXIgX3N1cGVycHJvcF9nZXRRdWVyeVZlY3RvcnMgPSAoKSA9PiBzdXBlci5xdWVyeVZlY3RvcnMsIF90aGlzMTIgPSB0aGlzO1xuXHRcdHJldHVybiBfc3VwZXJwcm9wX2dldFF1ZXJ5VmVjdG9ycygpLmNhbGwoX3RoaXMxMiwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG9wdGlvbnMpLCB7fSwge1xuXHRcdFx0dmVjdG9yQnVja2V0TmFtZTogX3RoaXMxMi52ZWN0b3JCdWNrZXROYW1lLFxuXHRcdFx0aW5kZXhOYW1lOiBfdGhpczEyLmluZGV4TmFtZVxuXHRcdH0pKTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogRGVsZXRlcyB2ZWN0b3JzIGJ5IGtleXMgZnJvbSB0aGlzIGluZGV4XG5cdCogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgYXV0b21hdGljYWxseSBpbmNsdWRlcyBidWNrZXQgYW5kIGluZGV4IG5hbWVzXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBEZWxldGlvbiBvcHRpb25zIChidWNrZXQgYW5kIGluZGV4IG5hbWVzIGF1dG9tYXRpY2FsbHkgc2V0KVxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBlbXB0eSByZXNwb25zZSBvbiBzdWNjZXNzIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCBpbmRleCA9IHN1cGFiYXNlLnN0b3JhZ2UudmVjdG9ycy5mcm9tKCdlbWJlZGRpbmdzLXByb2QnKS5pbmRleCgnZG9jdW1lbnRzLW9wZW5haScpXG5cdCogYXdhaXQgaW5kZXguZGVsZXRlVmVjdG9ycyh7XG5cdCogICBrZXlzOiBbJ2RvYy0xJywgJ2RvYy0yJywgJ2RvYy0zJ11cblx0KiB9KVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBkZWxldGVWZWN0b3JzKG9wdGlvbnMpIHtcblx0XHR2YXIgX3N1cGVycHJvcF9nZXREZWxldGVWZWN0b3JzID0gKCkgPT4gc3VwZXIuZGVsZXRlVmVjdG9ycywgX3RoaXMxMyA9IHRoaXM7XG5cdFx0cmV0dXJuIF9zdXBlcnByb3BfZ2V0RGVsZXRlVmVjdG9ycygpLmNhbGwoX3RoaXMxMywgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG9wdGlvbnMpLCB7fSwge1xuXHRcdFx0dmVjdG9yQnVja2V0TmFtZTogX3RoaXMxMy52ZWN0b3JCdWNrZXROYW1lLFxuXHRcdFx0aW5kZXhOYW1lOiBfdGhpczEzLmluZGV4TmFtZVxuXHRcdH0pKTtcblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL1N0b3JhZ2VDbGllbnQudHNcbnZhciBTdG9yYWdlQ2xpZW50ID0gY2xhc3MgZXh0ZW5kcyBTdG9yYWdlQnVja2V0QXBpIHtcblx0LyoqXG5cdCogQ3JlYXRlcyBhIGNsaWVudCBmb3IgU3RvcmFnZSBidWNrZXRzLCBmaWxlcywgYW5hbHl0aWNzLCBhbmQgdmVjdG9ycy5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHRzXG5cdCogaW1wb3J0IHsgU3RvcmFnZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdG9yYWdlLWpzJ1xuXHQqXG5cdCogY29uc3Qgc3RvcmFnZSA9IG5ldyBTdG9yYWdlQ2xpZW50KCdodHRwczovL3h5emNvbXBhbnkuc3VwYWJhc2UuY28vc3RvcmFnZS92MScsIHtcblx0KiAgIGFwaWtleTogJ3B1YmxpYy1hbm9uLWtleScsXG5cdCogfSlcblx0KiBjb25zdCBhdmF0YXJzID0gc3RvcmFnZS5mcm9tKCdhdmF0YXJzJylcblx0KiBgYGBcblx0Ki9cblx0Y29uc3RydWN0b3IodXJsLCBoZWFkZXJzID0ge30sIGZldGNoJDEsIG9wdHMpIHtcblx0XHRzdXBlcih1cmwsIGhlYWRlcnMsIGZldGNoJDEsIG9wdHMpO1xuXHR9XG5cdC8qKlxuXHQqIFBlcmZvcm0gZmlsZSBvcGVyYXRpb24gaW4gYSBidWNrZXQuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIGlkIFRoZSBidWNrZXQgaWQgdG8gb3BlcmF0ZSBvbi5cblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGF2YXRhcnMgPSBzdXBhYmFzZS5zdG9yYWdlLmZyb20oJ2F2YXRhcnMnKVxuXHQqIGBgYFxuXHQqL1xuXHRmcm9tKGlkKSB7XG5cdFx0cmV0dXJuIG5ldyBTdG9yYWdlRmlsZUFwaSh0aGlzLnVybCwgdGhpcy5oZWFkZXJzLCBpZCwgdGhpcy5mZXRjaCk7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIEFjY2VzcyB2ZWN0b3Igc3RvcmFnZSBvcGVyYXRpb25zLlxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEByZXR1cm5zIEEgU3RvcmFnZVZlY3RvcnNDbGllbnQgaW5zdGFuY2UgY29uZmlndXJlZCB3aXRoIHRoZSBjdXJyZW50IHN0b3JhZ2Ugc2V0dGluZ3MuXG5cdCovXG5cdGdldCB2ZWN0b3JzKCkge1xuXHRcdHJldHVybiBuZXcgU3RvcmFnZVZlY3RvcnNDbGllbnQodGhpcy51cmwgKyBcIi92ZWN0b3JcIiwge1xuXHRcdFx0aGVhZGVyczogdGhpcy5oZWFkZXJzLFxuXHRcdFx0ZmV0Y2g6IHRoaXMuZmV0Y2hcblx0XHR9KTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogQWNjZXNzIGFuYWx5dGljcyBzdG9yYWdlIG9wZXJhdGlvbnMgdXNpbmcgSWNlYmVyZyB0YWJsZXMuXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IEFuYWx5dGljcyBCdWNrZXRzXG5cdCogQHJldHVybnMgQSBTdG9yYWdlQW5hbHl0aWNzQ2xpZW50IGluc3RhbmNlIGNvbmZpZ3VyZWQgd2l0aCB0aGUgY3VycmVudCBzdG9yYWdlIHNldHRpbmdzLlxuXHQqL1xuXHRnZXQgYW5hbHl0aWNzKCkge1xuXHRcdHJldHVybiBuZXcgU3RvcmFnZUFuYWx5dGljc0NsaWVudCh0aGlzLnVybCArIFwiL2ljZWJlcmdcIiwgdGhpcy5oZWFkZXJzLCB0aGlzLmZldGNoKTtcblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG5leHBvcnQgeyBTdG9yYWdlQW5hbHl0aWNzQ2xpZW50LCBTdG9yYWdlQXBpRXJyb3IsIFN0b3JhZ2VDbGllbnQsIFN0b3JhZ2VFcnJvciwgU3RvcmFnZVVua25vd25FcnJvciwgU3RvcmFnZVZlY3RvcnNBcGlFcnJvciwgU3RvcmFnZVZlY3RvcnNDbGllbnQsIFN0b3JhZ2VWZWN0b3JzRXJyb3IsIFN0b3JhZ2VWZWN0b3JzRXJyb3JDb2RlLCBTdG9yYWdlVmVjdG9yc1Vua25vd25FcnJvciwgVmVjdG9yQnVja2V0QXBpLCBWZWN0b3JCdWNrZXRTY29wZSwgVmVjdG9yRGF0YUFwaSwgVmVjdG9ySW5kZXhBcGksIFZlY3RvckluZGV4U2NvcGUsIGlzUGxhaW5PYmplY3QsIGlzU3RvcmFnZUVycm9yLCBpc1N0b3JhZ2VWZWN0b3JzRXJyb3IsIG5vcm1hbGl6ZVRvRmxvYXQzMiwgcmVzb2x2ZUZldGNoLCByZXNvbHZlUmVzcG9uc2UsIHZhbGlkYXRlVmVjdG9yRGltZW5zaW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbIkljZWJlcmdSZXN0Q2F0YWxvZyIsIlN0b3JhZ2VFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwiX19pc1N0b3JhZ2VFcnJvciIsIm5hbWUiLCJpc1N0b3JhZ2VFcnJvciIsImVycm9yIiwiU3RvcmFnZUFwaUVycm9yIiwic3RhdHVzIiwic3RhdHVzQ29kZSIsInRvSlNPTiIsIlN0b3JhZ2VVbmtub3duRXJyb3IiLCJvcmlnaW5hbEVycm9yIiwicmVzb2x2ZUZldGNoJDEiLCJjdXN0b21GZXRjaCIsImFyZ3MiLCJmZXRjaCIsInJlc29sdmVSZXNwb25zZSQxIiwiUmVzcG9uc2UiLCJyZWN1cnNpdmVUb0NhbWVsIiwiaXRlbSIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsImVsIiwiT2JqZWN0IiwicmVzdWx0IiwiZW50cmllcyIsImZvckVhY2giLCJrZXkiLCJ2YWx1ZSIsIm5ld0tleSIsInJlcGxhY2UiLCJjIiwidG9VcHBlckNhc2UiLCJpc1BsYWluT2JqZWN0JDEiLCJwcm90b3R5cGUiLCJnZXRQcm90b3R5cGVPZiIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwiaXRlcmF0b3IiLCJpc1ZhbGlkQnVja2V0TmFtZSIsImJ1Y2tldE5hbWUiLCJsZW5ndGgiLCJ0cmltIiwiaW5jbHVkZXMiLCJ0ZXN0IiwiX3R5cGVvZiIsIm8iLCJvJDEiLCJ0b1ByaW1pdGl2ZSIsInQiLCJyIiwiZSIsImkiLCJjYWxsIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiTnVtYmVyIiwidG9Qcm9wZXJ0eUtleSIsIl9kZWZpbmVQcm9wZXJ0eSIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwib3duS2V5cyIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJyJDEiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkMiIsImFyZ3VtZW50cyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX2dldEVycm9yTWVzc2FnZSQxIiwiZXJyIiwiX2VyciRlcnJvciIsIm1zZyIsImVycm9yX2Rlc2NyaXB0aW9uIiwiSlNPTiIsInN0cmluZ2lmeSIsImhhbmRsZUVycm9yJDEiLCJyZWplY3QiLCJvcHRpb25zIiwibm9SZXNvbHZlSnNvbiIsImpzb24iLCJ0aGVuIiwiY2F0Y2giLCJfZ2V0UmVxdWVzdFBhcmFtcyQxIiwibWV0aG9kIiwicGFyYW1ldGVycyIsImJvZHkiLCJwYXJhbXMiLCJoZWFkZXJzIiwiZHVwbGV4IiwiX2hhbmRsZVJlcXVlc3QkMSIsImZldGNoZXIiLCJ1cmwiLCJQcm9taXNlIiwicmVzb2x2ZSIsIm9rIiwiZGF0YSIsImdldCIsInBvc3QkMSIsInB1dCIsImhlYWQiLCJyZW1vdmUiLCJTdHJlYW1Eb3dubG9hZEJ1aWxkZXIiLCJkb3dubG9hZEZuIiwic2hvdWxkVGhyb3dPbkVycm9yIiwib25mdWxmaWxsZWQiLCJvbnJlamVjdGVkIiwiZXhlY3V0ZSIsIl90aGlzIiwiX1N5bWJvbCR0b1N0cmluZ1RhZyIsIkJsb2JEb3dubG9hZEJ1aWxkZXIiLCJwcm9taXNlIiwiYXNTdHJlYW0iLCJnZXRQcm9taXNlIiwiZmluYWxseSIsIm9uZmluYWxseSIsImJsb2IiLCJERUZBVUxUX1NFQVJDSF9PUFRJT05TIiwibGltaXQiLCJvZmZzZXQiLCJzb3J0QnkiLCJjb2x1bW4iLCJvcmRlciIsIkRFRkFVTFRfRklMRV9PUFRJT05TIiwiY2FjaGVDb250cm9sIiwiY29udGVudFR5cGUiLCJ1cHNlcnQiLCJTdG9yYWdlRmlsZUFwaSIsImJ1Y2tldElkIiwiZmV0Y2gkMSIsInRocm93T25FcnJvciIsInVwbG9hZE9yVXBkYXRlIiwicGF0aCIsImZpbGVCb2R5IiwiZmlsZU9wdGlvbnMiLCJtZXRhZGF0YSIsIkJsb2IiLCJGb3JtRGF0YSIsImFwcGVuZCIsImVuY29kZU1ldGFkYXRhIiwiaGFzIiwidG9CYXNlNjQiLCJSZWFkYWJsZVN0cmVhbSIsInBpcGUiLCJjbGVhblBhdGgiLCJfcmVtb3ZlRW1wdHlGb2xkZXJzIiwiX3BhdGgiLCJfZ2V0RmluYWxQYXRoIiwiaWQiLCJJZCIsImZ1bGxQYXRoIiwiS2V5IiwidXBsb2FkIiwidXBsb2FkVG9TaWduZWRVcmwiLCJ0b2tlbiIsIl90aGlzMyIsIlVSTCIsInNlYXJjaFBhcmFtcyIsInNldCIsInRvU3RyaW5nIiwiY3JlYXRlU2lnbmVkVXBsb2FkVXJsIiwiX3RoaXM0Iiwic2lnbmVkVXJsIiwidXBkYXRlIiwibW92ZSIsImZyb21QYXRoIiwidG9QYXRoIiwiX3RoaXM2Iiwic291cmNlS2V5IiwiZGVzdGluYXRpb25LZXkiLCJkZXN0aW5hdGlvbkJ1Y2tldCIsImNvcHkiLCJfdGhpczciLCJjcmVhdGVTaWduZWRVcmwiLCJleHBpcmVzSW4iLCJfdGhpczgiLCJ0cmFuc2Zvcm0iLCJkb3dubG9hZFF1ZXJ5UGFyYW0iLCJkb3dubG9hZCIsImVuY29kZVVSSSIsInNpZ25lZFVSTCIsImNyZWF0ZVNpZ25lZFVybHMiLCJwYXRocyIsIl90aGlzOSIsImRhdHVtIiwicmVuZGVyUGF0aCIsInRyYW5zZm9ybWF0aW9uUXVlcnkiLCJ0cmFuc2Zvcm1PcHRzVG9RdWVyeVN0cmluZyIsInF1ZXJ5U3RyaW5nIiwiaW5mbyIsIl90aGlzMTAiLCJleGlzdHMiLCJfdGhpczExIiwiZ2V0UHVibGljVXJsIiwiX3F1ZXJ5U3RyaW5nIiwiam9pbiIsInB1YmxpY1VybCIsIl90aGlzMTIiLCJwcmVmaXhlcyIsImxpc3QiLCJfdGhpczEzIiwicHJlZml4IiwibGlzdFYyIiwiX3RoaXMxNCIsIkJ1ZmZlciIsImZyb20iLCJidG9hIiwid2lkdGgiLCJoZWlnaHQiLCJyZXNpemUiLCJmb3JtYXQiLCJxdWFsaXR5IiwidmVyc2lvbiIsIkRFRkFVTFRfSEVBREVSUyQxIiwiU3RvcmFnZUJ1Y2tldEFwaSIsIm9wdHMiLCJiYXNlVXJsIiwidXNlTmV3SG9zdG5hbWUiLCJob3N0bmFtZSIsImhyZWYiLCJsaXN0QnVja2V0cyIsImxpc3RCdWNrZXRPcHRpb25zVG9RdWVyeVN0cmluZyIsImdldEJ1Y2tldCIsIl90aGlzMiIsImNyZWF0ZUJ1Y2tldCIsInB1YmxpYyIsInR5cGUiLCJmaWxlX3NpemVfbGltaXQiLCJmaWxlU2l6ZUxpbWl0IiwiYWxsb3dlZF9taW1lX3R5cGVzIiwiYWxsb3dlZE1pbWVUeXBlcyIsInVwZGF0ZUJ1Y2tldCIsImVtcHR5QnVja2V0IiwiX3RoaXM1IiwiZGVsZXRlQnVja2V0Iiwic2VhcmNoIiwic29ydENvbHVtbiIsInNvcnRPcmRlciIsIlVSTFNlYXJjaFBhcmFtcyIsIlN0b3JhZ2VBbmFseXRpY3NDbGllbnQiLCJxdWVyeVBhcmFtcyIsImNhdGFsb2ciLCJjYXRhbG9nTmFtZSIsImF1dGgiLCJnZXRIZWFkZXJzIiwiUHJveHkiLCJ0YXJnZXQiLCJwcm9wIiwiREVGQVVMVF9IRUFERVJTIiwiU3RvcmFnZVZlY3RvcnNFcnJvciIsIl9faXNTdG9yYWdlVmVjdG9yc0Vycm9yIiwiaXNTdG9yYWdlVmVjdG9yc0Vycm9yIiwiU3RvcmFnZVZlY3RvcnNBcGlFcnJvciIsIlN0b3JhZ2VWZWN0b3JzVW5rbm93bkVycm9yIiwiU3RvcmFnZVZlY3RvcnNFcnJvckNvZGUiLCJTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSQxIiwicmVzb2x2ZUZldGNoIiwicmVzb2x2ZVJlc3BvbnNlIiwiaXNQbGFpbk9iamVjdCIsIm5vcm1hbGl6ZVRvRmxvYXQzMiIsInZhbHVlcyIsIkZsb2F0MzJBcnJheSIsInZhbGlkYXRlVmVjdG9yRGltZW5zaW9uIiwidmVjdG9yIiwiZXhwZWN0ZWREaW1lbnNpb24iLCJmbG9hdDMyIiwiX2dldEVycm9yTWVzc2FnZSIsImhhbmRsZUVycm9yIiwicmVzcG9uc2VFcnJvciIsImNvZGUiLCJzdGF0dXNUZXh0IiwiX2dldFJlcXVlc3RQYXJhbXMiLCJfaGFuZGxlUmVxdWVzdCIsInBvc3QiLCJWZWN0b3JJbmRleEFwaSIsImNyZWF0ZUluZGV4IiwiZ2V0SW5kZXgiLCJ2ZWN0b3JCdWNrZXROYW1lIiwiaW5kZXhOYW1lIiwibGlzdEluZGV4ZXMiLCJkZWxldGVJbmRleCIsIlZlY3RvckRhdGFBcGkiLCJwdXRWZWN0b3JzIiwidmVjdG9ycyIsImdldFZlY3RvcnMiLCJsaXN0VmVjdG9ycyIsInNlZ21lbnRDb3VudCIsInNlZ21lbnRJbmRleCIsInF1ZXJ5VmVjdG9ycyIsImRlbGV0ZVZlY3RvcnMiLCJWZWN0b3JCdWNrZXRBcGkiLCJTdG9yYWdlVmVjdG9yc0NsaWVudCIsIlZlY3RvckJ1Y2tldFNjb3BlIiwiX3N1cGVycHJvcF9nZXRDcmVhdGVCdWNrZXQiLCJfc3VwZXJwcm9wX2dldEdldEJ1Y2tldCIsIl9zdXBlcnByb3BfZ2V0TGlzdEJ1Y2tldHMiLCJfc3VwZXJwcm9wX2dldERlbGV0ZUJ1Y2tldCIsIl9zdXBlcnByb3BfZ2V0Q3JlYXRlSW5kZXgiLCJfc3VwZXJwcm9wX2dldExpc3RJbmRleGVzIiwiX3N1cGVycHJvcF9nZXRHZXRJbmRleCIsIl9zdXBlcnByb3BfZ2V0RGVsZXRlSW5kZXgiLCJpbmRleCIsIlZlY3RvckluZGV4U2NvcGUiLCJfc3VwZXJwcm9wX2dldFB1dFZlY3RvcnMiLCJfc3VwZXJwcm9wX2dldEdldFZlY3RvcnMiLCJfc3VwZXJwcm9wX2dldExpc3RWZWN0b3JzIiwiX3N1cGVycHJvcF9nZXRRdWVyeVZlY3RvcnMiLCJfc3VwZXJwcm9wX2dldERlbGV0ZVZlY3RvcnMiLCJTdG9yYWdlQ2xpZW50IiwiYW5hbHl0aWNzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@supabase+storage-js@2.91.0/node_modules/@supabase/storage-js/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@supabase+storage-js@2.91.0/node_modules/@supabase/storage-js/dist/index.mjs":
/*!*************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@supabase+storage-js@2.91.0/node_modules/@supabase/storage-js/dist/index.mjs ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StorageAnalyticsClient: () => (/* binding */ StorageAnalyticsClient),\n/* harmony export */   StorageApiError: () => (/* binding */ StorageApiError),\n/* harmony export */   StorageClient: () => (/* binding */ StorageClient),\n/* harmony export */   StorageError: () => (/* binding */ StorageError),\n/* harmony export */   StorageUnknownError: () => (/* binding */ StorageUnknownError),\n/* harmony export */   StorageVectorsApiError: () => (/* binding */ StorageVectorsApiError),\n/* harmony export */   StorageVectorsClient: () => (/* binding */ StorageVectorsClient),\n/* harmony export */   StorageVectorsError: () => (/* binding */ StorageVectorsError),\n/* harmony export */   StorageVectorsErrorCode: () => (/* binding */ StorageVectorsErrorCode),\n/* harmony export */   StorageVectorsUnknownError: () => (/* binding */ StorageVectorsUnknownError),\n/* harmony export */   VectorBucketApi: () => (/* binding */ VectorBucketApi),\n/* harmony export */   VectorBucketScope: () => (/* binding */ VectorBucketScope),\n/* harmony export */   VectorDataApi: () => (/* binding */ VectorDataApi),\n/* harmony export */   VectorIndexApi: () => (/* binding */ VectorIndexApi),\n/* harmony export */   VectorIndexScope: () => (/* binding */ VectorIndexScope),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isStorageError: () => (/* binding */ isStorageError),\n/* harmony export */   isStorageVectorsError: () => (/* binding */ isStorageVectorsError),\n/* harmony export */   normalizeToFloat32: () => (/* binding */ normalizeToFloat32),\n/* harmony export */   resolveFetch: () => (/* binding */ resolveFetch),\n/* harmony export */   resolveResponse: () => (/* binding */ resolveResponse),\n/* harmony export */   validateVectorDimension: () => (/* binding */ validateVectorDimension)\n/* harmony export */ });\n/* harmony import */ var iceberg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! iceberg-js */ \"(rsc)/../../node_modules/.pnpm/iceberg-js@0.8.1/node_modules/iceberg-js/dist/index.mjs\");\n\n//#region src/lib/errors.ts\nvar StorageError = class extends Error {\n    constructor(message){\n        super(message);\n        this.__isStorageError = true;\n        this.name = \"StorageError\";\n    }\n};\nfunction isStorageError(error) {\n    return typeof error === \"object\" && error !== null && \"__isStorageError\" in error;\n}\nvar StorageApiError = class extends StorageError {\n    constructor(message, status, statusCode){\n        super(message);\n        this.name = \"StorageApiError\";\n        this.status = status;\n        this.statusCode = statusCode;\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            status: this.status,\n            statusCode: this.statusCode\n        };\n    }\n};\nvar StorageUnknownError = class extends StorageError {\n    constructor(message, originalError){\n        super(message);\n        this.name = \"StorageUnknownError\";\n        this.originalError = originalError;\n    }\n};\n//#endregion\n//#region src/lib/helpers.ts\nconst resolveFetch$1 = (customFetch)=>{\n    if (customFetch) return (...args)=>customFetch(...args);\n    return (...args)=>fetch(...args);\n};\nconst resolveResponse$1 = ()=>{\n    return Response;\n};\nconst recursiveToCamel = (item)=>{\n    if (Array.isArray(item)) return item.map((el)=>recursiveToCamel(el));\n    else if (typeof item === \"function\" || item !== Object(item)) return item;\n    const result = {};\n    Object.entries(item).forEach(([key, value])=>{\n        const newKey = key.replace(/([-_][a-z])/gi, (c)=>c.toUpperCase().replace(/[-_]/g, \"\"));\n        result[newKey] = recursiveToCamel(value);\n    });\n    return result;\n};\n/**\n* Determine if input is a plain object\n* An object is plain if it's created by either {}, new Object(), or Object.create(null)\n* source: https://github.com/sindresorhus/is-plain-obj\n*/ const isPlainObject$1 = (value)=>{\n    if (typeof value !== \"object\" || value === null) return false;\n    const prototype = Object.getPrototypeOf(value);\n    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n};\n/**\n* Validates if a given bucket name is valid according to Supabase Storage API rules\n* Mirrors backend validation from: storage/src/storage/limits.ts:isValidBucketName()\n*\n* Rules:\n* - Length: 1-100 characters\n* - Allowed characters: alphanumeric (a-z, A-Z, 0-9), underscore (_), and safe special characters\n* - Safe special characters: ! - . * ' ( ) space & $ @ = ; : + , ?\n* - Forbidden: path separators (/, \\), path traversal (..), leading/trailing whitespace\n*\n* AWS S3 Reference: https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html\n*\n* @param bucketName - The bucket name to validate\n* @returns true if valid, false otherwise\n*/ const isValidBucketName = (bucketName)=>{\n    if (!bucketName || typeof bucketName !== \"string\") return false;\n    if (bucketName.length === 0 || bucketName.length > 100) return false;\n    if (bucketName.trim() !== bucketName) return false;\n    if (bucketName.includes(\"/\") || bucketName.includes(\"\\\\\")) return false;\n    return /^[\\w!.\\*'() &$@=;:+,?-]+$/.test(bucketName);\n};\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/typeof.js\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o$1) {\n        return typeof o$1;\n    } : function(o$1) {\n        return o$1 && \"function\" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? \"symbol\" : typeof o$1;\n    }, _typeof(o);\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/toPrimitive.js\nfunction toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/toPropertyKey.js\nfunction toPropertyKey(t) {\n    var i = toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/defineProperty.js\nfunction _defineProperty(e, r, t) {\n    return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n        value: t,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n    }) : e[r] = t, e;\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/objectSpread2.js\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r$1) {\n            return Object.getOwnPropertyDescriptor(e, r$1).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread2(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r$1) {\n            _defineProperty(e, r$1, t[r$1]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r$1) {\n            Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));\n        });\n    }\n    return e;\n}\n//#endregion\n//#region src/lib/fetch.ts\nconst _getErrorMessage$1 = (err)=>{\n    var _err$error;\n    return err.msg || err.message || err.error_description || (typeof err.error === \"string\" ? err.error : (_err$error = err.error) === null || _err$error === void 0 ? void 0 : _err$error.message) || JSON.stringify(err);\n};\nconst handleError$1 = async (error, reject, options)=>{\n    if (error instanceof await resolveResponse$1() && !(options === null || options === void 0 ? void 0 : options.noResolveJson)) error.json().then((err)=>{\n        const status = error.status || 500;\n        const statusCode = (err === null || err === void 0 ? void 0 : err.statusCode) || status + \"\";\n        reject(new StorageApiError(_getErrorMessage$1(err), status, statusCode));\n    }).catch((err)=>{\n        reject(new StorageUnknownError(_getErrorMessage$1(err), err));\n    });\n    else reject(new StorageUnknownError(_getErrorMessage$1(error), error));\n};\nconst _getRequestParams$1 = (method, options, parameters, body)=>{\n    const params = {\n        method,\n        headers: (options === null || options === void 0 ? void 0 : options.headers) || {}\n    };\n    if (method === \"GET\" || !body) return params;\n    if (isPlainObject$1(body)) {\n        params.headers = _objectSpread2({\n            \"Content-Type\": \"application/json\"\n        }, options === null || options === void 0 ? void 0 : options.headers);\n        params.body = JSON.stringify(body);\n    } else params.body = body;\n    if (options === null || options === void 0 ? void 0 : options.duplex) params.duplex = options.duplex;\n    return _objectSpread2(_objectSpread2({}, params), parameters);\n};\nasync function _handleRequest$1(fetcher, method, url, options, parameters, body) {\n    return new Promise((resolve, reject)=>{\n        fetcher(url, _getRequestParams$1(method, options, parameters, body)).then((result)=>{\n            if (!result.ok) throw result;\n            if (options === null || options === void 0 ? void 0 : options.noResolveJson) return result;\n            return result.json();\n        }).then((data)=>resolve(data)).catch((error)=>handleError$1(error, reject, options));\n    });\n}\nasync function get(fetcher, url, options, parameters) {\n    return _handleRequest$1(fetcher, \"GET\", url, options, parameters);\n}\nasync function post$1(fetcher, url, body, options, parameters) {\n    return _handleRequest$1(fetcher, \"POST\", url, options, parameters, body);\n}\nasync function put(fetcher, url, body, options, parameters) {\n    return _handleRequest$1(fetcher, \"PUT\", url, options, parameters, body);\n}\nasync function head(fetcher, url, options, parameters) {\n    return _handleRequest$1(fetcher, \"HEAD\", url, _objectSpread2(_objectSpread2({}, options), {}, {\n        noResolveJson: true\n    }), parameters);\n}\nasync function remove(fetcher, url, body, options, parameters) {\n    return _handleRequest$1(fetcher, \"DELETE\", url, options, parameters, body);\n}\n//#endregion\n//#region src/packages/StreamDownloadBuilder.ts\nvar StreamDownloadBuilder = class {\n    constructor(downloadFn, shouldThrowOnError){\n        this.downloadFn = downloadFn;\n        this.shouldThrowOnError = shouldThrowOnError;\n    }\n    then(onfulfilled, onrejected) {\n        return this.execute().then(onfulfilled, onrejected);\n    }\n    async execute() {\n        var _this = this;\n        try {\n            return {\n                data: (await _this.downloadFn()).body,\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n};\n//#endregion\n//#region src/packages/BlobDownloadBuilder.ts\nlet _Symbol$toStringTag;\n_Symbol$toStringTag = Symbol.toStringTag;\nvar BlobDownloadBuilder = class {\n    constructor(downloadFn, shouldThrowOnError){\n        this.downloadFn = downloadFn;\n        this.shouldThrowOnError = shouldThrowOnError;\n        this[_Symbol$toStringTag] = \"BlobDownloadBuilder\";\n        this.promise = null;\n    }\n    asStream() {\n        return new StreamDownloadBuilder(this.downloadFn, this.shouldThrowOnError);\n    }\n    then(onfulfilled, onrejected) {\n        return this.getPromise().then(onfulfilled, onrejected);\n    }\n    catch(onrejected) {\n        return this.getPromise().catch(onrejected);\n    }\n    finally(onfinally) {\n        return this.getPromise().finally(onfinally);\n    }\n    getPromise() {\n        if (!this.promise) this.promise = this.execute();\n        return this.promise;\n    }\n    async execute() {\n        var _this = this;\n        try {\n            return {\n                data: await (await _this.downloadFn()).blob(),\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n};\n//#endregion\n//#region src/packages/StorageFileApi.ts\nconst DEFAULT_SEARCH_OPTIONS = {\n    limit: 100,\n    offset: 0,\n    sortBy: {\n        column: \"name\",\n        order: \"asc\"\n    }\n};\nconst DEFAULT_FILE_OPTIONS = {\n    cacheControl: \"3600\",\n    contentType: \"text/plain;charset=UTF-8\",\n    upsert: false\n};\nvar StorageFileApi = class {\n    constructor(url, headers = {}, bucketId, fetch$1){\n        this.shouldThrowOnError = false;\n        this.url = url;\n        this.headers = headers;\n        this.bucketId = bucketId;\n        this.fetch = resolveFetch$1(fetch$1);\n    }\n    /**\n\t* Enable throwing errors instead of returning them.\n\t*\n\t* @category File Buckets\n\t*/ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /**\n\t* Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.\n\t*\n\t* @param method HTTP method.\n\t* @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n\t* @param fileBody The body of the file to be stored in the bucket.\n\t*/ async uploadOrUpdate(method, path, fileBody, fileOptions) {\n        var _this = this;\n        try {\n            let body;\n            const options = _objectSpread2(_objectSpread2({}, DEFAULT_FILE_OPTIONS), fileOptions);\n            let headers = _objectSpread2(_objectSpread2({}, _this.headers), method === \"POST\" && {\n                \"x-upsert\": String(options.upsert)\n            });\n            const metadata = options.metadata;\n            if (typeof Blob !== \"undefined\" && fileBody instanceof Blob) {\n                body = new FormData();\n                body.append(\"cacheControl\", options.cacheControl);\n                if (metadata) body.append(\"metadata\", _this.encodeMetadata(metadata));\n                body.append(\"\", fileBody);\n            } else if (typeof FormData !== \"undefined\" && fileBody instanceof FormData) {\n                body = fileBody;\n                if (!body.has(\"cacheControl\")) body.append(\"cacheControl\", options.cacheControl);\n                if (metadata && !body.has(\"metadata\")) body.append(\"metadata\", _this.encodeMetadata(metadata));\n            } else {\n                body = fileBody;\n                headers[\"cache-control\"] = `max-age=${options.cacheControl}`;\n                headers[\"content-type\"] = options.contentType;\n                if (metadata) headers[\"x-metadata\"] = _this.toBase64(_this.encodeMetadata(metadata));\n                if ((typeof ReadableStream !== \"undefined\" && body instanceof ReadableStream || body && typeof body === \"object\" && \"pipe\" in body && typeof body.pipe === \"function\") && !options.duplex) options.duplex = \"half\";\n            }\n            if (fileOptions === null || fileOptions === void 0 ? void 0 : fileOptions.headers) headers = _objectSpread2(_objectSpread2({}, headers), fileOptions.headers);\n            const cleanPath = _this._removeEmptyFolders(path);\n            const _path = _this._getFinalPath(cleanPath);\n            const data = await (method == \"PUT\" ? put : post$1)(_this.fetch, `${_this.url}/object/${_path}`, body, _objectSpread2({\n                headers\n            }, (options === null || options === void 0 ? void 0 : options.duplex) ? {\n                duplex: options.duplex\n            } : {}));\n            return {\n                data: {\n                    path: cleanPath,\n                    id: data.Id,\n                    fullPath: data.Key\n                },\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Uploads a file to an existing bucket.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n\t* @param fileBody The body of the file to be stored in the bucket.\n\t* @param fileOptions Optional file upload options including cacheControl, contentType, upsert, and metadata.\n\t* @returns Promise with response containing file path, id, and fullPath or error\n\t*\n\t* @example Upload file\n\t* ```js\n\t* const avatarFile = event.target.files[0]\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .upload('public/avatar1.png', avatarFile, {\n\t*     cacheControl: '3600',\n\t*     upsert: false\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"path\": \"public/avatar1.png\",\n\t*     \"fullPath\": \"avatars/public/avatar1.png\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*\n\t* @example Upload file using `ArrayBuffer` from base64 file data\n\t* ```js\n\t* import { decode } from 'base64-arraybuffer'\n\t*\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .upload('public/avatar1.png', decode('base64FileData'), {\n\t*     contentType: 'image/png'\n\t*   })\n\t* ```\n\t*/ async upload(path, fileBody, fileOptions) {\n        return this.uploadOrUpdate(\"POST\", path, fileBody, fileOptions);\n    }\n    /**\n\t* Upload a file with a token generated from `createSignedUploadUrl`.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n\t* @param token The token generated from `createSignedUploadUrl`\n\t* @param fileBody The body of the file to be stored in the bucket.\n\t* @param fileOptions HTTP headers (cacheControl, contentType, etc.).\n\t* **Note:** The `upsert` option has no effect here. To enable upsert behavior,\n\t* pass `{ upsert: true }` when calling `createSignedUploadUrl()` instead.\n\t* @returns Promise with response containing file path and fullPath or error\n\t*\n\t* @example Upload to a signed URL\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .uploadToSignedUrl('folder/cat.jpg', 'token-from-createSignedUploadUrl', file)\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"path\": \"folder/cat.jpg\",\n\t*     \"fullPath\": \"avatars/folder/cat.jpg\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async uploadToSignedUrl(path, token, fileBody, fileOptions) {\n        var _this3 = this;\n        const cleanPath = _this3._removeEmptyFolders(path);\n        const _path = _this3._getFinalPath(cleanPath);\n        const url = new URL(_this3.url + `/object/upload/sign/${_path}`);\n        url.searchParams.set(\"token\", token);\n        try {\n            let body;\n            const options = _objectSpread2({\n                upsert: DEFAULT_FILE_OPTIONS.upsert\n            }, fileOptions);\n            const headers = _objectSpread2(_objectSpread2({}, _this3.headers), {\n                \"x-upsert\": String(options.upsert)\n            });\n            if (typeof Blob !== \"undefined\" && fileBody instanceof Blob) {\n                body = new FormData();\n                body.append(\"cacheControl\", options.cacheControl);\n                body.append(\"\", fileBody);\n            } else if (typeof FormData !== \"undefined\" && fileBody instanceof FormData) {\n                body = fileBody;\n                body.append(\"cacheControl\", options.cacheControl);\n            } else {\n                body = fileBody;\n                headers[\"cache-control\"] = `max-age=${options.cacheControl}`;\n                headers[\"content-type\"] = options.contentType;\n            }\n            return {\n                data: {\n                    path: cleanPath,\n                    fullPath: (await put(_this3.fetch, url.toString(), body, {\n                        headers\n                    })).Key\n                },\n                error: null\n            };\n        } catch (error) {\n            if (_this3.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Creates a signed upload URL.\n\t* Signed upload URLs can be used to upload files to the bucket without further authentication.\n\t* They are valid for 2 hours.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the current file name. For example `folder/image.png`.\n\t* @param options.upsert If set to true, allows the file to be overwritten if it already exists.\n\t* @returns Promise with response containing signed upload URL, token, and path or error\n\t*\n\t* @example Create Signed Upload URL\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .createSignedUploadUrl('folder/cat.jpg')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"signedUrl\": \"https://example.supabase.co/storage/v1/object/upload/sign/avatars/folder/cat.jpg?token=<TOKEN>\",\n\t*     \"path\": \"folder/cat.jpg\",\n\t*     \"token\": \"<TOKEN>\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async createSignedUploadUrl(path, options) {\n        var _this4 = this;\n        try {\n            let _path = _this4._getFinalPath(path);\n            const headers = _objectSpread2({}, _this4.headers);\n            if (options === null || options === void 0 ? void 0 : options.upsert) headers[\"x-upsert\"] = \"true\";\n            const data = await post$1(_this4.fetch, `${_this4.url}/object/upload/sign/${_path}`, {}, {\n                headers\n            });\n            const url = new URL(_this4.url + data.url);\n            const token = url.searchParams.get(\"token\");\n            if (!token) throw new StorageError(\"No token returned by API\");\n            return {\n                data: {\n                    signedUrl: url.toString(),\n                    path,\n                    token\n                },\n                error: null\n            };\n        } catch (error) {\n            if (_this4.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Replaces an existing file at the specified path with a new one.\n\t*\n\t* @category File Buckets\n\t* @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.\n\t* @param fileBody The body of the file to be stored in the bucket.\n\t* @param fileOptions Optional file upload options including cacheControl, contentType, upsert, and metadata.\n\t* @returns Promise with response containing file path, id, and fullPath or error\n\t*\n\t* @example Update file\n\t* ```js\n\t* const avatarFile = event.target.files[0]\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .update('public/avatar1.png', avatarFile, {\n\t*     cacheControl: '3600',\n\t*     upsert: true\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"path\": \"public/avatar1.png\",\n\t*     \"fullPath\": \"avatars/public/avatar1.png\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*\n\t* @example Update file using `ArrayBuffer` from base64 file data\n\t* ```js\n\t* import {decode} from 'base64-arraybuffer'\n\t*\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .update('public/avatar1.png', decode('base64FileData'), {\n\t*     contentType: 'image/png'\n\t*   })\n\t* ```\n\t*/ async update(path, fileBody, fileOptions) {\n        return this.uploadOrUpdate(\"PUT\", path, fileBody, fileOptions);\n    }\n    /**\n\t* Moves an existing file to a new path in the same bucket.\n\t*\n\t* @category File Buckets\n\t* @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n\t* @param toPath The new file path, including the new file name. For example `folder/image-new.png`.\n\t* @param options The destination options.\n\t* @returns Promise with response containing success message or error\n\t*\n\t* @example Move file\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .move('public/avatar1.png', 'private/avatar2.png')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"message\": \"Successfully moved\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async move(fromPath, toPath, options) {\n        var _this6 = this;\n        try {\n            return {\n                data: await post$1(_this6.fetch, `${_this6.url}/object/move`, {\n                    bucketId: _this6.bucketId,\n                    sourceKey: fromPath,\n                    destinationKey: toPath,\n                    destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket\n                }, {\n                    headers: _this6.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this6.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Copies an existing file to a new path in the same bucket.\n\t*\n\t* @category File Buckets\n\t* @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n\t* @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.\n\t* @param options The destination options.\n\t* @returns Promise with response containing copied file path or error\n\t*\n\t* @example Copy file\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .copy('public/avatar1.png', 'private/avatar2.png')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"path\": \"avatars/private/avatar2.png\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async copy(fromPath, toPath, options) {\n        var _this7 = this;\n        try {\n            return {\n                data: {\n                    path: (await post$1(_this7.fetch, `${_this7.url}/object/copy`, {\n                        bucketId: _this7.bucketId,\n                        sourceKey: fromPath,\n                        destinationKey: toPath,\n                        destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket\n                    }, {\n                        headers: _this7.headers\n                    })).Key\n                },\n                error: null\n            };\n        } catch (error) {\n            if (_this7.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the current file name. For example `folder/image.png`.\n\t* @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.\n\t* @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n\t* @param options.transform Transform the asset before serving it to the client.\n\t* @returns Promise with response containing signed URL or error\n\t*\n\t* @example Create Signed URL\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .createSignedUrl('folder/avatar1.png', 60)\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"signedUrl\": \"https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar1.png?token=<TOKEN>\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*\n\t* @example Create a signed URL for an asset with transformations\n\t* ```js\n\t* const { data } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .createSignedUrl('folder/avatar1.png', 60, {\n\t*     transform: {\n\t*       width: 100,\n\t*       height: 100,\n\t*     }\n\t*   })\n\t* ```\n\t*\n\t* @example Create a signed URL which triggers the download of the asset\n\t* ```js\n\t* const { data } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .createSignedUrl('folder/avatar1.png', 60, {\n\t*     download: true,\n\t*   })\n\t* ```\n\t*/ async createSignedUrl(path, expiresIn, options) {\n        var _this8 = this;\n        try {\n            let _path = _this8._getFinalPath(path);\n            let data = await post$1(_this8.fetch, `${_this8.url}/object/sign/${_path}`, _objectSpread2({\n                expiresIn\n            }, (options === null || options === void 0 ? void 0 : options.transform) ? {\n                transform: options.transform\n            } : {}), {\n                headers: _this8.headers\n            });\n            const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? \"\" : options.download}` : \"\";\n            data = {\n                signedUrl: encodeURI(`${_this8.url}${data.signedURL}${downloadQueryParam}`)\n            };\n            return {\n                data,\n                error: null\n            };\n        } catch (error) {\n            if (_this8.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.\n\t*\n\t* @category File Buckets\n\t* @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.\n\t* @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.\n\t* @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n\t* @returns Promise with response containing array of objects with signedUrl, path, and error or error\n\t*\n\t* @example Create Signed URLs\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .createSignedUrls(['folder/avatar1.png', 'folder/avatar2.png'], 60)\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": [\n\t*     {\n\t*       \"error\": null,\n\t*       \"path\": \"folder/avatar1.png\",\n\t*       \"signedURL\": \"/object/sign/avatars/folder/avatar1.png?token=<TOKEN>\",\n\t*       \"signedUrl\": \"https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar1.png?token=<TOKEN>\"\n\t*     },\n\t*     {\n\t*       \"error\": null,\n\t*       \"path\": \"folder/avatar2.png\",\n\t*       \"signedURL\": \"/object/sign/avatars/folder/avatar2.png?token=<TOKEN>\",\n\t*       \"signedUrl\": \"https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar2.png?token=<TOKEN>\"\n\t*     }\n\t*   ],\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async createSignedUrls(paths, expiresIn, options) {\n        var _this9 = this;\n        try {\n            const data = await post$1(_this9.fetch, `${_this9.url}/object/sign/${_this9.bucketId}`, {\n                expiresIn,\n                paths\n            }, {\n                headers: _this9.headers\n            });\n            const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? \"\" : options.download}` : \"\";\n            return {\n                data: data.map((datum)=>_objectSpread2(_objectSpread2({}, datum), {}, {\n                        signedUrl: datum.signedURL ? encodeURI(`${_this9.url}${datum.signedURL}${downloadQueryParam}`) : null\n                    })),\n                error: null\n            };\n        } catch (error) {\n            if (_this9.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Downloads a file from a private bucket. For public buckets, make a request to the URL returned from `getPublicUrl` instead.\n\t*\n\t* @category File Buckets\n\t* @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.\n\t* @param options.transform Transform the asset before serving it to the client.\n\t* @returns BlobDownloadBuilder instance for downloading the file\n\t*\n\t* @example Download file\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .download('folder/avatar1.png')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": <BLOB>,\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*\n\t* @example Download file with transformations\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .download('folder/avatar1.png', {\n\t*     transform: {\n\t*       width: 100,\n\t*       height: 100,\n\t*       quality: 80\n\t*     }\n\t*   })\n\t* ```\n\t*/ download(path, options) {\n        const renderPath = typeof (options === null || options === void 0 ? void 0 : options.transform) !== \"undefined\" ? \"render/image/authenticated\" : \"object\";\n        const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});\n        const queryString = transformationQuery ? `?${transformationQuery}` : \"\";\n        const _path = this._getFinalPath(path);\n        const downloadFn = ()=>get(this.fetch, `${this.url}/${renderPath}/${_path}${queryString}`, {\n                headers: this.headers,\n                noResolveJson: true\n            });\n        return new BlobDownloadBuilder(downloadFn, this.shouldThrowOnError);\n    }\n    /**\n\t* Retrieves the details of an existing file.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the file name. For example `folder/image.png`.\n\t* @returns Promise with response containing file metadata or error\n\t*\n\t* @example Get file info\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .info('folder/avatar1.png')\n\t* ```\n\t*/ async info(path) {\n        var _this10 = this;\n        const _path = _this10._getFinalPath(path);\n        try {\n            return {\n                data: recursiveToCamel(await get(_this10.fetch, `${_this10.url}/object/info/${_path}`, {\n                    headers: _this10.headers\n                })),\n                error: null\n            };\n        } catch (error) {\n            if (_this10.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Checks the existence of a file.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the file name. For example `folder/image.png`.\n\t* @returns Promise with response containing boolean indicating file existence or error\n\t*\n\t* @example Check file existence\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .exists('folder/avatar1.png')\n\t* ```\n\t*/ async exists(path) {\n        var _this11 = this;\n        const _path = _this11._getFinalPath(path);\n        try {\n            await head(_this11.fetch, `${_this11.url}/object/${_path}`, {\n                headers: _this11.headers\n            });\n            return {\n                data: true,\n                error: null\n            };\n        } catch (error) {\n            if (_this11.shouldThrowOnError) throw error;\n            if (isStorageError(error) && error instanceof StorageUnknownError) {\n                const originalError = error.originalError;\n                if ([\n                    400,\n                    404\n                ].includes(originalError === null || originalError === void 0 ? void 0 : originalError.status)) return {\n                    data: false,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n\t* A simple convenience function to get the URL for an asset in a public bucket. If you do not want to use this function, you can construct the public URL by concatenating the bucket URL with the path to the asset.\n\t* This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.\n\t*\n\t* @category File Buckets\n\t* @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.\n\t* @param options.download Triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n\t* @param options.transform Transform the asset before serving it to the client.\n\t* @returns Object with public URL\n\t*\n\t* @example Returns the URL for an asset in a public bucket\n\t* ```js\n\t* const { data } = supabase\n\t*   .storage\n\t*   .from('public-bucket')\n\t*   .getPublicUrl('folder/avatar1.png')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"publicUrl\": \"https://example.supabase.co/storage/v1/object/public/public-bucket/folder/avatar1.png\"\n\t*   }\n\t* }\n\t* ```\n\t*\n\t* @example Returns the URL for an asset in a public bucket with transformations\n\t* ```js\n\t* const { data } = supabase\n\t*   .storage\n\t*   .from('public-bucket')\n\t*   .getPublicUrl('folder/avatar1.png', {\n\t*     transform: {\n\t*       width: 100,\n\t*       height: 100,\n\t*     }\n\t*   })\n\t* ```\n\t*\n\t* @example Returns the URL which triggers the download of an asset in a public bucket\n\t* ```js\n\t* const { data } = supabase\n\t*   .storage\n\t*   .from('public-bucket')\n\t*   .getPublicUrl('folder/avatar1.png', {\n\t*     download: true,\n\t*   })\n\t* ```\n\t*/ getPublicUrl(path, options) {\n        const _path = this._getFinalPath(path);\n        const _queryString = [];\n        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `download=${options.download === true ? \"\" : options.download}` : \"\";\n        if (downloadQueryParam !== \"\") _queryString.push(downloadQueryParam);\n        const renderPath = typeof (options === null || options === void 0 ? void 0 : options.transform) !== \"undefined\" ? \"render/image\" : \"object\";\n        const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});\n        if (transformationQuery !== \"\") _queryString.push(transformationQuery);\n        let queryString = _queryString.join(\"&\");\n        if (queryString !== \"\") queryString = `?${queryString}`;\n        return {\n            data: {\n                publicUrl: encodeURI(`${this.url}/${renderPath}/public/${_path}${queryString}`)\n            }\n        };\n    }\n    /**\n\t* Deletes files within the same bucket\n\t*\n\t* @category File Buckets\n\t* @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].\n\t* @returns Promise with response containing array of deleted file objects or error\n\t*\n\t* @example Delete file\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .remove(['folder/avatar1.png'])\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": [],\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async remove(paths) {\n        var _this12 = this;\n        try {\n            return {\n                data: await remove(_this12.fetch, `${_this12.url}/object/${_this12.bucketId}`, {\n                    prefixes: paths\n                }, {\n                    headers: _this12.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this12.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Get file metadata\n\t* @param id the file id to retrieve metadata\n\t*/ /**\n\t* Update file metadata\n\t* @param id the file id to update metadata\n\t* @param meta the new file metadata\n\t*/ /**\n\t* Lists all the files and folders within a path of the bucket.\n\t*\n\t* @category File Buckets\n\t* @param path The folder path.\n\t* @param options Search options including limit (defaults to 100), offset, sortBy, and search\n\t* @param parameters Optional fetch parameters including signal for cancellation\n\t* @returns Promise with response containing array of files or error\n\t*\n\t* @example List files in a bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .list('folder', {\n\t*     limit: 100,\n\t*     offset: 0,\n\t*     sortBy: { column: 'name', order: 'asc' },\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": [\n\t*     {\n\t*       \"name\": \"avatar1.png\",\n\t*       \"id\": \"e668cf7f-821b-4a2f-9dce-7dfa5dd1cfd2\",\n\t*       \"updated_at\": \"2024-05-22T23:06:05.580Z\",\n\t*       \"created_at\": \"2024-05-22T23:04:34.443Z\",\n\t*       \"last_accessed_at\": \"2024-05-22T23:04:34.443Z\",\n\t*       \"metadata\": {\n\t*         \"eTag\": \"\\\"c5e8c553235d9af30ef4f6e280790b92\\\"\",\n\t*         \"size\": 32175,\n\t*         \"mimetype\": \"image/png\",\n\t*         \"cacheControl\": \"max-age=3600\",\n\t*         \"lastModified\": \"2024-05-22T23:06:05.574Z\",\n\t*         \"contentLength\": 32175,\n\t*         \"httpStatusCode\": 200\n\t*       }\n\t*     }\n\t*   ],\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*\n\t* @example Search files in a bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .list('folder', {\n\t*     limit: 100,\n\t*     offset: 0,\n\t*     sortBy: { column: 'name', order: 'asc' },\n\t*     search: 'jon'\n\t*   })\n\t* ```\n\t*/ async list(path, options, parameters) {\n        var _this13 = this;\n        try {\n            const body = _objectSpread2(_objectSpread2(_objectSpread2({}, DEFAULT_SEARCH_OPTIONS), options), {}, {\n                prefix: path || \"\"\n            });\n            return {\n                data: await post$1(_this13.fetch, `${_this13.url}/object/list/${_this13.bucketId}`, body, {\n                    headers: _this13.headers\n                }, parameters),\n                error: null\n            };\n        } catch (error) {\n            if (_this13.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* @experimental this method signature might change in the future\n\t*\n\t* @category File Buckets\n\t* @param options search options\n\t* @param parameters\n\t*/ async listV2(options, parameters) {\n        var _this14 = this;\n        try {\n            const body = _objectSpread2({}, options);\n            return {\n                data: await post$1(_this14.fetch, `${_this14.url}/object/list-v2/${_this14.bucketId}`, body, {\n                    headers: _this14.headers\n                }, parameters),\n                error: null\n            };\n        } catch (error) {\n            if (_this14.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    encodeMetadata(metadata) {\n        return JSON.stringify(metadata);\n    }\n    toBase64(data) {\n        if (typeof Buffer !== \"undefined\") return Buffer.from(data).toString(\"base64\");\n        return btoa(data);\n    }\n    _getFinalPath(path) {\n        return `${this.bucketId}/${path.replace(/^\\/+/, \"\")}`;\n    }\n    _removeEmptyFolders(path) {\n        return path.replace(/^\\/|\\/$/g, \"\").replace(/\\/+/g, \"/\");\n    }\n    transformOptsToQueryString(transform) {\n        const params = [];\n        if (transform.width) params.push(`width=${transform.width}`);\n        if (transform.height) params.push(`height=${transform.height}`);\n        if (transform.resize) params.push(`resize=${transform.resize}`);\n        if (transform.format) params.push(`format=${transform.format}`);\n        if (transform.quality) params.push(`quality=${transform.quality}`);\n        return params.join(\"&\");\n    }\n};\n//#endregion\n//#region src/lib/version.ts\nconst version = \"2.91.0\";\n//#endregion\n//#region src/lib/constants.ts\nconst DEFAULT_HEADERS$1 = {\n    \"X-Client-Info\": `storage-js/${version}`\n};\n//#endregion\n//#region src/packages/StorageBucketApi.ts\nvar StorageBucketApi = class {\n    constructor(url, headers = {}, fetch$1, opts){\n        this.shouldThrowOnError = false;\n        const baseUrl = new URL(url);\n        if (opts === null || opts === void 0 ? void 0 : opts.useNewHostname) {\n            if (/supabase\\.(co|in|red)$/.test(baseUrl.hostname) && !baseUrl.hostname.includes(\"storage.supabase.\")) baseUrl.hostname = baseUrl.hostname.replace(\"supabase.\", \"storage.supabase.\");\n        }\n        this.url = baseUrl.href.replace(/\\/$/, \"\");\n        this.headers = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS$1), headers);\n        this.fetch = resolveFetch$1(fetch$1);\n    }\n    /**\n\t* Enable throwing errors instead of returning them.\n\t*\n\t* @category File Buckets\n\t*/ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /**\n\t* Retrieves the details of all Storage buckets within an existing project.\n\t*\n\t* @category File Buckets\n\t* @param options Query parameters for listing buckets\n\t* @param options.limit Maximum number of buckets to return\n\t* @param options.offset Number of buckets to skip\n\t* @param options.sortColumn Column to sort by ('id', 'name', 'created_at', 'updated_at')\n\t* @param options.sortOrder Sort order ('asc' or 'desc')\n\t* @param options.search Search term to filter bucket names\n\t* @returns Promise with response containing array of buckets or error\n\t*\n\t* @example List buckets\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .listBuckets()\n\t* ```\n\t*\n\t* @example List buckets with options\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .listBuckets({\n\t*     limit: 10,\n\t*     offset: 0,\n\t*     sortColumn: 'created_at',\n\t*     sortOrder: 'desc',\n\t*     search: 'prod'\n\t*   })\n\t* ```\n\t*/ async listBuckets(options) {\n        var _this = this;\n        try {\n            const queryString = _this.listBucketOptionsToQueryString(options);\n            return {\n                data: await get(_this.fetch, `${_this.url}/bucket${queryString}`, {\n                    headers: _this.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Retrieves the details of an existing Storage bucket.\n\t*\n\t* @category File Buckets\n\t* @param id The unique identifier of the bucket you would like to retrieve.\n\t* @returns Promise with response containing bucket details or error\n\t*\n\t* @example Get bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .getBucket('avatars')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"id\": \"avatars\",\n\t*     \"name\": \"avatars\",\n\t*     \"owner\": \"\",\n\t*     \"public\": false,\n\t*     \"file_size_limit\": 1024,\n\t*     \"allowed_mime_types\": [\n\t*       \"image/png\"\n\t*     ],\n\t*     \"created_at\": \"2024-05-22T22:26:05.100Z\",\n\t*     \"updated_at\": \"2024-05-22T22:26:05.100Z\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async getBucket(id) {\n        var _this2 = this;\n        try {\n            return {\n                data: await get(_this2.fetch, `${_this2.url}/bucket/${id}`, {\n                    headers: _this2.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this2.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Creates a new Storage bucket\n\t*\n\t* @category File Buckets\n\t* @param id A unique identifier for the bucket you are creating.\n\t* @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.\n\t* @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n\t* The global file size limit takes precedence over this value.\n\t* The default value is null, which doesn't set a per bucket file size limit.\n\t* @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n\t* The default value is null, which allows files with all mime types to be uploaded.\n\t* Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n\t* @param options.type (private-beta) specifies the bucket type. see `BucketType` for more details.\n\t*   - default bucket type is `STANDARD`\n\t* @returns Promise with response containing newly created bucket name or error\n\t*\n\t* @example Create bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .createBucket('avatars', {\n\t*     public: false,\n\t*     allowedMimeTypes: ['image/png'],\n\t*     fileSizeLimit: 1024\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"name\": \"avatars\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async createBucket(id, options = {\n        public: false\n    }) {\n        var _this3 = this;\n        try {\n            return {\n                data: await post$1(_this3.fetch, `${_this3.url}/bucket`, {\n                    id,\n                    name: id,\n                    type: options.type,\n                    public: options.public,\n                    file_size_limit: options.fileSizeLimit,\n                    allowed_mime_types: options.allowedMimeTypes\n                }, {\n                    headers: _this3.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this3.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Updates a Storage bucket\n\t*\n\t* @category File Buckets\n\t* @param id A unique identifier for the bucket you are updating.\n\t* @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.\n\t* @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n\t* The global file size limit takes precedence over this value.\n\t* The default value is null, which doesn't set a per bucket file size limit.\n\t* @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n\t* The default value is null, which allows files with all mime types to be uploaded.\n\t* Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n\t* @returns Promise with response containing success message or error\n\t*\n\t* @example Update bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .updateBucket('avatars', {\n\t*     public: false,\n\t*     allowedMimeTypes: ['image/png'],\n\t*     fileSizeLimit: 1024\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"message\": \"Successfully updated\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async updateBucket(id, options) {\n        var _this4 = this;\n        try {\n            return {\n                data: await put(_this4.fetch, `${_this4.url}/bucket/${id}`, {\n                    id,\n                    name: id,\n                    public: options.public,\n                    file_size_limit: options.fileSizeLimit,\n                    allowed_mime_types: options.allowedMimeTypes\n                }, {\n                    headers: _this4.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this4.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Removes all objects inside a single bucket.\n\t*\n\t* @category File Buckets\n\t* @param id The unique identifier of the bucket you would like to empty.\n\t* @returns Promise with success message or error\n\t*\n\t* @example Empty bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .emptyBucket('avatars')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"message\": \"Successfully emptied\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async emptyBucket(id) {\n        var _this5 = this;\n        try {\n            return {\n                data: await post$1(_this5.fetch, `${_this5.url}/bucket/${id}/empty`, {}, {\n                    headers: _this5.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this5.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.\n\t* You must first `empty()` the bucket.\n\t*\n\t* @category File Buckets\n\t* @param id The unique identifier of the bucket you would like to delete.\n\t* @returns Promise with success message or error\n\t*\n\t* @example Delete bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .deleteBucket('avatars')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"message\": \"Successfully deleted\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async deleteBucket(id) {\n        var _this6 = this;\n        try {\n            return {\n                data: await remove(_this6.fetch, `${_this6.url}/bucket/${id}`, {}, {\n                    headers: _this6.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this6.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    listBucketOptionsToQueryString(options) {\n        const params = {};\n        if (options) {\n            if (\"limit\" in options) params.limit = String(options.limit);\n            if (\"offset\" in options) params.offset = String(options.offset);\n            if (options.search) params.search = options.search;\n            if (options.sortColumn) params.sortColumn = options.sortColumn;\n            if (options.sortOrder) params.sortOrder = options.sortOrder;\n        }\n        return Object.keys(params).length > 0 ? \"?\" + new URLSearchParams(params).toString() : \"\";\n    }\n};\n//#endregion\n//#region src/packages/StorageAnalyticsClient.ts\n/**\n* Client class for managing Analytics Buckets using Iceberg tables\n* Provides methods for creating, listing, and deleting analytics buckets\n*/ var StorageAnalyticsClient = class {\n    /**\n\t* @alpha\n\t*\n\t* Creates a new StorageAnalyticsClient instance\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @param url - The base URL for the storage API\n\t* @param headers - HTTP headers to include in requests\n\t* @param fetch - Optional custom fetch implementation\n\t*\n\t* @example\n\t* ```typescript\n\t* const client = new StorageAnalyticsClient(url, headers)\n\t* ```\n\t*/ constructor(url, headers = {}, fetch$1){\n        this.shouldThrowOnError = false;\n        this.url = url.replace(/\\/$/, \"\");\n        this.headers = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS$1), headers);\n        this.fetch = resolveFetch$1(fetch$1);\n    }\n    /**\n\t* @alpha\n\t*\n\t* Enable throwing errors instead of returning them in the response\n\t* When enabled, failed operations will throw instead of returning { data: null, error }\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @returns This instance for method chaining\n\t*/ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /**\n\t* @alpha\n\t*\n\t* Creates a new analytics bucket using Iceberg tables\n\t* Analytics buckets are optimized for analytical queries and data processing\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @param name A unique name for the bucket you are creating\n\t* @returns Promise with response containing newly created analytics bucket or error\n\t*\n\t* @example Create analytics bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .analytics\n\t*   .createBucket('analytics-data')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"name\": \"analytics-data\",\n\t*     \"type\": \"ANALYTICS\",\n\t*     \"format\": \"iceberg\",\n\t*     \"created_at\": \"2024-05-22T22:26:05.100Z\",\n\t*     \"updated_at\": \"2024-05-22T22:26:05.100Z\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async createBucket(name) {\n        var _this = this;\n        try {\n            return {\n                data: await post$1(_this.fetch, `${_this.url}/bucket`, {\n                    name\n                }, {\n                    headers: _this.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* @alpha\n\t*\n\t* Retrieves the details of all Analytics Storage buckets within an existing project\n\t* Only returns buckets of type 'ANALYTICS'\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @param options Query parameters for listing buckets\n\t* @param options.limit Maximum number of buckets to return\n\t* @param options.offset Number of buckets to skip\n\t* @param options.sortColumn Column to sort by ('name', 'created_at', 'updated_at')\n\t* @param options.sortOrder Sort order ('asc' or 'desc')\n\t* @param options.search Search term to filter bucket names\n\t* @returns Promise with response containing array of analytics buckets or error\n\t*\n\t* @example List analytics buckets\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .analytics\n\t*   .listBuckets({\n\t*     limit: 10,\n\t*     offset: 0,\n\t*     sortColumn: 'created_at',\n\t*     sortOrder: 'desc'\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": [\n\t*     {\n\t*       \"name\": \"analytics-data\",\n\t*       \"type\": \"ANALYTICS\",\n\t*       \"format\": \"iceberg\",\n\t*       \"created_at\": \"2024-05-22T22:26:05.100Z\",\n\t*       \"updated_at\": \"2024-05-22T22:26:05.100Z\"\n\t*     }\n\t*   ],\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async listBuckets(options) {\n        var _this2 = this;\n        try {\n            const queryParams = new URLSearchParams();\n            if ((options === null || options === void 0 ? void 0 : options.limit) !== void 0) queryParams.set(\"limit\", options.limit.toString());\n            if ((options === null || options === void 0 ? void 0 : options.offset) !== void 0) queryParams.set(\"offset\", options.offset.toString());\n            if (options === null || options === void 0 ? void 0 : options.sortColumn) queryParams.set(\"sortColumn\", options.sortColumn);\n            if (options === null || options === void 0 ? void 0 : options.sortOrder) queryParams.set(\"sortOrder\", options.sortOrder);\n            if (options === null || options === void 0 ? void 0 : options.search) queryParams.set(\"search\", options.search);\n            const queryString = queryParams.toString();\n            const url = queryString ? `${_this2.url}/bucket?${queryString}` : `${_this2.url}/bucket`;\n            return {\n                data: await get(_this2.fetch, url, {\n                    headers: _this2.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this2.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* @alpha\n\t*\n\t* Deletes an existing analytics bucket\n\t* A bucket can't be deleted with existing objects inside it\n\t* You must first empty the bucket before deletion\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @param bucketName The unique identifier of the bucket you would like to delete\n\t* @returns Promise with response containing success message or error\n\t*\n\t* @example Delete analytics bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .analytics\n\t*   .deleteBucket('analytics-data')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"message\": \"Successfully deleted\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async deleteBucket(bucketName) {\n        var _this3 = this;\n        try {\n            return {\n                data: await remove(_this3.fetch, `${_this3.url}/bucket/${bucketName}`, {}, {\n                    headers: _this3.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this3.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* @alpha\n\t*\n\t* Get an Iceberg REST Catalog client configured for a specific analytics bucket\n\t* Use this to perform advanced table and namespace operations within the bucket\n\t* The returned client provides full access to the Apache Iceberg REST Catalog API\n\t* with the Supabase `{ data, error }` pattern for consistent error handling on all operations.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @param bucketName - The name of the analytics bucket (warehouse) to connect to\n\t* @returns The wrapped Iceberg catalog client\n\t* @throws {StorageError} If the bucket name is invalid\n\t*\n\t* @example Get catalog and create table\n\t* ```js\n\t* // First, create an analytics bucket\n\t* const { data: bucket, error: bucketError } = await supabase\n\t*   .storage\n\t*   .analytics\n\t*   .createBucket('analytics-data')\n\t*\n\t* // Get the Iceberg catalog for that bucket\n\t* const catalog = supabase.storage.analytics.from('analytics-data')\n\t*\n\t* // Create a namespace\n\t* const { error: nsError } = await catalog.createNamespace({ namespace: ['default'] })\n\t*\n\t* // Create a table with schema\n\t* const { data: tableMetadata, error: tableError } = await catalog.createTable(\n\t*   { namespace: ['default'] },\n\t*   {\n\t*     name: 'events',\n\t*     schema: {\n\t*       type: 'struct',\n\t*       fields: [\n\t*         { id: 1, name: 'id', type: 'long', required: true },\n\t*         { id: 2, name: 'timestamp', type: 'timestamp', required: true },\n\t*         { id: 3, name: 'user_id', type: 'string', required: false }\n\t*       ],\n\t*       'schema-id': 0,\n\t*       'identifier-field-ids': [1]\n\t*     },\n\t*     'partition-spec': {\n\t*       'spec-id': 0,\n\t*       fields: []\n\t*     },\n\t*     'write-order': {\n\t*       'order-id': 0,\n\t*       fields: []\n\t*     },\n\t*     properties: {\n\t*       'write.format.default': 'parquet'\n\t*     }\n\t*   }\n\t* )\n\t* ```\n\t*\n\t* @example List tables in namespace\n\t* ```js\n\t* const catalog = supabase.storage.analytics.from('analytics-data')\n\t*\n\t* // List all tables in the default namespace\n\t* const { data: tables, error: listError } = await catalog.listTables({ namespace: ['default'] })\n\t* if (listError) {\n\t*   if (listError.isNotFound()) {\n\t*     console.log('Namespace not found')\n\t*   }\n\t*   return\n\t* }\n\t* console.log(tables) // [{ namespace: ['default'], name: 'events' }]\n\t* ```\n\t*\n\t* @example Working with namespaces\n\t* ```js\n\t* const catalog = supabase.storage.analytics.from('analytics-data')\n\t*\n\t* // List all namespaces\n\t* const { data: namespaces } = await catalog.listNamespaces()\n\t*\n\t* // Create namespace with properties\n\t* await catalog.createNamespace(\n\t*   { namespace: ['production'] },\n\t*   { properties: { owner: 'data-team', env: 'prod' } }\n\t* )\n\t* ```\n\t*\n\t* @example Cleanup operations\n\t* ```js\n\t* const catalog = supabase.storage.analytics.from('analytics-data')\n\t*\n\t* // Drop table with purge option (removes all data)\n\t* const { error: dropError } = await catalog.dropTable(\n\t*   { namespace: ['default'], name: 'events' },\n\t*   { purge: true }\n\t* )\n\t*\n\t* if (dropError?.isNotFound()) {\n\t*   console.log('Table does not exist')\n\t* }\n\t*\n\t* // Drop namespace (must be empty)\n\t* await catalog.dropNamespace({ namespace: ['default'] })\n\t* ```\n\t*\n\t* @remarks\n\t* This method provides a bridge between Supabase's bucket management and the standard\n\t* Apache Iceberg REST Catalog API. The bucket name maps to the Iceberg warehouse parameter.\n\t* All authentication and configuration is handled automatically using your Supabase credentials.\n\t*\n\t* **Error Handling**: Invalid bucket names throw immediately. All catalog\n\t* operations return `{ data, error }` where errors are `IcebergError` instances from iceberg-js.\n\t* Use helper methods like `error.isNotFound()` or check `error.status` for specific error handling.\n\t* Use `.throwOnError()` on the analytics client if you prefer exceptions for catalog operations.\n\t*\n\t* **Cleanup Operations**: When using `dropTable`, the `purge: true` option permanently\n\t* deletes all table data. Without it, the table is marked as deleted but data remains.\n\t*\n\t* **Library Dependency**: The returned catalog wraps `IcebergRestCatalog` from iceberg-js.\n\t* For complete API documentation and advanced usage, refer to the\n\t* [iceberg-js documentation](https://supabase.github.io/iceberg-js/).\n\t*/ from(bucketName) {\n        var _this4 = this;\n        if (!isValidBucketName(bucketName)) throw new StorageError(\"Invalid bucket name: File, folder, and bucket names must follow AWS object key naming guidelines and should avoid the use of any other characters.\");\n        const catalog = new iceberg_js__WEBPACK_IMPORTED_MODULE_0__.IcebergRestCatalog({\n            baseUrl: this.url,\n            catalogName: bucketName,\n            auth: {\n                type: \"custom\",\n                getHeaders: async ()=>_this4.headers\n            },\n            fetch: this.fetch\n        });\n        const shouldThrowOnError = this.shouldThrowOnError;\n        return new Proxy(catalog, {\n            get (target, prop) {\n                const value = target[prop];\n                if (typeof value !== \"function\") return value;\n                return async (...args)=>{\n                    try {\n                        return {\n                            data: await value.apply(target, args),\n                            error: null\n                        };\n                    } catch (error) {\n                        if (shouldThrowOnError) throw error;\n                        return {\n                            data: null,\n                            error\n                        };\n                    }\n                };\n            }\n        });\n    }\n};\n//#endregion\n//#region src/lib/vectors/constants.ts\nconst DEFAULT_HEADERS = {\n    \"X-Client-Info\": `storage-js/${version}`,\n    \"Content-Type\": \"application/json\"\n};\n//#endregion\n//#region src/lib/vectors/errors.ts\n/**\n* Base error class for all Storage Vectors errors\n*/ var StorageVectorsError = class extends Error {\n    constructor(message){\n        super(message);\n        this.__isStorageVectorsError = true;\n        this.name = \"StorageVectorsError\";\n    }\n};\n/**\n* Type guard to check if an error is a StorageVectorsError\n* @param error - The error to check\n* @returns True if the error is a StorageVectorsError\n*/ function isStorageVectorsError(error) {\n    return typeof error === \"object\" && error !== null && \"__isStorageVectorsError\" in error;\n}\n/**\n* API error returned from S3 Vectors service\n* Includes HTTP status code and service-specific error code\n*/ var StorageVectorsApiError = class extends StorageVectorsError {\n    constructor(message, status, statusCode){\n        super(message);\n        this.name = \"StorageVectorsApiError\";\n        this.status = status;\n        this.statusCode = statusCode;\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            status: this.status,\n            statusCode: this.statusCode\n        };\n    }\n};\n/**\n* Unknown error that doesn't match expected error patterns\n* Wraps the original error for debugging\n*/ var StorageVectorsUnknownError = class extends StorageVectorsError {\n    constructor(message, originalError){\n        super(message);\n        this.name = \"StorageVectorsUnknownError\";\n        this.originalError = originalError;\n    }\n};\n/**\n* Error codes specific to S3 Vectors API\n* Maps AWS service errors to application-friendly error codes\n*/ let StorageVectorsErrorCode = /* @__PURE__ */ function(StorageVectorsErrorCode$1) {\n    /** Internal server fault (HTTP 500) */ StorageVectorsErrorCode$1[\"InternalError\"] = \"InternalError\";\n    /** Resource already exists / conflict (HTTP 409) */ StorageVectorsErrorCode$1[\"S3VectorConflictException\"] = \"S3VectorConflictException\";\n    /** Resource not found (HTTP 404) */ StorageVectorsErrorCode$1[\"S3VectorNotFoundException\"] = \"S3VectorNotFoundException\";\n    /** Delete bucket while not empty (HTTP 400) */ StorageVectorsErrorCode$1[\"S3VectorBucketNotEmpty\"] = \"S3VectorBucketNotEmpty\";\n    /** Exceeds bucket quota/limit (HTTP 400) */ StorageVectorsErrorCode$1[\"S3VectorMaxBucketsExceeded\"] = \"S3VectorMaxBucketsExceeded\";\n    /** Exceeds index quota/limit (HTTP 400) */ StorageVectorsErrorCode$1[\"S3VectorMaxIndexesExceeded\"] = \"S3VectorMaxIndexesExceeded\";\n    return StorageVectorsErrorCode$1;\n}({});\n//#endregion\n//#region src/lib/vectors/helpers.ts\n/**\n* Resolves the fetch implementation to use\n* Uses custom fetch if provided, otherwise uses native fetch\n*\n* @param customFetch - Optional custom fetch implementation\n* @returns Resolved fetch function\n*/ const resolveFetch = (customFetch)=>{\n    if (customFetch) return (...args)=>customFetch(...args);\n    return (...args)=>fetch(...args);\n};\n/**\n* Resolves the Response constructor to use\n* Returns native Response constructor\n*\n* @returns Response constructor\n*/ const resolveResponse = ()=>{\n    return Response;\n};\n/**\n* Determine if input is a plain object\n* An object is plain if it's created by either {}, new Object(), or Object.create(null)\n*\n* @param value - Value to check\n* @returns True if value is a plain object\n* @source https://github.com/sindresorhus/is-plain-obj\n*/ const isPlainObject = (value)=>{\n    if (typeof value !== \"object\" || value === null) return false;\n    const prototype = Object.getPrototypeOf(value);\n    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n};\n/**\n* Normalizes a number array to float32 format\n* Ensures all vector values are valid 32-bit floats\n*\n* @param values - Array of numbers to normalize\n* @returns Normalized float32 array\n*/ const normalizeToFloat32 = (values)=>{\n    return Array.from(new Float32Array(values));\n};\n/**\n* Validates vector dimensions match expected dimension\n* Throws error if dimensions don't match\n*\n* @param vector - Vector data to validate\n* @param expectedDimension - Expected vector dimension\n* @throws Error if dimensions don't match\n*/ const validateVectorDimension = (vector, expectedDimension)=>{\n    if (expectedDimension !== void 0 && vector.float32.length !== expectedDimension) throw new Error(`Vector dimension mismatch: expected ${expectedDimension}, got ${vector.float32.length}`);\n};\n//#endregion\n//#region src/lib/vectors/fetch.ts\n/**\n* Extracts error message from various error response formats\n* @param err - Error object from API\n* @returns Human-readable error message\n*/ const _getErrorMessage = (err)=>err.msg || err.message || err.error_description || err.error || JSON.stringify(err);\n/**\n* Handles fetch errors and converts them to StorageVectors error types\n* @param error - The error caught from fetch\n* @param reject - Promise rejection function\n* @param options - Fetch options that may affect error handling\n*/ const handleError = async (error, reject, options)=>{\n    if (error && typeof error === \"object\" && \"status\" in error && \"ok\" in error && typeof error.status === \"number\" && !(options === null || options === void 0 ? void 0 : options.noResolveJson)) {\n        const status = error.status || 500;\n        const responseError = error;\n        if (typeof responseError.json === \"function\") responseError.json().then((err)=>{\n            const statusCode = (err === null || err === void 0 ? void 0 : err.statusCode) || (err === null || err === void 0 ? void 0 : err.code) || status + \"\";\n            reject(new StorageVectorsApiError(_getErrorMessage(err), status, statusCode));\n        }).catch(()=>{\n            const statusCode = status + \"\";\n            reject(new StorageVectorsApiError(responseError.statusText || `HTTP ${status} error`, status, statusCode));\n        });\n        else {\n            const statusCode = status + \"\";\n            reject(new StorageVectorsApiError(responseError.statusText || `HTTP ${status} error`, status, statusCode));\n        }\n    } else reject(new StorageVectorsUnknownError(_getErrorMessage(error), error));\n};\n/**\n* Builds request parameters for fetch calls\n* @param method - HTTP method\n* @param options - Custom fetch options\n* @param parameters - Additional fetch parameters like AbortSignal\n* @param body - Request body (will be JSON stringified if plain object)\n* @returns Complete fetch request parameters\n*/ const _getRequestParams = (method, options, parameters, body)=>{\n    const params = {\n        method,\n        headers: (options === null || options === void 0 ? void 0 : options.headers) || {}\n    };\n    if (method === \"GET\" || !body) return params;\n    if (isPlainObject(body)) {\n        params.headers = _objectSpread2({\n            \"Content-Type\": \"application/json\"\n        }, options === null || options === void 0 ? void 0 : options.headers);\n        params.body = JSON.stringify(body);\n    } else params.body = body;\n    return _objectSpread2(_objectSpread2({}, params), parameters);\n};\n/**\n* Internal request handler that wraps fetch with error handling\n* @param fetcher - Fetch function to use\n* @param method - HTTP method\n* @param url - Request URL\n* @param options - Custom fetch options\n* @param parameters - Additional fetch parameters\n* @param body - Request body\n* @returns Promise with parsed response or error\n*/ async function _handleRequest(fetcher, method, url, options, parameters, body) {\n    return new Promise((resolve, reject)=>{\n        fetcher(url, _getRequestParams(method, options, parameters, body)).then((result)=>{\n            if (!result.ok) throw result;\n            if (options === null || options === void 0 ? void 0 : options.noResolveJson) return result;\n            const contentType = result.headers.get(\"content-type\");\n            if (!contentType || !contentType.includes(\"application/json\")) return {};\n            return result.json();\n        }).then((data)=>resolve(data)).catch((error)=>handleError(error, reject, options));\n    });\n}\n/**\n* Performs a POST request\n* @param fetcher - Fetch function to use\n* @param url - Request URL\n* @param body - Request body to be JSON stringified\n* @param options - Custom fetch options\n* @param parameters - Additional fetch parameters\n* @returns Promise with parsed response\n*/ async function post(fetcher, url, body, options, parameters) {\n    return _handleRequest(fetcher, \"POST\", url, options, parameters, body);\n}\n//#endregion\n//#region src/lib/vectors/VectorIndexApi.ts\n/**\n* @hidden\n* Base implementation for vector index operations.\n* Use {@link VectorBucketScope} via `supabase.storage.vectors.from('bucket')` instead.\n*/ var VectorIndexApi = class {\n    /** Creates a new VectorIndexApi instance */ constructor(url, headers = {}, fetch$1){\n        this.shouldThrowOnError = false;\n        this.url = url.replace(/\\/$/, \"\");\n        this.headers = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS), headers);\n        this.fetch = resolveFetch(fetch$1);\n    }\n    /** Enable throwing errors instead of returning them in the response */ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /** Creates a new vector index within a bucket */ async createIndex(options) {\n        var _this = this;\n        try {\n            return {\n                data: await post(_this.fetch, `${_this.url}/CreateIndex`, options, {\n                    headers: _this.headers\n                }) || {},\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Retrieves metadata for a specific vector index */ async getIndex(vectorBucketName, indexName) {\n        var _this2 = this;\n        try {\n            return {\n                data: await post(_this2.fetch, `${_this2.url}/GetIndex`, {\n                    vectorBucketName,\n                    indexName\n                }, {\n                    headers: _this2.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this2.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Lists vector indexes within a bucket with optional filtering and pagination */ async listIndexes(options) {\n        var _this3 = this;\n        try {\n            return {\n                data: await post(_this3.fetch, `${_this3.url}/ListIndexes`, options, {\n                    headers: _this3.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this3.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Deletes a vector index and all its data */ async deleteIndex(vectorBucketName, indexName) {\n        var _this4 = this;\n        try {\n            return {\n                data: await post(_this4.fetch, `${_this4.url}/DeleteIndex`, {\n                    vectorBucketName,\n                    indexName\n                }, {\n                    headers: _this4.headers\n                }) || {},\n                error: null\n            };\n        } catch (error) {\n            if (_this4.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n};\n//#endregion\n//#region src/lib/vectors/VectorDataApi.ts\n/**\n* @hidden\n* Base implementation for vector data operations.\n* Use {@link VectorIndexScope} via `supabase.storage.vectors.from('bucket').index('idx')` instead.\n*/ var VectorDataApi = class {\n    /** Creates a new VectorDataApi instance */ constructor(url, headers = {}, fetch$1){\n        this.shouldThrowOnError = false;\n        this.url = url.replace(/\\/$/, \"\");\n        this.headers = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS), headers);\n        this.fetch = resolveFetch(fetch$1);\n    }\n    /** Enable throwing errors instead of returning them in the response */ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /** Inserts or updates vectors in batch (1-500 per request) */ async putVectors(options) {\n        var _this = this;\n        try {\n            if (options.vectors.length < 1 || options.vectors.length > 500) throw new Error(\"Vector batch size must be between 1 and 500 items\");\n            return {\n                data: await post(_this.fetch, `${_this.url}/PutVectors`, options, {\n                    headers: _this.headers\n                }) || {},\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Retrieves vectors by their keys in batch */ async getVectors(options) {\n        var _this2 = this;\n        try {\n            return {\n                data: await post(_this2.fetch, `${_this2.url}/GetVectors`, options, {\n                    headers: _this2.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this2.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Lists vectors in an index with pagination */ async listVectors(options) {\n        var _this3 = this;\n        try {\n            if (options.segmentCount !== void 0) {\n                if (options.segmentCount < 1 || options.segmentCount > 16) throw new Error(\"segmentCount must be between 1 and 16\");\n                if (options.segmentIndex !== void 0) {\n                    if (options.segmentIndex < 0 || options.segmentIndex >= options.segmentCount) throw new Error(`segmentIndex must be between 0 and ${options.segmentCount - 1}`);\n                }\n            }\n            return {\n                data: await post(_this3.fetch, `${_this3.url}/ListVectors`, options, {\n                    headers: _this3.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this3.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Queries for similar vectors using approximate nearest neighbor search */ async queryVectors(options) {\n        var _this4 = this;\n        try {\n            return {\n                data: await post(_this4.fetch, `${_this4.url}/QueryVectors`, options, {\n                    headers: _this4.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this4.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Deletes vectors by their keys in batch (1-500 per request) */ async deleteVectors(options) {\n        var _this5 = this;\n        try {\n            if (options.keys.length < 1 || options.keys.length > 500) throw new Error(\"Keys batch size must be between 1 and 500 items\");\n            return {\n                data: await post(_this5.fetch, `${_this5.url}/DeleteVectors`, options, {\n                    headers: _this5.headers\n                }) || {},\n                error: null\n            };\n        } catch (error) {\n            if (_this5.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n};\n//#endregion\n//#region src/lib/vectors/VectorBucketApi.ts\n/**\n* @hidden\n* Base implementation for vector bucket operations.\n* Use {@link StorageVectorsClient} via `supabase.storage.vectors` instead.\n*/ var VectorBucketApi = class {\n    /** Creates a new VectorBucketApi instance */ constructor(url, headers = {}, fetch$1){\n        this.shouldThrowOnError = false;\n        this.url = url.replace(/\\/$/, \"\");\n        this.headers = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS), headers);\n        this.fetch = resolveFetch(fetch$1);\n    }\n    /** Enable throwing errors instead of returning them in the response */ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /** Creates a new vector bucket */ async createBucket(vectorBucketName) {\n        var _this = this;\n        try {\n            return {\n                data: await post(_this.fetch, `${_this.url}/CreateVectorBucket`, {\n                    vectorBucketName\n                }, {\n                    headers: _this.headers\n                }) || {},\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Retrieves metadata for a specific vector bucket */ async getBucket(vectorBucketName) {\n        var _this2 = this;\n        try {\n            return {\n                data: await post(_this2.fetch, `${_this2.url}/GetVectorBucket`, {\n                    vectorBucketName\n                }, {\n                    headers: _this2.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this2.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Lists vector buckets with optional filtering and pagination */ async listBuckets(options = {}) {\n        var _this3 = this;\n        try {\n            return {\n                data: await post(_this3.fetch, `${_this3.url}/ListVectorBuckets`, options, {\n                    headers: _this3.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this3.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Deletes a vector bucket (must be empty first) */ async deleteBucket(vectorBucketName) {\n        var _this4 = this;\n        try {\n            return {\n                data: await post(_this4.fetch, `${_this4.url}/DeleteVectorBucket`, {\n                    vectorBucketName\n                }, {\n                    headers: _this4.headers\n                }) || {},\n                error: null\n            };\n        } catch (error) {\n            if (_this4.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n};\n//#endregion\n//#region src/lib/vectors/StorageVectorsClient.ts\n/**\n*\n* @alpha\n*\n* Main client for interacting with S3 Vectors API\n* Provides access to bucket, index, and vector data operations\n*\n* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n*\n* **Usage Patterns:**\n*\n* ```typescript\n* const { data, error } = await supabase\n*  .storage\n*  .vectors\n*  .createBucket('embeddings-prod')\n*\n* // Access index operations via buckets\n* const bucket = supabase.storage.vectors.from('embeddings-prod')\n* await bucket.createIndex({\n*   indexName: 'documents',\n*   dataType: 'float32',\n*   dimension: 1536,\n*   distanceMetric: 'cosine'\n* })\n*\n* // Access vector operations via index\n* const index = bucket.index('documents')\n* await index.putVectors({\n*   vectors: [\n*     { key: 'doc-1', data: { float32: [...] }, metadata: { title: 'Intro' } }\n*   ]\n* })\n*\n* // Query similar vectors\n* const { data } = await index.queryVectors({\n*   queryVector: { float32: [...] },\n*   topK: 5,\n*   returnDistance: true\n* })\n* ```\n*/ var StorageVectorsClient = class extends VectorBucketApi {\n    /**\n\t* @alpha\n\t*\n\t* Creates a StorageVectorsClient that can manage buckets, indexes, and vectors.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param url - Base URL of the Storage Vectors REST API.\n\t* @param options.headers - Optional headers (for example `Authorization`) applied to every request.\n\t* @param options.fetch - Optional custom `fetch` implementation for non-browser runtimes.\n\t*\n\t* @example\n\t* ```typescript\n\t* const client = new StorageVectorsClient(url, options)\n\t* ```\n\t*/ constructor(url, options = {}){\n        super(url, options.headers || {}, options.fetch);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Access operations for a specific vector bucket\n\t* Returns a scoped client for index and vector operations within the bucket\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param vectorBucketName - Name of the vector bucket\n\t* @returns Bucket-scoped client with index and vector operations\n\t*\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* ```\n\t*/ from(vectorBucketName) {\n        return new VectorBucketScope(this.url, this.headers, vectorBucketName, this.fetch);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Creates a new vector bucket\n\t* Vector buckets are containers for vector indexes and their data\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param vectorBucketName - Unique name for the vector bucket\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .vectors\n\t*   .createBucket('embeddings-prod')\n\t* ```\n\t*/ async createBucket(vectorBucketName) {\n        var _superprop_getCreateBucket = ()=>super.createBucket, _this = this;\n        return _superprop_getCreateBucket().call(_this, vectorBucketName);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Retrieves metadata for a specific vector bucket\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param vectorBucketName - Name of the vector bucket\n\t* @returns Promise with bucket metadata or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .vectors\n\t*   .getBucket('embeddings-prod')\n\t*\n\t* console.log('Bucket created:', data?.vectorBucket.creationTime)\n\t* ```\n\t*/ async getBucket(vectorBucketName) {\n        var _superprop_getGetBucket = ()=>super.getBucket, _this2 = this;\n        return _superprop_getGetBucket().call(_this2, vectorBucketName);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Lists all vector buckets with optional filtering and pagination\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Optional filters (prefix, maxResults, nextToken)\n\t* @returns Promise with list of buckets or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .vectors\n\t*   .listBuckets({ prefix: 'embeddings-' })\n\t*\n\t* data?.vectorBuckets.forEach(bucket => {\n\t*   console.log(bucket.vectorBucketName)\n\t* })\n\t* ```\n\t*/ async listBuckets(options = {}) {\n        var _superprop_getListBuckets = ()=>super.listBuckets, _this3 = this;\n        return _superprop_getListBuckets().call(_this3, options);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Deletes a vector bucket (bucket must be empty)\n\t* All indexes must be deleted before deleting the bucket\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param vectorBucketName - Name of the vector bucket to delete\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .vectors\n\t*   .deleteBucket('embeddings-old')\n\t* ```\n\t*/ async deleteBucket(vectorBucketName) {\n        var _superprop_getDeleteBucket = ()=>super.deleteBucket, _this4 = this;\n        return _superprop_getDeleteBucket().call(_this4, vectorBucketName);\n    }\n};\n/**\n*\n* @alpha\n*\n* Scoped client for operations within a specific vector bucket\n* Provides index management and access to vector operations\n*\n* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n*/ var VectorBucketScope = class extends VectorIndexApi {\n    /**\n\t* @alpha\n\t*\n\t* Creates a helper that automatically scopes all index operations to the provided bucket.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* ```\n\t*/ constructor(url, headers, vectorBucketName, fetch$1){\n        super(url, headers, fetch$1);\n        this.vectorBucketName = vectorBucketName;\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Creates a new vector index in this bucket\n\t* Convenience method that automatically includes the bucket name\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Index configuration (vectorBucketName is automatically set)\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* await bucket.createIndex({\n\t*   indexName: 'documents-openai',\n\t*   dataType: 'float32',\n\t*   dimension: 1536,\n\t*   distanceMetric: 'cosine',\n\t*   metadataConfiguration: {\n\t*     nonFilterableMetadataKeys: ['raw_text']\n\t*   }\n\t* })\n\t* ```\n\t*/ async createIndex(options) {\n        var _superprop_getCreateIndex = ()=>super.createIndex, _this5 = this;\n        return _superprop_getCreateIndex().call(_this5, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this5.vectorBucketName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Lists indexes in this bucket\n\t* Convenience method that automatically includes the bucket name\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Listing options (vectorBucketName is automatically set)\n\t* @returns Promise with response containing indexes array and pagination token or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* const { data } = await bucket.listIndexes({ prefix: 'documents-' })\n\t* ```\n\t*/ async listIndexes(options = {}) {\n        var _superprop_getListIndexes = ()=>super.listIndexes, _this6 = this;\n        return _superprop_getListIndexes().call(_this6, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this6.vectorBucketName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Retrieves metadata for a specific index in this bucket\n\t* Convenience method that automatically includes the bucket name\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param indexName - Name of the index to retrieve\n\t* @returns Promise with index metadata or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* const { data } = await bucket.getIndex('documents-openai')\n\t* console.log('Dimension:', data?.index.dimension)\n\t* ```\n\t*/ async getIndex(indexName) {\n        var _superprop_getGetIndex = ()=>super.getIndex, _this7 = this;\n        return _superprop_getGetIndex().call(_this7, _this7.vectorBucketName, indexName);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Deletes an index from this bucket\n\t* Convenience method that automatically includes the bucket name\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param indexName - Name of the index to delete\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* await bucket.deleteIndex('old-index')\n\t* ```\n\t*/ async deleteIndex(indexName) {\n        var _superprop_getDeleteIndex = ()=>super.deleteIndex, _this8 = this;\n        return _superprop_getDeleteIndex().call(_this8, _this8.vectorBucketName, indexName);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Access operations for a specific index within this bucket\n\t* Returns a scoped client for vector data operations\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param indexName - Name of the index\n\t* @returns Index-scoped client with vector data operations\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t*\n\t* // Insert vectors\n\t* await index.putVectors({\n\t*   vectors: [\n\t*     { key: 'doc-1', data: { float32: [...] }, metadata: { title: 'Intro' } }\n\t*   ]\n\t* })\n\t*\n\t* // Query similar vectors\n\t* const { data } = await index.queryVectors({\n\t*   queryVector: { float32: [...] },\n\t*   topK: 5\n\t* })\n\t* ```\n\t*/ index(indexName) {\n        return new VectorIndexScope(this.url, this.headers, this.vectorBucketName, indexName, this.fetch);\n    }\n};\n/**\n*\n* @alpha\n*\n* Scoped client for operations within a specific vector index\n* Provides vector data operations (put, get, list, query, delete)\n*\n* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n*/ var VectorIndexScope = class extends VectorDataApi {\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Creates a helper that automatically scopes all vector operations to the provided bucket/index names.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* ```\n\t*/ constructor(url, headers, vectorBucketName, indexName, fetch$1){\n        super(url, headers, fetch$1);\n        this.vectorBucketName = vectorBucketName;\n        this.indexName = indexName;\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Inserts or updates vectors in this index\n\t* Convenience method that automatically includes bucket and index names\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Vector insertion options (bucket and index names automatically set)\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* await index.putVectors({\n\t*   vectors: [\n\t*     {\n\t*       key: 'doc-1',\n\t*       data: { float32: [0.1, 0.2, ...] },\n\t*       metadata: { title: 'Introduction', page: 1 }\n\t*     }\n\t*   ]\n\t* })\n\t* ```\n\t*/ async putVectors(options) {\n        var _superprop_getPutVectors = ()=>super.putVectors, _this9 = this;\n        return _superprop_getPutVectors().call(_this9, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this9.vectorBucketName,\n            indexName: _this9.indexName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Retrieves vectors by keys from this index\n\t* Convenience method that automatically includes bucket and index names\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Vector retrieval options (bucket and index names automatically set)\n\t* @returns Promise with response containing vectors array or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* const { data } = await index.getVectors({\n\t*   keys: ['doc-1', 'doc-2'],\n\t*   returnMetadata: true\n\t* })\n\t* ```\n\t*/ async getVectors(options) {\n        var _superprop_getGetVectors = ()=>super.getVectors, _this10 = this;\n        return _superprop_getGetVectors().call(_this10, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this10.vectorBucketName,\n            indexName: _this10.indexName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Lists vectors in this index with pagination\n\t* Convenience method that automatically includes bucket and index names\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Listing options (bucket and index names automatically set)\n\t* @returns Promise with response containing vectors array and pagination token or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* const { data } = await index.listVectors({\n\t*   maxResults: 500,\n\t*   returnMetadata: true\n\t* })\n\t* ```\n\t*/ async listVectors(options = {}) {\n        var _superprop_getListVectors = ()=>super.listVectors, _this11 = this;\n        return _superprop_getListVectors().call(_this11, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this11.vectorBucketName,\n            indexName: _this11.indexName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Queries for similar vectors in this index\n\t* Convenience method that automatically includes bucket and index names\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Query options (bucket and index names automatically set)\n\t* @returns Promise with response containing matches array of similar vectors ordered by distance or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* const { data } = await index.queryVectors({\n\t*   queryVector: { float32: [0.1, 0.2, ...] },\n\t*   topK: 5,\n\t*   filter: { category: 'technical' },\n\t*   returnDistance: true,\n\t*   returnMetadata: true\n\t* })\n\t* ```\n\t*/ async queryVectors(options) {\n        var _superprop_getQueryVectors = ()=>super.queryVectors, _this12 = this;\n        return _superprop_getQueryVectors().call(_this12, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this12.vectorBucketName,\n            indexName: _this12.indexName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Deletes vectors by keys from this index\n\t* Convenience method that automatically includes bucket and index names\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Deletion options (bucket and index names automatically set)\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* await index.deleteVectors({\n\t*   keys: ['doc-1', 'doc-2', 'doc-3']\n\t* })\n\t* ```\n\t*/ async deleteVectors(options) {\n        var _superprop_getDeleteVectors = ()=>super.deleteVectors, _this13 = this;\n        return _superprop_getDeleteVectors().call(_this13, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this13.vectorBucketName,\n            indexName: _this13.indexName\n        }));\n    }\n};\n//#endregion\n//#region src/StorageClient.ts\nvar StorageClient = class extends StorageBucketApi {\n    /**\n\t* Creates a client for Storage buckets, files, analytics, and vectors.\n\t*\n\t* @category File Buckets\n\t* @example\n\t* ```ts\n\t* import { StorageClient } from '@supabase/storage-js'\n\t*\n\t* const storage = new StorageClient('https://xyzcompany.supabase.co/storage/v1', {\n\t*   apikey: 'public-anon-key',\n\t* })\n\t* const avatars = storage.from('avatars')\n\t* ```\n\t*/ constructor(url, headers = {}, fetch$1, opts){\n        super(url, headers, fetch$1, opts);\n    }\n    /**\n\t* Perform file operation in a bucket.\n\t*\n\t* @category File Buckets\n\t* @param id The bucket id to operate on.\n\t*\n\t* @example\n\t* ```typescript\n\t* const avatars = supabase.storage.from('avatars')\n\t* ```\n\t*/ from(id) {\n        return new StorageFileApi(this.url, this.headers, id, this.fetch);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Access vector storage operations.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @returns A StorageVectorsClient instance configured with the current storage settings.\n\t*/ get vectors() {\n        return new StorageVectorsClient(this.url + \"/vector\", {\n            headers: this.headers,\n            fetch: this.fetch\n        });\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Access analytics storage operations using Iceberg tables.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @returns A StorageAnalyticsClient instance configured with the current storage settings.\n\t*/ get analytics() {\n        return new StorageAnalyticsClient(this.url + \"/iceberg\", this.headers, this.fetch);\n    }\n};\n//#endregion\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzdXBhYmFzZStzdG9yYWdlLWpzQDIuOTEuMC9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0Q7QUFFaEQsMkJBQTJCO0FBQzNCLElBQUlDLGVBQWUsY0FBY0M7SUFDaENDLFlBQVlDLE9BQU8sQ0FBRTtRQUNwQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRztRQUN4QixJQUFJLENBQUNDLElBQUksR0FBRztJQUNiO0FBQ0Q7QUFDQSxTQUFTQyxlQUFlQyxLQUFLO0lBQzVCLE9BQU8sT0FBT0EsVUFBVSxZQUFZQSxVQUFVLFFBQVEsc0JBQXNCQTtBQUM3RTtBQUNBLElBQUlDLGtCQUFrQixjQUFjUjtJQUNuQ0UsWUFBWUMsT0FBTyxFQUFFTSxNQUFNLEVBQUVDLFVBQVUsQ0FBRTtRQUN4QyxLQUFLLENBQUNQO1FBQ04sSUFBSSxDQUFDRSxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNJLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNDLFVBQVUsR0FBR0E7SUFDbkI7SUFDQUMsU0FBUztRQUNSLE9BQU87WUFDTk4sTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDZkYsU0FBUyxJQUFJLENBQUNBLE9BQU87WUFDckJNLFFBQVEsSUFBSSxDQUFDQSxNQUFNO1lBQ25CQyxZQUFZLElBQUksQ0FBQ0EsVUFBVTtRQUM1QjtJQUNEO0FBQ0Q7QUFDQSxJQUFJRSxzQkFBc0IsY0FBY1o7SUFDdkNFLFlBQVlDLE9BQU8sRUFBRVUsYUFBYSxDQUFFO1FBQ25DLEtBQUssQ0FBQ1Y7UUFDTixJQUFJLENBQUNFLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ1EsYUFBYSxHQUFHQTtJQUN0QjtBQUNEO0FBRUEsWUFBWTtBQUNaLDRCQUE0QjtBQUM1QixNQUFNQyxpQkFBaUIsQ0FBQ0M7SUFDdkIsSUFBSUEsYUFBYSxPQUFPLENBQUMsR0FBR0MsT0FBU0QsZUFBZUM7SUFDcEQsT0FBTyxDQUFDLEdBQUdBLE9BQVNDLFNBQVNEO0FBQzlCO0FBQ0EsTUFBTUUsb0JBQW9CO0lBQ3pCLE9BQU9DO0FBQ1I7QUFDQSxNQUFNQyxtQkFBbUIsQ0FBQ0M7SUFDekIsSUFBSUMsTUFBTUMsT0FBTyxDQUFDRixPQUFPLE9BQU9BLEtBQUtHLEdBQUcsQ0FBQyxDQUFDQyxLQUFPTCxpQkFBaUJLO1NBQzdELElBQUksT0FBT0osU0FBUyxjQUFjQSxTQUFTSyxPQUFPTCxPQUFPLE9BQU9BO0lBQ3JFLE1BQU1NLFNBQVMsQ0FBQztJQUNoQkQsT0FBT0UsT0FBTyxDQUFDUCxNQUFNUSxPQUFPLENBQUMsQ0FBQyxDQUFDQyxLQUFLQyxNQUFNO1FBQ3pDLE1BQU1DLFNBQVNGLElBQUlHLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQ0MsSUFBTUEsRUFBRUMsV0FBVyxHQUFHRixPQUFPLENBQUMsU0FBUztRQUNwRk4sTUFBTSxDQUFDSyxPQUFPLEdBQUdaLGlCQUFpQlc7SUFDbkM7SUFDQSxPQUFPSjtBQUNSO0FBQ0E7Ozs7QUFJQSxHQUNBLE1BQU1TLGtCQUFrQixDQUFDTDtJQUN4QixJQUFJLE9BQU9BLFVBQVUsWUFBWUEsVUFBVSxNQUFNLE9BQU87SUFDeEQsTUFBTU0sWUFBWVgsT0FBT1ksY0FBYyxDQUFDUDtJQUN4QyxPQUFPLENBQUNNLGNBQWMsUUFBUUEsY0FBY1gsT0FBT1csU0FBUyxJQUFJWCxPQUFPWSxjQUFjLENBQUNELGVBQWUsSUFBRyxLQUFNLENBQUVFLENBQUFBLE9BQU9DLFdBQVcsSUFBSVQsS0FBSSxLQUFNLENBQUVRLENBQUFBLE9BQU9FLFFBQVEsSUFBSVYsS0FBSTtBQUMxSztBQUNBOzs7Ozs7Ozs7Ozs7OztBQWNBLEdBQ0EsTUFBTVcsb0JBQW9CLENBQUNDO0lBQzFCLElBQUksQ0FBQ0EsY0FBYyxPQUFPQSxlQUFlLFVBQVUsT0FBTztJQUMxRCxJQUFJQSxXQUFXQyxNQUFNLEtBQUssS0FBS0QsV0FBV0MsTUFBTSxHQUFHLEtBQUssT0FBTztJQUMvRCxJQUFJRCxXQUFXRSxJQUFJLE9BQU9GLFlBQVksT0FBTztJQUM3QyxJQUFJQSxXQUFXRyxRQUFRLENBQUMsUUFBUUgsV0FBV0csUUFBUSxDQUFDLE9BQU8sT0FBTztJQUNsRSxPQUFPLDRCQUE0QkMsSUFBSSxDQUFDSjtBQUN6QztBQUVBLFlBQVk7QUFDWiwwREFBMEQ7QUFDMUQsU0FBU0ssUUFBUUMsQ0FBQztJQUNqQjtJQUNBLE9BQU9ELFVBQVUsY0FBYyxPQUFPVCxVQUFVLFlBQVksT0FBT0EsT0FBT0UsUUFBUSxHQUFHLFNBQVNTLEdBQUc7UUFDaEcsT0FBTyxPQUFPQTtJQUNmLElBQUksU0FBU0EsR0FBRztRQUNmLE9BQU9BLE9BQU8sY0FBYyxPQUFPWCxVQUFVVyxJQUFJaEQsV0FBVyxLQUFLcUMsVUFBVVcsUUFBUVgsT0FBT0YsU0FBUyxHQUFHLFdBQVcsT0FBT2E7SUFDekgsR0FBR0YsUUFBUUM7QUFDWjtBQUVBLFlBQVk7QUFDWiwrREFBK0Q7QUFDL0QsU0FBU0UsWUFBWUMsQ0FBQyxFQUFFQyxDQUFDO0lBQ3hCLElBQUksWUFBWUwsUUFBUUksTUFBTSxDQUFDQSxHQUFHLE9BQU9BO0lBQ3pDLElBQUlFLElBQUlGLENBQUMsQ0FBQ2IsT0FBT1ksV0FBVyxDQUFDO0lBQzdCLElBQUksS0FBSyxNQUFNRyxHQUFHO1FBQ2pCLElBQUlDLElBQUlELEVBQUVFLElBQUksQ0FBQ0osR0FBR0MsS0FBSztRQUN2QixJQUFJLFlBQVlMLFFBQVFPLElBQUksT0FBT0E7UUFDbkMsTUFBTSxJQUFJRSxVQUFVO0lBQ3JCO0lBQ0EsT0FBTyxDQUFDLGFBQWFKLElBQUlLLFNBQVNDLE1BQUssRUFBR1A7QUFDM0M7QUFFQSxZQUFZO0FBQ1osaUVBQWlFO0FBQ2pFLFNBQVNRLGNBQWNSLENBQUM7SUFDdkIsSUFBSUcsSUFBSUosWUFBWUMsR0FBRztJQUN2QixPQUFPLFlBQVlKLFFBQVFPLEtBQUtBLElBQUlBLElBQUk7QUFDekM7QUFFQSxZQUFZO0FBQ1osa0VBQWtFO0FBQ2xFLFNBQVNNLGdCQUFnQlAsQ0FBQyxFQUFFRCxDQUFDLEVBQUVELENBQUM7SUFDL0IsT0FBTyxDQUFDQyxJQUFJTyxjQUFjUCxFQUFDLEtBQU1DLElBQUk1QixPQUFPb0MsY0FBYyxDQUFDUixHQUFHRCxHQUFHO1FBQ2hFdEIsT0FBT3FCO1FBQ1BXLFlBQVksQ0FBQztRQUNiQyxjQUFjLENBQUM7UUFDZkMsVUFBVSxDQUFDO0lBQ1osS0FBS1gsQ0FBQyxDQUFDRCxFQUFFLEdBQUdELEdBQUdFO0FBQ2hCO0FBRUEsWUFBWTtBQUNaLGlFQUFpRTtBQUNqRSxTQUFTWSxRQUFRWixDQUFDLEVBQUVELENBQUM7SUFDcEIsSUFBSUQsSUFBSTFCLE9BQU95QyxJQUFJLENBQUNiO0lBQ3BCLElBQUk1QixPQUFPMEMscUJBQXFCLEVBQUU7UUFDakMsSUFBSW5CLElBQUl2QixPQUFPMEMscUJBQXFCLENBQUNkO1FBQ3JDRCxLQUFNSixDQUFBQSxJQUFJQSxFQUFFb0IsTUFBTSxDQUFDLFNBQVNDLEdBQUc7WUFDOUIsT0FBTzVDLE9BQU82Qyx3QkFBd0IsQ0FBQ2pCLEdBQUdnQixLQUFLUCxVQUFVO1FBQzFELEVBQUMsR0FBSVgsRUFBRW9CLElBQUksQ0FBQ0MsS0FBSyxDQUFDckIsR0FBR0g7SUFDdEI7SUFDQSxPQUFPRztBQUNSO0FBQ0EsU0FBU3NCLGVBQWVwQixDQUFDO0lBQ3hCLElBQUssSUFBSUQsSUFBSSxHQUFHQSxJQUFJc0IsVUFBVS9CLE1BQU0sRUFBRVMsSUFBSztRQUMxQyxJQUFJRCxJQUFJLFFBQVF1QixTQUFTLENBQUN0QixFQUFFLEdBQUdzQixTQUFTLENBQUN0QixFQUFFLEdBQUcsQ0FBQztRQUMvQ0EsSUFBSSxJQUFJYSxRQUFReEMsT0FBTzBCLElBQUksQ0FBQyxHQUFHdkIsT0FBTyxDQUFDLFNBQVN5QyxHQUFHO1lBQ2xEVCxnQkFBZ0JQLEdBQUdnQixLQUFLbEIsQ0FBQyxDQUFDa0IsSUFBSTtRQUMvQixLQUFLNUMsT0FBT2tELHlCQUF5QixHQUFHbEQsT0FBT21ELGdCQUFnQixDQUFDdkIsR0FBRzVCLE9BQU9rRCx5QkFBeUIsQ0FBQ3hCLE1BQU1jLFFBQVF4QyxPQUFPMEIsSUFBSXZCLE9BQU8sQ0FBQyxTQUFTeUMsR0FBRztZQUNoSjVDLE9BQU9vQyxjQUFjLENBQUNSLEdBQUdnQixLQUFLNUMsT0FBTzZDLHdCQUF3QixDQUFDbkIsR0FBR2tCO1FBQ2xFO0lBQ0Q7SUFDQSxPQUFPaEI7QUFDUjtBQUVBLFlBQVk7QUFDWiwwQkFBMEI7QUFDMUIsTUFBTXdCLHFCQUFxQixDQUFDQztJQUMzQixJQUFJQztJQUNKLE9BQU9ELElBQUlFLEdBQUcsSUFBSUYsSUFBSTVFLE9BQU8sSUFBSTRFLElBQUlHLGlCQUFpQixJQUFLLFFBQU9ILElBQUl4RSxLQUFLLEtBQUssV0FBV3dFLElBQUl4RSxLQUFLLEdBQUcsQ0FBQ3lFLGFBQWFELElBQUl4RSxLQUFLLE1BQU0sUUFBUXlFLGVBQWUsS0FBSyxJQUFJLEtBQUssSUFBSUEsV0FBVzdFLE9BQU8sS0FBS2dGLEtBQUtDLFNBQVMsQ0FBQ0w7QUFDcE47QUFDQSxNQUFNTSxnQkFBZ0IsT0FBTzlFLE9BQU8rRSxRQUFRQztJQUMzQyxJQUFJaEYsaUJBQWlCLE1BQU1XLHVCQUF1QixDQUFFcUUsQ0FBQUEsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVFDLGFBQWEsR0FBR2pGLE1BQU1rRixJQUFJLEdBQUdDLElBQUksQ0FBQyxDQUFDWDtRQUNoSixNQUFNdEUsU0FBU0YsTUFBTUUsTUFBTSxJQUFJO1FBQy9CLE1BQU1DLGFBQWEsQ0FBQ3FFLFFBQVEsUUFBUUEsUUFBUSxLQUFLLElBQUksS0FBSyxJQUFJQSxJQUFJckUsVUFBVSxLQUFLRCxTQUFTO1FBQzFGNkUsT0FBTyxJQUFJOUUsZ0JBQWdCc0UsbUJBQW1CQyxNQUFNdEUsUUFBUUM7SUFDN0QsR0FBR2lGLEtBQUssQ0FBQyxDQUFDWjtRQUNUTyxPQUFPLElBQUkxRSxvQkFBb0JrRSxtQkFBbUJDLE1BQU1BO0lBQ3pEO1NBQ0tPLE9BQU8sSUFBSTFFLG9CQUFvQmtFLG1CQUFtQnZFLFFBQVFBO0FBQ2hFO0FBQ0EsTUFBTXFGLHNCQUFzQixDQUFDQyxRQUFRTixTQUFTTyxZQUFZQztJQUN6RCxNQUFNQyxTQUFTO1FBQ2RIO1FBQ0FJLFNBQVMsQ0FBQ1YsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVFVLE9BQU8sS0FBSyxDQUFDO0lBQ2xGO0lBQ0EsSUFBSUosV0FBVyxTQUFTLENBQUNFLE1BQU0sT0FBT0M7SUFDdEMsSUFBSTVELGdCQUFnQjJELE9BQU87UUFDMUJDLE9BQU9DLE9BQU8sR0FBR3ZCLGVBQWU7WUFBRSxnQkFBZ0I7UUFBbUIsR0FBR2EsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVFVLE9BQU87UUFDeklELE9BQU9ELElBQUksR0FBR1osS0FBS0MsU0FBUyxDQUFDVztJQUM5QixPQUFPQyxPQUFPRCxJQUFJLEdBQUdBO0lBQ3JCLElBQUlSLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRVyxNQUFNLEVBQUVGLE9BQU9FLE1BQU0sR0FBR1gsUUFBUVcsTUFBTTtJQUNwRyxPQUFPeEIsZUFBZUEsZUFBZSxDQUFDLEdBQUdzQixTQUFTRjtBQUNuRDtBQUNBLGVBQWVLLGlCQUFpQkMsT0FBTyxFQUFFUCxNQUFNLEVBQUVRLEdBQUcsRUFBRWQsT0FBTyxFQUFFTyxVQUFVLEVBQUVDLElBQUk7SUFDOUUsT0FBTyxJQUFJTyxRQUFRLENBQUNDLFNBQVNqQjtRQUM1QmMsUUFBUUMsS0FBS1Qsb0JBQW9CQyxRQUFRTixTQUFTTyxZQUFZQyxPQUFPTCxJQUFJLENBQUMsQ0FBQy9EO1lBQzFFLElBQUksQ0FBQ0EsT0FBTzZFLEVBQUUsRUFBRSxNQUFNN0U7WUFDdEIsSUFBSTRELFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRQyxhQUFhLEVBQUUsT0FBTzdEO1lBQ3BGLE9BQU9BLE9BQU84RCxJQUFJO1FBQ25CLEdBQUdDLElBQUksQ0FBQyxDQUFDZSxPQUFTRixRQUFRRSxPQUFPZCxLQUFLLENBQUMsQ0FBQ3BGLFFBQVU4RSxjQUFjOUUsT0FBTytFLFFBQVFDO0lBQ2hGO0FBQ0Q7QUFDQSxlQUFlbUIsSUFBSU4sT0FBTyxFQUFFQyxHQUFHLEVBQUVkLE9BQU8sRUFBRU8sVUFBVTtJQUNuRCxPQUFPSyxpQkFBaUJDLFNBQVMsT0FBT0MsS0FBS2QsU0FBU087QUFDdkQ7QUFDQSxlQUFlYSxPQUFPUCxPQUFPLEVBQUVDLEdBQUcsRUFBRU4sSUFBSSxFQUFFUixPQUFPLEVBQUVPLFVBQVU7SUFDNUQsT0FBT0ssaUJBQWlCQyxTQUFTLFFBQVFDLEtBQUtkLFNBQVNPLFlBQVlDO0FBQ3BFO0FBQ0EsZUFBZWEsSUFBSVIsT0FBTyxFQUFFQyxHQUFHLEVBQUVOLElBQUksRUFBRVIsT0FBTyxFQUFFTyxVQUFVO0lBQ3pELE9BQU9LLGlCQUFpQkMsU0FBUyxPQUFPQyxLQUFLZCxTQUFTTyxZQUFZQztBQUNuRTtBQUNBLGVBQWVjLEtBQUtULE9BQU8sRUFBRUMsR0FBRyxFQUFFZCxPQUFPLEVBQUVPLFVBQVU7SUFDcEQsT0FBT0ssaUJBQWlCQyxTQUFTLFFBQVFDLEtBQUszQixlQUFlQSxlQUFlLENBQUMsR0FBR2EsVUFBVSxDQUFDLEdBQUc7UUFBRUMsZUFBZTtJQUFLLElBQUlNO0FBQ3pIO0FBQ0EsZUFBZWdCLE9BQU9WLE9BQU8sRUFBRUMsR0FBRyxFQUFFTixJQUFJLEVBQUVSLE9BQU8sRUFBRU8sVUFBVTtJQUM1RCxPQUFPSyxpQkFBaUJDLFNBQVMsVUFBVUMsS0FBS2QsU0FBU08sWUFBWUM7QUFDdEU7QUFFQSxZQUFZO0FBQ1osK0NBQStDO0FBQy9DLElBQUlnQix3QkFBd0I7SUFDM0I3RyxZQUFZOEcsVUFBVSxFQUFFQyxrQkFBa0IsQ0FBRTtRQUMzQyxJQUFJLENBQUNELFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDQyxrQkFBa0IsR0FBR0E7SUFDM0I7SUFDQXZCLEtBQUt3QixXQUFXLEVBQUVDLFVBQVUsRUFBRTtRQUM3QixPQUFPLElBQUksQ0FBQ0MsT0FBTyxHQUFHMUIsSUFBSSxDQUFDd0IsYUFBYUM7SUFDekM7SUFDQSxNQUFNQyxVQUFVO1FBQ2YsSUFBSUMsUUFBUSxJQUFJO1FBQ2hCLElBQUk7WUFDSCxPQUFPO2dCQUNOWixNQUFNLENBQUMsTUFBTVksTUFBTUwsVUFBVSxFQUFDLEVBQUdqQixJQUFJO2dCQUNyQ3hGLE9BQU87WUFDUjtRQUNELEVBQUUsT0FBT0EsT0FBTztZQUNmLElBQUk4RyxNQUFNSixrQkFBa0IsRUFBRSxNQUFNMUc7WUFDcEMsSUFBSUQsZUFBZUMsUUFBUSxPQUFPO2dCQUNqQ2tHLE1BQU07Z0JBQ05sRztZQUNEO1lBQ0EsTUFBTUE7UUFDUDtJQUNEO0FBQ0Q7QUFFQSxZQUFZO0FBQ1osNkNBQTZDO0FBQzdDLElBQUkrRztBQUNKQSxzQkFBc0IvRSxPQUFPQyxXQUFXO0FBQ3hDLElBQUkrRSxzQkFBc0I7SUFDekJySCxZQUFZOEcsVUFBVSxFQUFFQyxrQkFBa0IsQ0FBRTtRQUMzQyxJQUFJLENBQUNELFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDQyxrQkFBa0IsR0FBR0E7UUFDMUIsSUFBSSxDQUFDSyxvQkFBb0IsR0FBRztRQUM1QixJQUFJLENBQUNFLE9BQU8sR0FBRztJQUNoQjtJQUNBQyxXQUFXO1FBQ1YsT0FBTyxJQUFJVixzQkFBc0IsSUFBSSxDQUFDQyxVQUFVLEVBQUUsSUFBSSxDQUFDQyxrQkFBa0I7SUFDMUU7SUFDQXZCLEtBQUt3QixXQUFXLEVBQUVDLFVBQVUsRUFBRTtRQUM3QixPQUFPLElBQUksQ0FBQ08sVUFBVSxHQUFHaEMsSUFBSSxDQUFDd0IsYUFBYUM7SUFDNUM7SUFDQXhCLE1BQU13QixVQUFVLEVBQUU7UUFDakIsT0FBTyxJQUFJLENBQUNPLFVBQVUsR0FBRy9CLEtBQUssQ0FBQ3dCO0lBQ2hDO0lBQ0FRLFFBQVFDLFNBQVMsRUFBRTtRQUNsQixPQUFPLElBQUksQ0FBQ0YsVUFBVSxHQUFHQyxPQUFPLENBQUNDO0lBQ2xDO0lBQ0FGLGFBQWE7UUFDWixJQUFJLENBQUMsSUFBSSxDQUFDRixPQUFPLEVBQUUsSUFBSSxDQUFDQSxPQUFPLEdBQUcsSUFBSSxDQUFDSixPQUFPO1FBQzlDLE9BQU8sSUFBSSxDQUFDSSxPQUFPO0lBQ3BCO0lBQ0EsTUFBTUosVUFBVTtRQUNmLElBQUlDLFFBQVEsSUFBSTtRQUNoQixJQUFJO1lBQ0gsT0FBTztnQkFDTlosTUFBTSxNQUFNLENBQUMsTUFBTVksTUFBTUwsVUFBVSxFQUFDLEVBQUdhLElBQUk7Z0JBQzNDdEgsT0FBTztZQUNSO1FBQ0QsRUFBRSxPQUFPQSxPQUFPO1lBQ2YsSUFBSThHLE1BQU1KLGtCQUFrQixFQUFFLE1BQU0xRztZQUNwQyxJQUFJRCxlQUFlQyxRQUFRLE9BQU87Z0JBQ2pDa0csTUFBTTtnQkFDTmxHO1lBQ0Q7WUFDQSxNQUFNQTtRQUNQO0lBQ0Q7QUFDRDtBQUVBLFlBQVk7QUFDWix3Q0FBd0M7QUFDeEMsTUFBTXVILHlCQUF5QjtJQUM5QkMsT0FBTztJQUNQQyxRQUFRO0lBQ1JDLFFBQVE7UUFDUEMsUUFBUTtRQUNSQyxPQUFPO0lBQ1I7QUFDRDtBQUNBLE1BQU1DLHVCQUF1QjtJQUM1QkMsY0FBYztJQUNkQyxhQUFhO0lBQ2JDLFFBQVE7QUFDVDtBQUNBLElBQUlDLGlCQUFpQjtJQUNwQnRJLFlBQVltRyxHQUFHLEVBQUVKLFVBQVUsQ0FBQyxDQUFDLEVBQUV3QyxRQUFRLEVBQUVDLE9BQU8sQ0FBRTtRQUNqRCxJQUFJLENBQUN6QixrQkFBa0IsR0FBRztRQUMxQixJQUFJLENBQUNaLEdBQUcsR0FBR0E7UUFDWCxJQUFJLENBQUNKLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUN3QyxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ3hILEtBQUssR0FBR0gsZUFBZTRIO0lBQzdCO0lBQ0E7Ozs7Q0FJQSxHQUNBQyxlQUFlO1FBQ2QsSUFBSSxDQUFDMUIsa0JBQWtCLEdBQUc7UUFDMUIsT0FBTyxJQUFJO0lBQ1o7SUFDQTs7Ozs7O0NBTUEsR0FDQSxNQUFNMkIsZUFBZS9DLE1BQU0sRUFBRWdELElBQUksRUFBRUMsUUFBUSxFQUFFQyxXQUFXLEVBQUU7UUFDekQsSUFBSTFCLFFBQVEsSUFBSTtRQUNoQixJQUFJO1lBQ0gsSUFBSXRCO1lBQ0osTUFBTVIsVUFBVWIsZUFBZUEsZUFBZSxDQUFDLEdBQUcwRCx1QkFBdUJXO1lBQ3pFLElBQUk5QyxVQUFVdkIsZUFBZUEsZUFBZSxDQUFDLEdBQUcyQyxNQUFNcEIsT0FBTyxHQUFHSixXQUFXLFVBQVU7Z0JBQUUsWUFBWW5DLE9BQU82QixRQUFRZ0QsTUFBTTtZQUFFO1lBQzFILE1BQU1TLFdBQVd6RCxRQUFReUQsUUFBUTtZQUNqQyxJQUFJLE9BQU9DLFNBQVMsZUFBZUgsb0JBQW9CRyxNQUFNO2dCQUM1RGxELE9BQU8sSUFBSW1EO2dCQUNYbkQsS0FBS29ELE1BQU0sQ0FBQyxnQkFBZ0I1RCxRQUFROEMsWUFBWTtnQkFDaEQsSUFBSVcsVUFBVWpELEtBQUtvRCxNQUFNLENBQUMsWUFBWTlCLE1BQU0rQixjQUFjLENBQUNKO2dCQUMzRGpELEtBQUtvRCxNQUFNLENBQUMsSUFBSUw7WUFDakIsT0FBTyxJQUFJLE9BQU9JLGFBQWEsZUFBZUosb0JBQW9CSSxVQUFVO2dCQUMzRW5ELE9BQU8rQztnQkFDUCxJQUFJLENBQUMvQyxLQUFLc0QsR0FBRyxDQUFDLGlCQUFpQnRELEtBQUtvRCxNQUFNLENBQUMsZ0JBQWdCNUQsUUFBUThDLFlBQVk7Z0JBQy9FLElBQUlXLFlBQVksQ0FBQ2pELEtBQUtzRCxHQUFHLENBQUMsYUFBYXRELEtBQUtvRCxNQUFNLENBQUMsWUFBWTlCLE1BQU0rQixjQUFjLENBQUNKO1lBQ3JGLE9BQU87Z0JBQ05qRCxPQUFPK0M7Z0JBQ1A3QyxPQUFPLENBQUMsZ0JBQWdCLEdBQUcsQ0FBQyxRQUFRLEVBQUVWLFFBQVE4QyxZQUFZLENBQUMsQ0FBQztnQkFDNURwQyxPQUFPLENBQUMsZUFBZSxHQUFHVixRQUFRK0MsV0FBVztnQkFDN0MsSUFBSVUsVUFBVS9DLE9BQU8sQ0FBQyxhQUFhLEdBQUdvQixNQUFNaUMsUUFBUSxDQUFDakMsTUFBTStCLGNBQWMsQ0FBQ0o7Z0JBQzFFLElBQUksQ0FBQyxPQUFPTyxtQkFBbUIsZUFBZXhELGdCQUFnQndELGtCQUFrQnhELFFBQVEsT0FBT0EsU0FBUyxZQUFZLFVBQVVBLFFBQVEsT0FBT0EsS0FBS3lELElBQUksS0FBSyxVQUFTLEtBQU0sQ0FBQ2pFLFFBQVFXLE1BQU0sRUFBRVgsUUFBUVcsTUFBTSxHQUFHO1lBQzdNO1lBQ0EsSUFBSTZDLGdCQUFnQixRQUFRQSxnQkFBZ0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsWUFBWTlDLE9BQU8sRUFBRUEsVUFBVXZCLGVBQWVBLGVBQWUsQ0FBQyxHQUFHdUIsVUFBVThDLFlBQVk5QyxPQUFPO1lBQzVKLE1BQU13RCxZQUFZcEMsTUFBTXFDLG1CQUFtQixDQUFDYjtZQUM1QyxNQUFNYyxRQUFRdEMsTUFBTXVDLGFBQWEsQ0FBQ0g7WUFDbEMsTUFBTWhELE9BQU8sTUFBTSxDQUFDWixVQUFVLFFBQVFlLE1BQU1ELE1BQUssRUFBR1UsTUFBTXBHLEtBQUssRUFBRSxDQUFDLEVBQUVvRyxNQUFNaEIsR0FBRyxDQUFDLFFBQVEsRUFBRXNELE1BQU0sQ0FBQyxFQUFFNUQsTUFBTXJCLGVBQWU7Z0JBQUV1QjtZQUFRLEdBQUcsQ0FBQ1YsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVFXLE1BQU0sSUFBSTtnQkFBRUEsUUFBUVgsUUFBUVcsTUFBTTtZQUFDLElBQUksQ0FBQztZQUN0TyxPQUFPO2dCQUNOTyxNQUFNO29CQUNMb0MsTUFBTVk7b0JBQ05JLElBQUlwRCxLQUFLcUQsRUFBRTtvQkFDWEMsVUFBVXRELEtBQUt1RCxHQUFHO2dCQUNuQjtnQkFDQXpKLE9BQU87WUFDUjtRQUNELEVBQUUsT0FBT0EsT0FBTztZQUNmLElBQUk4RyxNQUFNSixrQkFBa0IsRUFBRSxNQUFNMUc7WUFDcEMsSUFBSUQsZUFBZUMsUUFBUSxPQUFPO2dCQUNqQ2tHLE1BQU07Z0JBQ05sRztZQUNEO1lBQ0EsTUFBTUE7UUFDUDtJQUNEO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0EyQ0EsR0FDQSxNQUFNMEosT0FBT3BCLElBQUksRUFBRUMsUUFBUSxFQUFFQyxXQUFXLEVBQUU7UUFDekMsT0FBTyxJQUFJLENBQUNILGNBQWMsQ0FBQyxRQUFRQyxNQUFNQyxVQUFVQztJQUNwRDtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E4QkEsR0FDQSxNQUFNbUIsa0JBQWtCckIsSUFBSSxFQUFFc0IsS0FBSyxFQUFFckIsUUFBUSxFQUFFQyxXQUFXLEVBQUU7UUFDM0QsSUFBSXFCLFNBQVMsSUFBSTtRQUNqQixNQUFNWCxZQUFZVyxPQUFPVixtQkFBbUIsQ0FBQ2I7UUFDN0MsTUFBTWMsUUFBUVMsT0FBT1IsYUFBYSxDQUFDSDtRQUNuQyxNQUFNcEQsTUFBTSxJQUFJZ0UsSUFBSUQsT0FBTy9ELEdBQUcsR0FBRyxDQUFDLG9CQUFvQixFQUFFc0QsTUFBTSxDQUFDO1FBQy9EdEQsSUFBSWlFLFlBQVksQ0FBQ0MsR0FBRyxDQUFDLFNBQVNKO1FBQzlCLElBQUk7WUFDSCxJQUFJcEU7WUFDSixNQUFNUixVQUFVYixlQUFlO2dCQUFFNkQsUUFBUUgscUJBQXFCRyxNQUFNO1lBQUMsR0FBR1E7WUFDeEUsTUFBTTlDLFVBQVV2QixlQUFlQSxlQUFlLENBQUMsR0FBRzBGLE9BQU9uRSxPQUFPLEdBQUc7Z0JBQUUsWUFBWXZDLE9BQU82QixRQUFRZ0QsTUFBTTtZQUFFO1lBQ3hHLElBQUksT0FBT1UsU0FBUyxlQUFlSCxvQkFBb0JHLE1BQU07Z0JBQzVEbEQsT0FBTyxJQUFJbUQ7Z0JBQ1huRCxLQUFLb0QsTUFBTSxDQUFDLGdCQUFnQjVELFFBQVE4QyxZQUFZO2dCQUNoRHRDLEtBQUtvRCxNQUFNLENBQUMsSUFBSUw7WUFDakIsT0FBTyxJQUFJLE9BQU9JLGFBQWEsZUFBZUosb0JBQW9CSSxVQUFVO2dCQUMzRW5ELE9BQU8rQztnQkFDUC9DLEtBQUtvRCxNQUFNLENBQUMsZ0JBQWdCNUQsUUFBUThDLFlBQVk7WUFDakQsT0FBTztnQkFDTnRDLE9BQU8rQztnQkFDUDdDLE9BQU8sQ0FBQyxnQkFBZ0IsR0FBRyxDQUFDLFFBQVEsRUFBRVYsUUFBUThDLFlBQVksQ0FBQyxDQUFDO2dCQUM1RHBDLE9BQU8sQ0FBQyxlQUFlLEdBQUdWLFFBQVErQyxXQUFXO1lBQzlDO1lBQ0EsT0FBTztnQkFDTjdCLE1BQU07b0JBQ0xvQyxNQUFNWTtvQkFDTk0sVUFBVSxDQUFDLE1BQU1uRCxJQUFJd0QsT0FBT25KLEtBQUssRUFBRW9GLElBQUltRSxRQUFRLElBQUl6RSxNQUFNO3dCQUFFRTtvQkFBUSxFQUFDLEVBQUcrRCxHQUFHO2dCQUMzRTtnQkFDQXpKLE9BQU87WUFDUjtRQUNELEVBQUUsT0FBT0EsT0FBTztZQUNmLElBQUk2SixPQUFPbkQsa0JBQWtCLEVBQUUsTUFBTTFHO1lBQ3JDLElBQUlELGVBQWVDLFFBQVEsT0FBTztnQkFDakNrRyxNQUFNO2dCQUNObEc7WUFDRDtZQUNBLE1BQU1BO1FBQ1A7SUFDRDtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTZCQSxHQUNBLE1BQU1rSyxzQkFBc0I1QixJQUFJLEVBQUV0RCxPQUFPLEVBQUU7UUFDMUMsSUFBSW1GLFNBQVMsSUFBSTtRQUNqQixJQUFJO1lBQ0gsSUFBSWYsUUFBUWUsT0FBT2QsYUFBYSxDQUFDZjtZQUNqQyxNQUFNNUMsVUFBVXZCLGVBQWUsQ0FBQyxHQUFHZ0csT0FBT3pFLE9BQU87WUFDakQsSUFBSVYsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVFnRCxNQUFNLEVBQUV0QyxPQUFPLENBQUMsV0FBVyxHQUFHO1lBQzVGLE1BQU1RLE9BQU8sTUFBTUUsT0FBTytELE9BQU96SixLQUFLLEVBQUUsQ0FBQyxFQUFFeUosT0FBT3JFLEdBQUcsQ0FBQyxvQkFBb0IsRUFBRXNELE1BQU0sQ0FBQyxFQUFFLENBQUMsR0FBRztnQkFBRTFEO1lBQVE7WUFDbkcsTUFBTUksTUFBTSxJQUFJZ0UsSUFBSUssT0FBT3JFLEdBQUcsR0FBR0ksS0FBS0osR0FBRztZQUN6QyxNQUFNOEQsUUFBUTlELElBQUlpRSxZQUFZLENBQUM1RCxHQUFHLENBQUM7WUFDbkMsSUFBSSxDQUFDeUQsT0FBTyxNQUFNLElBQUluSyxhQUFhO1lBQ25DLE9BQU87Z0JBQ055RyxNQUFNO29CQUNMa0UsV0FBV3RFLElBQUltRSxRQUFRO29CQUN2QjNCO29CQUNBc0I7Z0JBQ0Q7Z0JBQ0E1SixPQUFPO1lBQ1I7UUFDRCxFQUFFLE9BQU9BLE9BQU87WUFDZixJQUFJbUssT0FBT3pELGtCQUFrQixFQUFFLE1BQU0xRztZQUNyQyxJQUFJRCxlQUFlQyxRQUFRLE9BQU87Z0JBQ2pDa0csTUFBTTtnQkFDTmxHO1lBQ0Q7WUFDQSxNQUFNQTtRQUNQO0lBQ0Q7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTJDQSxHQUNBLE1BQU1xSyxPQUFPL0IsSUFBSSxFQUFFQyxRQUFRLEVBQUVDLFdBQVcsRUFBRTtRQUN6QyxPQUFPLElBQUksQ0FBQ0gsY0FBYyxDQUFDLE9BQU9DLE1BQU1DLFVBQVVDO0lBQ25EO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBMEJBLEdBQ0EsTUFBTThCLEtBQUtDLFFBQVEsRUFBRUMsTUFBTSxFQUFFeEYsT0FBTyxFQUFFO1FBQ3JDLElBQUl5RixTQUFTLElBQUk7UUFDakIsSUFBSTtZQUNILE9BQU87Z0JBQ052RSxNQUFNLE1BQU1FLE9BQU9xRSxPQUFPL0osS0FBSyxFQUFFLENBQUMsRUFBRStKLE9BQU8zRSxHQUFHLENBQUMsWUFBWSxDQUFDLEVBQUU7b0JBQzdEb0MsVUFBVXVDLE9BQU92QyxRQUFRO29CQUN6QndDLFdBQVdIO29CQUNYSSxnQkFBZ0JIO29CQUNoQkksbUJBQW1CNUYsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVE0RixpQkFBaUI7Z0JBQy9GLEdBQUc7b0JBQUVsRixTQUFTK0UsT0FBTy9FLE9BQU87Z0JBQUM7Z0JBQzdCMUYsT0FBTztZQUNSO1FBQ0QsRUFBRSxPQUFPQSxPQUFPO1lBQ2YsSUFBSXlLLE9BQU8vRCxrQkFBa0IsRUFBRSxNQUFNMUc7WUFDckMsSUFBSUQsZUFBZUMsUUFBUSxPQUFPO2dCQUNqQ2tHLE1BQU07Z0JBQ05sRztZQUNEO1lBQ0EsTUFBTUE7UUFDUDtJQUNEO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBMEJBLEdBQ0EsTUFBTTZLLEtBQUtOLFFBQVEsRUFBRUMsTUFBTSxFQUFFeEYsT0FBTyxFQUFFO1FBQ3JDLElBQUk4RixTQUFTLElBQUk7UUFDakIsSUFBSTtZQUNILE9BQU87Z0JBQ041RSxNQUFNO29CQUFFb0MsTUFBTSxDQUFDLE1BQU1sQyxPQUFPMEUsT0FBT3BLLEtBQUssRUFBRSxDQUFDLEVBQUVvSyxPQUFPaEYsR0FBRyxDQUFDLFlBQVksQ0FBQyxFQUFFO3dCQUN0RW9DLFVBQVU0QyxPQUFPNUMsUUFBUTt3QkFDekJ3QyxXQUFXSDt3QkFDWEksZ0JBQWdCSDt3QkFDaEJJLG1CQUFtQjVGLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRNEYsaUJBQWlCO29CQUMvRixHQUFHO3dCQUFFbEYsU0FBU29GLE9BQU9wRixPQUFPO29CQUFDLEVBQUMsRUFBRytELEdBQUc7Z0JBQUM7Z0JBQ3JDekosT0FBTztZQUNSO1FBQ0QsRUFBRSxPQUFPQSxPQUFPO1lBQ2YsSUFBSThLLE9BQU9wRSxrQkFBa0IsRUFBRSxNQUFNMUc7WUFDckMsSUFBSUQsZUFBZUMsUUFBUSxPQUFPO2dCQUNqQ2tHLE1BQU07Z0JBQ05sRztZQUNEO1lBQ0EsTUFBTUE7UUFDUDtJQUNEO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBa0RBLEdBQ0EsTUFBTStLLGdCQUFnQnpDLElBQUksRUFBRTBDLFNBQVMsRUFBRWhHLE9BQU8sRUFBRTtRQUMvQyxJQUFJaUcsU0FBUyxJQUFJO1FBQ2pCLElBQUk7WUFDSCxJQUFJN0IsUUFBUTZCLE9BQU81QixhQUFhLENBQUNmO1lBQ2pDLElBQUlwQyxPQUFPLE1BQU1FLE9BQU82RSxPQUFPdkssS0FBSyxFQUFFLENBQUMsRUFBRXVLLE9BQU9uRixHQUFHLENBQUMsYUFBYSxFQUFFc0QsTUFBTSxDQUFDLEVBQUVqRixlQUFlO2dCQUFFNkc7WUFBVSxHQUFHLENBQUNoRyxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUWtHLFNBQVMsSUFBSTtnQkFBRUEsV0FBV2xHLFFBQVFrRyxTQUFTO1lBQUMsSUFBSSxDQUFDLElBQUk7Z0JBQUV4RixTQUFTdUYsT0FBT3ZGLE9BQU87WUFBQztZQUNwUCxNQUFNeUYscUJBQXFCLENBQUNuRyxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUW9HLFFBQVEsSUFBSSxDQUFDLFVBQVUsRUFBRXBHLFFBQVFvRyxRQUFRLEtBQUssT0FBTyxLQUFLcEcsUUFBUW9HLFFBQVEsQ0FBQyxDQUFDLEdBQUc7WUFDcktsRixPQUFPO2dCQUFFa0UsV0FBV2lCLFVBQVUsQ0FBQyxFQUFFSixPQUFPbkYsR0FBRyxDQUFDLEVBQUVJLEtBQUtvRixTQUFTLENBQUMsRUFBRUgsbUJBQW1CLENBQUM7WUFBRTtZQUNyRixPQUFPO2dCQUNOakY7Z0JBQ0FsRyxPQUFPO1lBQ1I7UUFDRCxFQUFFLE9BQU9BLE9BQU87WUFDZixJQUFJaUwsT0FBT3ZFLGtCQUFrQixFQUFFLE1BQU0xRztZQUNyQyxJQUFJRCxlQUFlQyxRQUFRLE9BQU87Z0JBQ2pDa0csTUFBTTtnQkFDTmxHO1lBQ0Q7WUFDQSxNQUFNQTtRQUNQO0lBQ0Q7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXFDQSxHQUNBLE1BQU11TCxpQkFBaUJDLEtBQUssRUFBRVIsU0FBUyxFQUFFaEcsT0FBTyxFQUFFO1FBQ2pELElBQUl5RyxTQUFTLElBQUk7UUFDakIsSUFBSTtZQUNILE1BQU12RixPQUFPLE1BQU1FLE9BQU9xRixPQUFPL0ssS0FBSyxFQUFFLENBQUMsRUFBRStLLE9BQU8zRixHQUFHLENBQUMsYUFBYSxFQUFFMkYsT0FBT3ZELFFBQVEsQ0FBQyxDQUFDLEVBQUU7Z0JBQ3ZGOEM7Z0JBQ0FRO1lBQ0QsR0FBRztnQkFBRTlGLFNBQVMrRixPQUFPL0YsT0FBTztZQUFDO1lBQzdCLE1BQU15RixxQkFBcUIsQ0FBQ25HLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRb0csUUFBUSxJQUFJLENBQUMsVUFBVSxFQUFFcEcsUUFBUW9HLFFBQVEsS0FBSyxPQUFPLEtBQUtwRyxRQUFRb0csUUFBUSxDQUFDLENBQUMsR0FBRztZQUNySyxPQUFPO2dCQUNObEYsTUFBTUEsS0FBS2pGLEdBQUcsQ0FBQyxDQUFDeUssUUFBVXZILGVBQWVBLGVBQWUsQ0FBQyxHQUFHdUgsUUFBUSxDQUFDLEdBQUc7d0JBQUV0QixXQUFXc0IsTUFBTUosU0FBUyxHQUFHRCxVQUFVLENBQUMsRUFBRUksT0FBTzNGLEdBQUcsQ0FBQyxFQUFFNEYsTUFBTUosU0FBUyxDQUFDLEVBQUVILG1CQUFtQixDQUFDLElBQUk7b0JBQUs7Z0JBQ2hMbkwsT0FBTztZQUNSO1FBQ0QsRUFBRSxPQUFPQSxPQUFPO1lBQ2YsSUFBSXlMLE9BQU8vRSxrQkFBa0IsRUFBRSxNQUFNMUc7WUFDckMsSUFBSUQsZUFBZUMsUUFBUSxPQUFPO2dCQUNqQ2tHLE1BQU07Z0JBQ05sRztZQUNEO1lBQ0EsTUFBTUE7UUFDUDtJQUNEO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FxQ0EsR0FDQW9MLFNBQVM5QyxJQUFJLEVBQUV0RCxPQUFPLEVBQUU7UUFDdkIsTUFBTTJHLGFBQWEsT0FBUTNHLENBQUFBLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRa0csU0FBUyxNQUFNLGNBQWMsK0JBQStCO1FBQ2pKLE1BQU1VLHNCQUFzQixJQUFJLENBQUNDLDBCQUEwQixDQUFDLENBQUM3RyxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUWtHLFNBQVMsS0FBSyxDQUFDO1FBQ3RJLE1BQU1ZLGNBQWNGLHNCQUFzQixDQUFDLENBQUMsRUFBRUEsb0JBQW9CLENBQUMsR0FBRztRQUN0RSxNQUFNeEMsUUFBUSxJQUFJLENBQUNDLGFBQWEsQ0FBQ2Y7UUFDakMsTUFBTTdCLGFBQWEsSUFBTU4sSUFBSSxJQUFJLENBQUN6RixLQUFLLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQ29GLEdBQUcsQ0FBQyxDQUFDLEVBQUU2RixXQUFXLENBQUMsRUFBRXZDLE1BQU0sRUFBRTBDLFlBQVksQ0FBQyxFQUFFO2dCQUM1RnBHLFNBQVMsSUFBSSxDQUFDQSxPQUFPO2dCQUNyQlQsZUFBZTtZQUNoQjtRQUNBLE9BQU8sSUFBSStCLG9CQUFvQlAsWUFBWSxJQUFJLENBQUNDLGtCQUFrQjtJQUNuRTtJQUNBOzs7Ozs7Ozs7Ozs7OztDQWNBLEdBQ0EsTUFBTXFGLEtBQUt6RCxJQUFJLEVBQUU7UUFDaEIsSUFBSTBELFVBQVUsSUFBSTtRQUNsQixNQUFNNUMsUUFBUTRDLFFBQVEzQyxhQUFhLENBQUNmO1FBQ3BDLElBQUk7WUFDSCxPQUFPO2dCQUNOcEMsTUFBTXJGLGlCQUFpQixNQUFNc0YsSUFBSTZGLFFBQVF0TCxLQUFLLEVBQUUsQ0FBQyxFQUFFc0wsUUFBUWxHLEdBQUcsQ0FBQyxhQUFhLEVBQUVzRCxNQUFNLENBQUMsRUFBRTtvQkFBRTFELFNBQVNzRyxRQUFRdEcsT0FBTztnQkFBQztnQkFDbEgxRixPQUFPO1lBQ1I7UUFDRCxFQUFFLE9BQU9BLE9BQU87WUFDZixJQUFJZ00sUUFBUXRGLGtCQUFrQixFQUFFLE1BQU0xRztZQUN0QyxJQUFJRCxlQUFlQyxRQUFRLE9BQU87Z0JBQ2pDa0csTUFBTTtnQkFDTmxHO1lBQ0Q7WUFDQSxNQUFNQTtRQUNQO0lBQ0Q7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Q0FjQSxHQUNBLE1BQU1pTSxPQUFPM0QsSUFBSSxFQUFFO1FBQ2xCLElBQUk0RCxVQUFVLElBQUk7UUFDbEIsTUFBTTlDLFFBQVE4QyxRQUFRN0MsYUFBYSxDQUFDZjtRQUNwQyxJQUFJO1lBQ0gsTUFBTWhDLEtBQUs0RixRQUFReEwsS0FBSyxFQUFFLENBQUMsRUFBRXdMLFFBQVFwRyxHQUFHLENBQUMsUUFBUSxFQUFFc0QsTUFBTSxDQUFDLEVBQUU7Z0JBQUUxRCxTQUFTd0csUUFBUXhHLE9BQU87WUFBQztZQUN2RixPQUFPO2dCQUNOUSxNQUFNO2dCQUNObEcsT0FBTztZQUNSO1FBQ0QsRUFBRSxPQUFPQSxPQUFPO1lBQ2YsSUFBSWtNLFFBQVF4RixrQkFBa0IsRUFBRSxNQUFNMUc7WUFDdEMsSUFBSUQsZUFBZUMsVUFBVUEsaUJBQWlCSyxxQkFBcUI7Z0JBQ2xFLE1BQU1DLGdCQUFnQk4sTUFBTU0sYUFBYTtnQkFDekMsSUFBSTtvQkFBQztvQkFBSztpQkFBSSxDQUFDaUMsUUFBUSxDQUFDakMsa0JBQWtCLFFBQVFBLGtCQUFrQixLQUFLLElBQUksS0FBSyxJQUFJQSxjQUFjSixNQUFNLEdBQUcsT0FBTztvQkFDbkhnRyxNQUFNO29CQUNObEc7Z0JBQ0Q7WUFDRDtZQUNBLE1BQU1BO1FBQ1A7SUFDRDtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaURBLEdBQ0FtTSxhQUFhN0QsSUFBSSxFQUFFdEQsT0FBTyxFQUFFO1FBQzNCLE1BQU1vRSxRQUFRLElBQUksQ0FBQ0MsYUFBYSxDQUFDZjtRQUNqQyxNQUFNOEQsZUFBZSxFQUFFO1FBQ3ZCLE1BQU1qQixxQkFBcUIsQ0FBQ25HLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRb0csUUFBUSxJQUFJLENBQUMsU0FBUyxFQUFFcEcsUUFBUW9HLFFBQVEsS0FBSyxPQUFPLEtBQUtwRyxRQUFRb0csUUFBUSxDQUFDLENBQUMsR0FBRztRQUNwSyxJQUFJRCx1QkFBdUIsSUFBSWlCLGFBQWFuSSxJQUFJLENBQUNrSDtRQUNqRCxNQUFNUSxhQUFhLE9BQVEzRyxDQUFBQSxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUWtHLFNBQVMsTUFBTSxjQUFjLGlCQUFpQjtRQUNuSSxNQUFNVSxzQkFBc0IsSUFBSSxDQUFDQywwQkFBMEIsQ0FBQyxDQUFDN0csWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVFrRyxTQUFTLEtBQUssQ0FBQztRQUN0SSxJQUFJVSx3QkFBd0IsSUFBSVEsYUFBYW5JLElBQUksQ0FBQzJIO1FBQ2xELElBQUlFLGNBQWNNLGFBQWFDLElBQUksQ0FBQztRQUNwQyxJQUFJUCxnQkFBZ0IsSUFBSUEsY0FBYyxDQUFDLENBQUMsRUFBRUEsWUFBWSxDQUFDO1FBQ3ZELE9BQU87WUFBRTVGLE1BQU07Z0JBQUVvRyxXQUFXakIsVUFBVSxDQUFDLEVBQUUsSUFBSSxDQUFDdkYsR0FBRyxDQUFDLENBQUMsRUFBRTZGLFdBQVcsUUFBUSxFQUFFdkMsTUFBTSxFQUFFMEMsWUFBWSxDQUFDO1lBQUU7UUFBRTtJQUNwRztJQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBc0JBLEdBQ0EsTUFBTXZGLE9BQU9pRixLQUFLLEVBQUU7UUFDbkIsSUFBSWUsVUFBVSxJQUFJO1FBQ2xCLElBQUk7WUFDSCxPQUFPO2dCQUNOckcsTUFBTSxNQUFNSyxPQUFPZ0csUUFBUTdMLEtBQUssRUFBRSxDQUFDLEVBQUU2TCxRQUFRekcsR0FBRyxDQUFDLFFBQVEsRUFBRXlHLFFBQVFyRSxRQUFRLENBQUMsQ0FBQyxFQUFFO29CQUFFc0UsVUFBVWhCO2dCQUFNLEdBQUc7b0JBQUU5RixTQUFTNkcsUUFBUTdHLE9BQU87Z0JBQUM7Z0JBQy9IMUYsT0FBTztZQUNSO1FBQ0QsRUFBRSxPQUFPQSxPQUFPO1lBQ2YsSUFBSXVNLFFBQVE3RixrQkFBa0IsRUFBRSxNQUFNMUc7WUFDdEMsSUFBSUQsZUFBZUMsUUFBUSxPQUFPO2dCQUNqQ2tHLE1BQU07Z0JBQ05sRztZQUNEO1lBQ0EsTUFBTUE7UUFDUDtJQUNEO0lBQ0E7OztDQUdBLEdBQ0E7Ozs7Q0FJQSxHQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBMERBLEdBQ0EsTUFBTXlNLEtBQUtuRSxJQUFJLEVBQUV0RCxPQUFPLEVBQUVPLFVBQVUsRUFBRTtRQUNyQyxJQUFJbUgsVUFBVSxJQUFJO1FBQ2xCLElBQUk7WUFDSCxNQUFNbEgsT0FBT3JCLGVBQWVBLGVBQWVBLGVBQWUsQ0FBQyxHQUFHb0QseUJBQXlCdkMsVUFBVSxDQUFDLEdBQUc7Z0JBQUUySCxRQUFRckUsUUFBUTtZQUFHO1lBQzFILE9BQU87Z0JBQ05wQyxNQUFNLE1BQU1FLE9BQU9zRyxRQUFRaE0sS0FBSyxFQUFFLENBQUMsRUFBRWdNLFFBQVE1RyxHQUFHLENBQUMsYUFBYSxFQUFFNEcsUUFBUXhFLFFBQVEsQ0FBQyxDQUFDLEVBQUUxQyxNQUFNO29CQUFFRSxTQUFTZ0gsUUFBUWhILE9BQU87Z0JBQUMsR0FBR0g7Z0JBQ3hIdkYsT0FBTztZQUNSO1FBQ0QsRUFBRSxPQUFPQSxPQUFPO1lBQ2YsSUFBSTBNLFFBQVFoRyxrQkFBa0IsRUFBRSxNQUFNMUc7WUFDdEMsSUFBSUQsZUFBZUMsUUFBUSxPQUFPO2dCQUNqQ2tHLE1BQU07Z0JBQ05sRztZQUNEO1lBQ0EsTUFBTUE7UUFDUDtJQUNEO0lBQ0E7Ozs7OztDQU1BLEdBQ0EsTUFBTTRNLE9BQU81SCxPQUFPLEVBQUVPLFVBQVUsRUFBRTtRQUNqQyxJQUFJc0gsVUFBVSxJQUFJO1FBQ2xCLElBQUk7WUFDSCxNQUFNckgsT0FBT3JCLGVBQWUsQ0FBQyxHQUFHYTtZQUNoQyxPQUFPO2dCQUNOa0IsTUFBTSxNQUFNRSxPQUFPeUcsUUFBUW5NLEtBQUssRUFBRSxDQUFDLEVBQUVtTSxRQUFRL0csR0FBRyxDQUFDLGdCQUFnQixFQUFFK0csUUFBUTNFLFFBQVEsQ0FBQyxDQUFDLEVBQUUxQyxNQUFNO29CQUFFRSxTQUFTbUgsUUFBUW5ILE9BQU87Z0JBQUMsR0FBR0g7Z0JBQzNIdkYsT0FBTztZQUNSO1FBQ0QsRUFBRSxPQUFPQSxPQUFPO1lBQ2YsSUFBSTZNLFFBQVFuRyxrQkFBa0IsRUFBRSxNQUFNMUc7WUFDdEMsSUFBSUQsZUFBZUMsUUFBUSxPQUFPO2dCQUNqQ2tHLE1BQU07Z0JBQ05sRztZQUNEO1lBQ0EsTUFBTUE7UUFDUDtJQUNEO0lBQ0E2SSxlQUFlSixRQUFRLEVBQUU7UUFDeEIsT0FBTzdELEtBQUtDLFNBQVMsQ0FBQzREO0lBQ3ZCO0lBQ0FNLFNBQVM3QyxJQUFJLEVBQUU7UUFDZCxJQUFJLE9BQU80RyxXQUFXLGFBQWEsT0FBT0EsT0FBT0MsSUFBSSxDQUFDN0csTUFBTStELFFBQVEsQ0FBQztRQUNyRSxPQUFPK0MsS0FBSzlHO0lBQ2I7SUFDQW1ELGNBQWNmLElBQUksRUFBRTtRQUNuQixPQUFPLENBQUMsRUFBRSxJQUFJLENBQUNKLFFBQVEsQ0FBQyxDQUFDLEVBQUVJLEtBQUs1RyxPQUFPLENBQUMsUUFBUSxJQUFJLENBQUM7SUFDdEQ7SUFDQXlILG9CQUFvQmIsSUFBSSxFQUFFO1FBQ3pCLE9BQU9BLEtBQUs1RyxPQUFPLENBQUMsWUFBWSxJQUFJQSxPQUFPLENBQUMsUUFBUTtJQUNyRDtJQUNBbUssMkJBQTJCWCxTQUFTLEVBQUU7UUFDckMsTUFBTXpGLFNBQVMsRUFBRTtRQUNqQixJQUFJeUYsVUFBVStCLEtBQUssRUFBRXhILE9BQU94QixJQUFJLENBQUMsQ0FBQyxNQUFNLEVBQUVpSCxVQUFVK0IsS0FBSyxDQUFDLENBQUM7UUFDM0QsSUFBSS9CLFVBQVVnQyxNQUFNLEVBQUV6SCxPQUFPeEIsSUFBSSxDQUFDLENBQUMsT0FBTyxFQUFFaUgsVUFBVWdDLE1BQU0sQ0FBQyxDQUFDO1FBQzlELElBQUloQyxVQUFVaUMsTUFBTSxFQUFFMUgsT0FBT3hCLElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRWlILFVBQVVpQyxNQUFNLENBQUMsQ0FBQztRQUM5RCxJQUFJakMsVUFBVWtDLE1BQU0sRUFBRTNILE9BQU94QixJQUFJLENBQUMsQ0FBQyxPQUFPLEVBQUVpSCxVQUFVa0MsTUFBTSxDQUFDLENBQUM7UUFDOUQsSUFBSWxDLFVBQVVtQyxPQUFPLEVBQUU1SCxPQUFPeEIsSUFBSSxDQUFDLENBQUMsUUFBUSxFQUFFaUgsVUFBVW1DLE9BQU8sQ0FBQyxDQUFDO1FBQ2pFLE9BQU81SCxPQUFPNEcsSUFBSSxDQUFDO0lBQ3BCO0FBQ0Q7QUFFQSxZQUFZO0FBQ1osNEJBQTRCO0FBQzVCLE1BQU1pQixVQUFVO0FBRWhCLFlBQVk7QUFDWiw4QkFBOEI7QUFDOUIsTUFBTUMsb0JBQW9CO0lBQUUsaUJBQWlCLENBQUMsV0FBVyxFQUFFRCxRQUFRLENBQUM7QUFBQztBQUVyRSxZQUFZO0FBQ1osMENBQTBDO0FBQzFDLElBQUlFLG1CQUFtQjtJQUN0QjdOLFlBQVltRyxHQUFHLEVBQUVKLFVBQVUsQ0FBQyxDQUFDLEVBQUV5QyxPQUFPLEVBQUVzRixJQUFJLENBQUU7UUFDN0MsSUFBSSxDQUFDL0csa0JBQWtCLEdBQUc7UUFDMUIsTUFBTWdILFVBQVUsSUFBSTVELElBQUloRTtRQUN4QixJQUFJMkgsU0FBUyxRQUFRQSxTQUFTLEtBQUssSUFBSSxLQUFLLElBQUlBLEtBQUtFLGNBQWMsRUFBRTtZQUNwRSxJQUFJLHlCQUF5Qm5MLElBQUksQ0FBQ2tMLFFBQVFFLFFBQVEsS0FBSyxDQUFDRixRQUFRRSxRQUFRLENBQUNyTCxRQUFRLENBQUMsc0JBQXNCbUwsUUFBUUUsUUFBUSxHQUFHRixRQUFRRSxRQUFRLENBQUNsTSxPQUFPLENBQUMsYUFBYTtRQUNsSztRQUNBLElBQUksQ0FBQ29FLEdBQUcsR0FBRzRILFFBQVFHLElBQUksQ0FBQ25NLE9BQU8sQ0FBQyxPQUFPO1FBQ3ZDLElBQUksQ0FBQ2dFLE9BQU8sR0FBR3ZCLGVBQWVBLGVBQWUsQ0FBQyxHQUFHb0osb0JBQW9CN0g7UUFDckUsSUFBSSxDQUFDaEYsS0FBSyxHQUFHSCxlQUFlNEg7SUFDN0I7SUFDQTs7OztDQUlBLEdBQ0FDLGVBQWU7UUFDZCxJQUFJLENBQUMxQixrQkFBa0IsR0FBRztRQUMxQixPQUFPLElBQUk7SUFDWjtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBK0JBLEdBQ0EsTUFBTW9ILFlBQVk5SSxPQUFPLEVBQUU7UUFDMUIsSUFBSThCLFFBQVEsSUFBSTtRQUNoQixJQUFJO1lBQ0gsTUFBTWdGLGNBQWNoRixNQUFNaUgsOEJBQThCLENBQUMvSTtZQUN6RCxPQUFPO2dCQUNOa0IsTUFBTSxNQUFNQyxJQUFJVyxNQUFNcEcsS0FBSyxFQUFFLENBQUMsRUFBRW9HLE1BQU1oQixHQUFHLENBQUMsT0FBTyxFQUFFZ0csWUFBWSxDQUFDLEVBQUU7b0JBQUVwRyxTQUFTb0IsTUFBTXBCLE9BQU87Z0JBQUM7Z0JBQzNGMUYsT0FBTztZQUNSO1FBQ0QsRUFBRSxPQUFPQSxPQUFPO1lBQ2YsSUFBSThHLE1BQU1KLGtCQUFrQixFQUFFLE1BQU0xRztZQUNwQyxJQUFJRCxlQUFlQyxRQUFRLE9BQU87Z0JBQ2pDa0csTUFBTTtnQkFDTmxHO1lBQ0Q7WUFDQSxNQUFNQTtRQUNQO0lBQ0Q7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQ0EsR0FDQSxNQUFNZ08sVUFBVTFFLEVBQUUsRUFBRTtRQUNuQixJQUFJMkUsU0FBUyxJQUFJO1FBQ2pCLElBQUk7WUFDSCxPQUFPO2dCQUNOL0gsTUFBTSxNQUFNQyxJQUFJOEgsT0FBT3ZOLEtBQUssRUFBRSxDQUFDLEVBQUV1TixPQUFPbkksR0FBRyxDQUFDLFFBQVEsRUFBRXdELEdBQUcsQ0FBQyxFQUFFO29CQUFFNUQsU0FBU3VJLE9BQU92SSxPQUFPO2dCQUFDO2dCQUN0RjFGLE9BQU87WUFDUjtRQUNELEVBQUUsT0FBT0EsT0FBTztZQUNmLElBQUlpTyxPQUFPdkgsa0JBQWtCLEVBQUUsTUFBTTFHO1lBQ3JDLElBQUlELGVBQWVDLFFBQVEsT0FBTztnQkFDakNrRyxNQUFNO2dCQUNObEc7WUFDRDtZQUNBLE1BQU1BO1FBQ1A7SUFDRDtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FvQ0EsR0FDQSxNQUFNa08sYUFBYTVFLEVBQUUsRUFBRXRFLFVBQVU7UUFBRW1KLFFBQVE7SUFBTSxDQUFDLEVBQUU7UUFDbkQsSUFBSXRFLFNBQVMsSUFBSTtRQUNqQixJQUFJO1lBQ0gsT0FBTztnQkFDTjNELE1BQU0sTUFBTUUsT0FBT3lELE9BQU9uSixLQUFLLEVBQUUsQ0FBQyxFQUFFbUosT0FBTy9ELEdBQUcsQ0FBQyxPQUFPLENBQUMsRUFBRTtvQkFDeER3RDtvQkFDQXhKLE1BQU13SjtvQkFDTjhFLE1BQU1wSixRQUFRb0osSUFBSTtvQkFDbEJELFFBQVFuSixRQUFRbUosTUFBTTtvQkFDdEJFLGlCQUFpQnJKLFFBQVFzSixhQUFhO29CQUN0Q0Msb0JBQW9CdkosUUFBUXdKLGdCQUFnQjtnQkFDN0MsR0FBRztvQkFBRTlJLFNBQVNtRSxPQUFPbkUsT0FBTztnQkFBQztnQkFDN0IxRixPQUFPO1lBQ1I7UUFDRCxFQUFFLE9BQU9BLE9BQU87WUFDZixJQUFJNkosT0FBT25ELGtCQUFrQixFQUFFLE1BQU0xRztZQUNyQyxJQUFJRCxlQUFlQyxRQUFRLE9BQU87Z0JBQ2pDa0csTUFBTTtnQkFDTmxHO1lBQ0Q7WUFDQSxNQUFNQTtRQUNQO0lBQ0Q7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtDQSxHQUNBLE1BQU15TyxhQUFhbkYsRUFBRSxFQUFFdEUsT0FBTyxFQUFFO1FBQy9CLElBQUltRixTQUFTLElBQUk7UUFDakIsSUFBSTtZQUNILE9BQU87Z0JBQ05qRSxNQUFNLE1BQU1HLElBQUk4RCxPQUFPekosS0FBSyxFQUFFLENBQUMsRUFBRXlKLE9BQU9yRSxHQUFHLENBQUMsUUFBUSxFQUFFd0QsR0FBRyxDQUFDLEVBQUU7b0JBQzNEQTtvQkFDQXhKLE1BQU13SjtvQkFDTjZFLFFBQVFuSixRQUFRbUosTUFBTTtvQkFDdEJFLGlCQUFpQnJKLFFBQVFzSixhQUFhO29CQUN0Q0Msb0JBQW9CdkosUUFBUXdKLGdCQUFnQjtnQkFDN0MsR0FBRztvQkFBRTlJLFNBQVN5RSxPQUFPekUsT0FBTztnQkFBQztnQkFDN0IxRixPQUFPO1lBQ1I7UUFDRCxFQUFFLE9BQU9BLE9BQU87WUFDZixJQUFJbUssT0FBT3pELGtCQUFrQixFQUFFLE1BQU0xRztZQUNyQyxJQUFJRCxlQUFlQyxRQUFRLE9BQU87Z0JBQ2pDa0csTUFBTTtnQkFDTmxHO1lBQ0Q7WUFDQSxNQUFNQTtRQUNQO0lBQ0Q7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F1QkEsR0FDQSxNQUFNME8sWUFBWXBGLEVBQUUsRUFBRTtRQUNyQixJQUFJcUYsU0FBUyxJQUFJO1FBQ2pCLElBQUk7WUFDSCxPQUFPO2dCQUNOekksTUFBTSxNQUFNRSxPQUFPdUksT0FBT2pPLEtBQUssRUFBRSxDQUFDLEVBQUVpTyxPQUFPN0ksR0FBRyxDQUFDLFFBQVEsRUFBRXdELEdBQUcsTUFBTSxDQUFDLEVBQUUsQ0FBQyxHQUFHO29CQUFFNUQsU0FBU2lKLE9BQU9qSixPQUFPO2dCQUFDO2dCQUNuRzFGLE9BQU87WUFDUjtRQUNELEVBQUUsT0FBT0EsT0FBTztZQUNmLElBQUkyTyxPQUFPakksa0JBQWtCLEVBQUUsTUFBTTFHO1lBQ3JDLElBQUlELGVBQWVDLFFBQVEsT0FBTztnQkFDakNrRyxNQUFNO2dCQUNObEc7WUFDRDtZQUNBLE1BQU1BO1FBQ1A7SUFDRDtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F3QkEsR0FDQSxNQUFNNE8sYUFBYXRGLEVBQUUsRUFBRTtRQUN0QixJQUFJbUIsU0FBUyxJQUFJO1FBQ2pCLElBQUk7WUFDSCxPQUFPO2dCQUNOdkUsTUFBTSxNQUFNSyxPQUFPa0UsT0FBTy9KLEtBQUssRUFBRSxDQUFDLEVBQUUrSixPQUFPM0UsR0FBRyxDQUFDLFFBQVEsRUFBRXdELEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRztvQkFBRTVELFNBQVMrRSxPQUFPL0UsT0FBTztnQkFBQztnQkFDN0YxRixPQUFPO1lBQ1I7UUFDRCxFQUFFLE9BQU9BLE9BQU87WUFDZixJQUFJeUssT0FBTy9ELGtCQUFrQixFQUFFLE1BQU0xRztZQUNyQyxJQUFJRCxlQUFlQyxRQUFRLE9BQU87Z0JBQ2pDa0csTUFBTTtnQkFDTmxHO1lBQ0Q7WUFDQSxNQUFNQTtRQUNQO0lBQ0Q7SUFDQStOLCtCQUErQi9JLE9BQU8sRUFBRTtRQUN2QyxNQUFNUyxTQUFTLENBQUM7UUFDaEIsSUFBSVQsU0FBUztZQUNaLElBQUksV0FBV0EsU0FBU1MsT0FBTytCLEtBQUssR0FBR3JFLE9BQU82QixRQUFRd0MsS0FBSztZQUMzRCxJQUFJLFlBQVl4QyxTQUFTUyxPQUFPZ0MsTUFBTSxHQUFHdEUsT0FBTzZCLFFBQVF5QyxNQUFNO1lBQzlELElBQUl6QyxRQUFRNkosTUFBTSxFQUFFcEosT0FBT29KLE1BQU0sR0FBRzdKLFFBQVE2SixNQUFNO1lBQ2xELElBQUk3SixRQUFROEosVUFBVSxFQUFFckosT0FBT3FKLFVBQVUsR0FBRzlKLFFBQVE4SixVQUFVO1lBQzlELElBQUk5SixRQUFRK0osU0FBUyxFQUFFdEosT0FBT3NKLFNBQVMsR0FBRy9KLFFBQVErSixTQUFTO1FBQzVEO1FBQ0EsT0FBTzVOLE9BQU95QyxJQUFJLENBQUM2QixRQUFRcEQsTUFBTSxHQUFHLElBQUksTUFBTSxJQUFJMk0sZ0JBQWdCdkosUUFBUXdFLFFBQVEsS0FBSztJQUN4RjtBQUNEO0FBRUEsWUFBWTtBQUNaLGdEQUFnRDtBQUNoRDs7O0FBR0EsR0FDQSxJQUFJZ0YseUJBQXlCO0lBQzVCOzs7Ozs7Ozs7Ozs7Ozs7O0NBZ0JBLEdBQ0F0UCxZQUFZbUcsR0FBRyxFQUFFSixVQUFVLENBQUMsQ0FBQyxFQUFFeUMsT0FBTyxDQUFFO1FBQ3ZDLElBQUksQ0FBQ3pCLGtCQUFrQixHQUFHO1FBQzFCLElBQUksQ0FBQ1osR0FBRyxHQUFHQSxJQUFJcEUsT0FBTyxDQUFDLE9BQU87UUFDOUIsSUFBSSxDQUFDZ0UsT0FBTyxHQUFHdkIsZUFBZUEsZUFBZSxDQUFDLEdBQUdvSixvQkFBb0I3SDtRQUNyRSxJQUFJLENBQUNoRixLQUFLLEdBQUdILGVBQWU0SDtJQUM3QjtJQUNBOzs7Ozs7Ozs7O0NBVUEsR0FDQUMsZUFBZTtRQUNkLElBQUksQ0FBQzFCLGtCQUFrQixHQUFHO1FBQzFCLE9BQU8sSUFBSTtJQUNaO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWlDQSxHQUNBLE1BQU13SCxhQUFhcE8sSUFBSSxFQUFFO1FBQ3hCLElBQUlnSCxRQUFRLElBQUk7UUFDaEIsSUFBSTtZQUNILE9BQU87Z0JBQ05aLE1BQU0sTUFBTUUsT0FBT1UsTUFBTXBHLEtBQUssRUFBRSxDQUFDLEVBQUVvRyxNQUFNaEIsR0FBRyxDQUFDLE9BQU8sQ0FBQyxFQUFFO29CQUFFaEc7Z0JBQUssR0FBRztvQkFBRTRGLFNBQVNvQixNQUFNcEIsT0FBTztnQkFBQztnQkFDMUYxRixPQUFPO1lBQ1I7UUFDRCxFQUFFLE9BQU9BLE9BQU87WUFDZixJQUFJOEcsTUFBTUosa0JBQWtCLEVBQUUsTUFBTTFHO1lBQ3BDLElBQUlELGVBQWVDLFFBQVEsT0FBTztnQkFDakNrRyxNQUFNO2dCQUNObEc7WUFDRDtZQUNBLE1BQU1BO1FBQ1A7SUFDRDtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E2Q0EsR0FDQSxNQUFNOE4sWUFBWTlJLE9BQU8sRUFBRTtRQUMxQixJQUFJaUosU0FBUyxJQUFJO1FBQ2pCLElBQUk7WUFDSCxNQUFNaUIsY0FBYyxJQUFJRjtZQUN4QixJQUFJLENBQUNoSyxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUXdDLEtBQUssTUFBTSxLQUFLLEdBQUcwSCxZQUFZbEYsR0FBRyxDQUFDLFNBQVNoRixRQUFRd0MsS0FBSyxDQUFDeUMsUUFBUTtZQUNqSSxJQUFJLENBQUNqRixZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUXlDLE1BQU0sTUFBTSxLQUFLLEdBQUd5SCxZQUFZbEYsR0FBRyxDQUFDLFVBQVVoRixRQUFReUMsTUFBTSxDQUFDd0MsUUFBUTtZQUNwSSxJQUFJakYsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVE4SixVQUFVLEVBQUVJLFlBQVlsRixHQUFHLENBQUMsY0FBY2hGLFFBQVE4SixVQUFVO1lBQzFILElBQUk5SixZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUStKLFNBQVMsRUFBRUcsWUFBWWxGLEdBQUcsQ0FBQyxhQUFhaEYsUUFBUStKLFNBQVM7WUFDdkgsSUFBSS9KLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRNkosTUFBTSxFQUFFSyxZQUFZbEYsR0FBRyxDQUFDLFVBQVVoRixRQUFRNkosTUFBTTtZQUM5RyxNQUFNL0MsY0FBY29ELFlBQVlqRixRQUFRO1lBQ3hDLE1BQU1uRSxNQUFNZ0csY0FBYyxDQUFDLEVBQUVtQyxPQUFPbkksR0FBRyxDQUFDLFFBQVEsRUFBRWdHLFlBQVksQ0FBQyxHQUFHLENBQUMsRUFBRW1DLE9BQU9uSSxHQUFHLENBQUMsT0FBTyxDQUFDO1lBQ3hGLE9BQU87Z0JBQ05JLE1BQU0sTUFBTUMsSUFBSThILE9BQU92TixLQUFLLEVBQUVvRixLQUFLO29CQUFFSixTQUFTdUksT0FBT3ZJLE9BQU87Z0JBQUM7Z0JBQzdEMUYsT0FBTztZQUNSO1FBQ0QsRUFBRSxPQUFPQSxPQUFPO1lBQ2YsSUFBSWlPLE9BQU92SCxrQkFBa0IsRUFBRSxNQUFNMUc7WUFDckMsSUFBSUQsZUFBZUMsUUFBUSxPQUFPO2dCQUNqQ2tHLE1BQU07Z0JBQ05sRztZQUNEO1lBQ0EsTUFBTUE7UUFDUDtJQUNEO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQThCQSxHQUNBLE1BQU00TyxhQUFheE0sVUFBVSxFQUFFO1FBQzlCLElBQUl5SCxTQUFTLElBQUk7UUFDakIsSUFBSTtZQUNILE9BQU87Z0JBQ04zRCxNQUFNLE1BQU1LLE9BQU9zRCxPQUFPbkosS0FBSyxFQUFFLENBQUMsRUFBRW1KLE9BQU8vRCxHQUFHLENBQUMsUUFBUSxFQUFFMUQsV0FBVyxDQUFDLEVBQUUsQ0FBQyxHQUFHO29CQUFFc0QsU0FBU21FLE9BQU9uRSxPQUFPO2dCQUFDO2dCQUNyRzFGLE9BQU87WUFDUjtRQUNELEVBQUUsT0FBT0EsT0FBTztZQUNmLElBQUk2SixPQUFPbkQsa0JBQWtCLEVBQUUsTUFBTTFHO1lBQ3JDLElBQUlELGVBQWVDLFFBQVEsT0FBTztnQkFDakNrRyxNQUFNO2dCQUNObEc7WUFDRDtZQUNBLE1BQU1BO1FBQ1A7SUFDRDtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTBIQSxHQUNBK00sS0FBSzNLLFVBQVUsRUFBRTtRQUNoQixJQUFJK0gsU0FBUyxJQUFJO1FBQ2pCLElBQUksQ0FBQ2hJLGtCQUFrQkMsYUFBYSxNQUFNLElBQUkzQyxhQUFhO1FBQzNELE1BQU0wUCxVQUFVLElBQUkzUCwwREFBa0JBLENBQUM7WUFDdENrTyxTQUFTLElBQUksQ0FBQzVILEdBQUc7WUFDakJzSixhQUFhaE47WUFDYmlOLE1BQU07Z0JBQ0xqQixNQUFNO2dCQUNOa0IsWUFBWSxVQUFZbkYsT0FBT3pFLE9BQU87WUFDdkM7WUFDQWhGLE9BQU8sSUFBSSxDQUFDQSxLQUFLO1FBQ2xCO1FBQ0EsTUFBTWdHLHFCQUFxQixJQUFJLENBQUNBLGtCQUFrQjtRQUNsRCxPQUFPLElBQUk2SSxNQUFNSixTQUFTO1lBQUVoSixLQUFJcUosTUFBTSxFQUFFQyxJQUFJO2dCQUMzQyxNQUFNak8sUUFBUWdPLE1BQU0sQ0FBQ0MsS0FBSztnQkFDMUIsSUFBSSxPQUFPak8sVUFBVSxZQUFZLE9BQU9BO2dCQUN4QyxPQUFPLE9BQU8sR0FBR2Y7b0JBQ2hCLElBQUk7d0JBQ0gsT0FBTzs0QkFDTnlGLE1BQU0sTUFBTTFFLE1BQU0wQyxLQUFLLENBQUNzTCxRQUFRL087NEJBQ2hDVCxPQUFPO3dCQUNSO29CQUNELEVBQUUsT0FBT0EsT0FBTzt3QkFDZixJQUFJMEcsb0JBQW9CLE1BQU0xRzt3QkFDOUIsT0FBTzs0QkFDTmtHLE1BQU07NEJBQ05sRzt3QkFDRDtvQkFDRDtnQkFDRDtZQUNEO1FBQUU7SUFDSDtBQUNEO0FBRUEsWUFBWTtBQUNaLHNDQUFzQztBQUN0QyxNQUFNMFAsa0JBQWtCO0lBQ3ZCLGlCQUFpQixDQUFDLFdBQVcsRUFBRXBDLFFBQVEsQ0FBQztJQUN4QyxnQkFBZ0I7QUFDakI7QUFFQSxZQUFZO0FBQ1osbUNBQW1DO0FBQ25DOztBQUVBLEdBQ0EsSUFBSXFDLHNCQUFzQixjQUFjalE7SUFDdkNDLFlBQVlDLE9BQU8sQ0FBRTtRQUNwQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDZ1EsdUJBQXVCLEdBQUc7UUFDL0IsSUFBSSxDQUFDOVAsSUFBSSxHQUFHO0lBQ2I7QUFDRDtBQUNBOzs7O0FBSUEsR0FDQSxTQUFTK1Asc0JBQXNCN1AsS0FBSztJQUNuQyxPQUFPLE9BQU9BLFVBQVUsWUFBWUEsVUFBVSxRQUFRLDZCQUE2QkE7QUFDcEY7QUFDQTs7O0FBR0EsR0FDQSxJQUFJOFAseUJBQXlCLGNBQWNIO0lBQzFDaFEsWUFBWUMsT0FBTyxFQUFFTSxNQUFNLEVBQUVDLFVBQVUsQ0FBRTtRQUN4QyxLQUFLLENBQUNQO1FBQ04sSUFBSSxDQUFDRSxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNJLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNDLFVBQVUsR0FBR0E7SUFDbkI7SUFDQUMsU0FBUztRQUNSLE9BQU87WUFDTk4sTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDZkYsU0FBUyxJQUFJLENBQUNBLE9BQU87WUFDckJNLFFBQVEsSUFBSSxDQUFDQSxNQUFNO1lBQ25CQyxZQUFZLElBQUksQ0FBQ0EsVUFBVTtRQUM1QjtJQUNEO0FBQ0Q7QUFDQTs7O0FBR0EsR0FDQSxJQUFJNFAsNkJBQTZCLGNBQWNKO0lBQzlDaFEsWUFBWUMsT0FBTyxFQUFFVSxhQUFhLENBQUU7UUFDbkMsS0FBSyxDQUFDVjtRQUNOLElBQUksQ0FBQ0UsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDUSxhQUFhLEdBQUdBO0lBQ3RCO0FBQ0Q7QUFDQTs7O0FBR0EsR0FDQSxJQUFJMFAsMEJBQTBCLGFBQWEsR0FBRyxTQUFTQyx5QkFBeUI7SUFDL0UscUNBQXFDLEdBQ3JDQSx5QkFBeUIsQ0FBQyxnQkFBZ0IsR0FBRztJQUM3QyxrREFBa0QsR0FDbERBLHlCQUF5QixDQUFDLDRCQUE0QixHQUFHO0lBQ3pELGtDQUFrQyxHQUNsQ0EseUJBQXlCLENBQUMsNEJBQTRCLEdBQUc7SUFDekQsNkNBQTZDLEdBQzdDQSx5QkFBeUIsQ0FBQyx5QkFBeUIsR0FBRztJQUN0RCwwQ0FBMEMsR0FDMUNBLHlCQUF5QixDQUFDLDZCQUE2QixHQUFHO0lBQzFELHlDQUF5QyxHQUN6Q0EseUJBQXlCLENBQUMsNkJBQTZCLEdBQUc7SUFDMUQsT0FBT0E7QUFDUixFQUFFLENBQUM7QUFFSCxZQUFZO0FBQ1osb0NBQW9DO0FBQ3BDOzs7Ozs7QUFNQSxHQUNBLE1BQU1DLGVBQWUsQ0FBQzFQO0lBQ3JCLElBQUlBLGFBQWEsT0FBTyxDQUFDLEdBQUdDLE9BQVNELGVBQWVDO0lBQ3BELE9BQU8sQ0FBQyxHQUFHQSxPQUFTQyxTQUFTRDtBQUM5QjtBQUNBOzs7OztBQUtBLEdBQ0EsTUFBTTBQLGtCQUFrQjtJQUN2QixPQUFPdlA7QUFDUjtBQUNBOzs7Ozs7O0FBT0EsR0FDQSxNQUFNd1AsZ0JBQWdCLENBQUM1TztJQUN0QixJQUFJLE9BQU9BLFVBQVUsWUFBWUEsVUFBVSxNQUFNLE9BQU87SUFDeEQsTUFBTU0sWUFBWVgsT0FBT1ksY0FBYyxDQUFDUDtJQUN4QyxPQUFPLENBQUNNLGNBQWMsUUFBUUEsY0FBY1gsT0FBT1csU0FBUyxJQUFJWCxPQUFPWSxjQUFjLENBQUNELGVBQWUsSUFBRyxLQUFNLENBQUVFLENBQUFBLE9BQU9DLFdBQVcsSUFBSVQsS0FBSSxLQUFNLENBQUVRLENBQUFBLE9BQU9FLFFBQVEsSUFBSVYsS0FBSTtBQUMxSztBQUNBOzs7Ozs7QUFNQSxHQUNBLE1BQU02TyxxQkFBcUIsQ0FBQ0M7SUFDM0IsT0FBT3ZQLE1BQU1nTSxJQUFJLENBQUMsSUFBSXdELGFBQWFEO0FBQ3BDO0FBQ0E7Ozs7Ozs7QUFPQSxHQUNBLE1BQU1FLDBCQUEwQixDQUFDQyxRQUFRQztJQUN4QyxJQUFJQSxzQkFBc0IsS0FBSyxLQUFLRCxPQUFPRSxPQUFPLENBQUN0TyxNQUFNLEtBQUtxTyxtQkFBbUIsTUFBTSxJQUFJaFIsTUFBTSxDQUFDLG9DQUFvQyxFQUFFZ1Isa0JBQWtCLE1BQU0sRUFBRUQsT0FBT0UsT0FBTyxDQUFDdE8sTUFBTSxDQUFDLENBQUM7QUFDMUw7QUFFQSxZQUFZO0FBQ1osa0NBQWtDO0FBQ2xDOzs7O0FBSUEsR0FDQSxNQUFNdU8sbUJBQW1CLENBQUNwTSxNQUFRQSxJQUFJRSxHQUFHLElBQUlGLElBQUk1RSxPQUFPLElBQUk0RSxJQUFJRyxpQkFBaUIsSUFBSUgsSUFBSXhFLEtBQUssSUFBSTRFLEtBQUtDLFNBQVMsQ0FBQ0w7QUFDakg7Ozs7O0FBS0EsR0FDQSxNQUFNcU0sY0FBYyxPQUFPN1EsT0FBTytFLFFBQVFDO0lBQ3pDLElBQUloRixTQUFTLE9BQU9BLFVBQVUsWUFBWSxZQUFZQSxTQUFTLFFBQVFBLFNBQVMsT0FBT0EsTUFBTUUsTUFBTSxLQUFLLFlBQVksQ0FBRThFLENBQUFBLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRQyxhQUFhLEdBQUc7UUFDL0wsTUFBTS9FLFNBQVNGLE1BQU1FLE1BQU0sSUFBSTtRQUMvQixNQUFNNFEsZ0JBQWdCOVE7UUFDdEIsSUFBSSxPQUFPOFEsY0FBYzVMLElBQUksS0FBSyxZQUFZNEwsY0FBYzVMLElBQUksR0FBR0MsSUFBSSxDQUFDLENBQUNYO1lBQ3hFLE1BQU1yRSxhQUFhLENBQUNxRSxRQUFRLFFBQVFBLFFBQVEsS0FBSyxJQUFJLEtBQUssSUFBSUEsSUFBSXJFLFVBQVUsS0FBTXFFLENBQUFBLFFBQVEsUUFBUUEsUUFBUSxLQUFLLElBQUksS0FBSyxJQUFJQSxJQUFJdU0sSUFBSSxLQUFLN1EsU0FBUztZQUNsSjZFLE9BQU8sSUFBSStLLHVCQUF1QmMsaUJBQWlCcE0sTUFBTXRFLFFBQVFDO1FBQ2xFLEdBQUdpRixLQUFLLENBQUM7WUFDUixNQUFNakYsYUFBYUQsU0FBUztZQUM1QjZFLE9BQU8sSUFBSStLLHVCQUF1QmdCLGNBQWNFLFVBQVUsSUFBSSxDQUFDLEtBQUssRUFBRTlRLE9BQU8sTUFBTSxDQUFDLEVBQUVBLFFBQVFDO1FBQy9GO2FBQ0s7WUFDSixNQUFNQSxhQUFhRCxTQUFTO1lBQzVCNkUsT0FBTyxJQUFJK0ssdUJBQXVCZ0IsY0FBY0UsVUFBVSxJQUFJLENBQUMsS0FBSyxFQUFFOVEsT0FBTyxNQUFNLENBQUMsRUFBRUEsUUFBUUM7UUFDL0Y7SUFDRCxPQUFPNEUsT0FBTyxJQUFJZ0wsMkJBQTJCYSxpQkFBaUI1USxRQUFRQTtBQUN2RTtBQUNBOzs7Ozs7O0FBT0EsR0FDQSxNQUFNaVIsb0JBQW9CLENBQUMzTCxRQUFRTixTQUFTTyxZQUFZQztJQUN2RCxNQUFNQyxTQUFTO1FBQ2RIO1FBQ0FJLFNBQVMsQ0FBQ1YsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVFVLE9BQU8sS0FBSyxDQUFDO0lBQ2xGO0lBQ0EsSUFBSUosV0FBVyxTQUFTLENBQUNFLE1BQU0sT0FBT0M7SUFDdEMsSUFBSTJLLGNBQWM1SyxPQUFPO1FBQ3hCQyxPQUFPQyxPQUFPLEdBQUd2QixlQUFlO1lBQUUsZ0JBQWdCO1FBQW1CLEdBQUdhLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRVSxPQUFPO1FBQ3pJRCxPQUFPRCxJQUFJLEdBQUdaLEtBQUtDLFNBQVMsQ0FBQ1c7SUFDOUIsT0FBT0MsT0FBT0QsSUFBSSxHQUFHQTtJQUNyQixPQUFPckIsZUFBZUEsZUFBZSxDQUFDLEdBQUdzQixTQUFTRjtBQUNuRDtBQUNBOzs7Ozs7Ozs7QUFTQSxHQUNBLGVBQWUyTCxlQUFlckwsT0FBTyxFQUFFUCxNQUFNLEVBQUVRLEdBQUcsRUFBRWQsT0FBTyxFQUFFTyxVQUFVLEVBQUVDLElBQUk7SUFDNUUsT0FBTyxJQUFJTyxRQUFRLENBQUNDLFNBQVNqQjtRQUM1QmMsUUFBUUMsS0FBS21MLGtCQUFrQjNMLFFBQVFOLFNBQVNPLFlBQVlDLE9BQU9MLElBQUksQ0FBQyxDQUFDL0Q7WUFDeEUsSUFBSSxDQUFDQSxPQUFPNkUsRUFBRSxFQUFFLE1BQU03RTtZQUN0QixJQUFJNEQsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVFDLGFBQWEsRUFBRSxPQUFPN0Q7WUFDcEYsTUFBTTJHLGNBQWMzRyxPQUFPc0UsT0FBTyxDQUFDUyxHQUFHLENBQUM7WUFDdkMsSUFBSSxDQUFDNEIsZUFBZSxDQUFDQSxZQUFZeEYsUUFBUSxDQUFDLHFCQUFxQixPQUFPLENBQUM7WUFDdkUsT0FBT25CLE9BQU84RCxJQUFJO1FBQ25CLEdBQUdDLElBQUksQ0FBQyxDQUFDZSxPQUFTRixRQUFRRSxPQUFPZCxLQUFLLENBQUMsQ0FBQ3BGLFFBQVU2USxZQUFZN1EsT0FBTytFLFFBQVFDO0lBQzlFO0FBQ0Q7QUFDQTs7Ozs7Ozs7QUFRQSxHQUNBLGVBQWVtTSxLQUFLdEwsT0FBTyxFQUFFQyxHQUFHLEVBQUVOLElBQUksRUFBRVIsT0FBTyxFQUFFTyxVQUFVO0lBQzFELE9BQU8yTCxlQUFlckwsU0FBUyxRQUFRQyxLQUFLZCxTQUFTTyxZQUFZQztBQUNsRTtBQUVBLFlBQVk7QUFDWiwyQ0FBMkM7QUFDM0M7Ozs7QUFJQSxHQUNBLElBQUk0TCxpQkFBaUI7SUFDcEIsMENBQTBDLEdBQzFDelIsWUFBWW1HLEdBQUcsRUFBRUosVUFBVSxDQUFDLENBQUMsRUFBRXlDLE9BQU8sQ0FBRTtRQUN2QyxJQUFJLENBQUN6QixrQkFBa0IsR0FBRztRQUMxQixJQUFJLENBQUNaLEdBQUcsR0FBR0EsSUFBSXBFLE9BQU8sQ0FBQyxPQUFPO1FBQzlCLElBQUksQ0FBQ2dFLE9BQU8sR0FBR3ZCLGVBQWVBLGVBQWUsQ0FBQyxHQUFHdUwsa0JBQWtCaEs7UUFDbkUsSUFBSSxDQUFDaEYsS0FBSyxHQUFHd1AsYUFBYS9IO0lBQzNCO0lBQ0EscUVBQXFFLEdBQ3JFQyxlQUFlO1FBQ2QsSUFBSSxDQUFDMUIsa0JBQWtCLEdBQUc7UUFDMUIsT0FBTyxJQUFJO0lBQ1o7SUFDQSwrQ0FBK0MsR0FDL0MsTUFBTTJLLFlBQVlyTSxPQUFPLEVBQUU7UUFDMUIsSUFBSThCLFFBQVEsSUFBSTtRQUNoQixJQUFJO1lBQ0gsT0FBTztnQkFDTlosTUFBTSxNQUFNaUwsS0FBS3JLLE1BQU1wRyxLQUFLLEVBQUUsQ0FBQyxFQUFFb0csTUFBTWhCLEdBQUcsQ0FBQyxZQUFZLENBQUMsRUFBRWQsU0FBUztvQkFBRVUsU0FBU29CLE1BQU1wQixPQUFPO2dCQUFDLE1BQU0sQ0FBQztnQkFDbkcxRixPQUFPO1lBQ1I7UUFDRCxFQUFFLE9BQU9BLE9BQU87WUFDZixJQUFJOEcsTUFBTUosa0JBQWtCLEVBQUUsTUFBTTFHO1lBQ3BDLElBQUk2UCxzQkFBc0I3UCxRQUFRLE9BQU87Z0JBQ3hDa0csTUFBTTtnQkFDTmxHO1lBQ0Q7WUFDQSxNQUFNQTtRQUNQO0lBQ0Q7SUFDQSxtREFBbUQsR0FDbkQsTUFBTXNSLFNBQVNDLGdCQUFnQixFQUFFQyxTQUFTLEVBQUU7UUFDM0MsSUFBSXZELFNBQVMsSUFBSTtRQUNqQixJQUFJO1lBQ0gsT0FBTztnQkFDTi9ILE1BQU0sTUFBTWlMLEtBQUtsRCxPQUFPdk4sS0FBSyxFQUFFLENBQUMsRUFBRXVOLE9BQU9uSSxHQUFHLENBQUMsU0FBUyxDQUFDLEVBQUU7b0JBQ3hEeUw7b0JBQ0FDO2dCQUNELEdBQUc7b0JBQUU5TCxTQUFTdUksT0FBT3ZJLE9BQU87Z0JBQUM7Z0JBQzdCMUYsT0FBTztZQUNSO1FBQ0QsRUFBRSxPQUFPQSxPQUFPO1lBQ2YsSUFBSWlPLE9BQU92SCxrQkFBa0IsRUFBRSxNQUFNMUc7WUFDckMsSUFBSTZQLHNCQUFzQjdQLFFBQVEsT0FBTztnQkFDeENrRyxNQUFNO2dCQUNObEc7WUFDRDtZQUNBLE1BQU1BO1FBQ1A7SUFDRDtJQUNBLGdGQUFnRixHQUNoRixNQUFNeVIsWUFBWXpNLE9BQU8sRUFBRTtRQUMxQixJQUFJNkUsU0FBUyxJQUFJO1FBQ2pCLElBQUk7WUFDSCxPQUFPO2dCQUNOM0QsTUFBTSxNQUFNaUwsS0FBS3RILE9BQU9uSixLQUFLLEVBQUUsQ0FBQyxFQUFFbUosT0FBTy9ELEdBQUcsQ0FBQyxZQUFZLENBQUMsRUFBRWQsU0FBUztvQkFBRVUsU0FBU21FLE9BQU9uRSxPQUFPO2dCQUFDO2dCQUMvRjFGLE9BQU87WUFDUjtRQUNELEVBQUUsT0FBT0EsT0FBTztZQUNmLElBQUk2SixPQUFPbkQsa0JBQWtCLEVBQUUsTUFBTTFHO1lBQ3JDLElBQUk2UCxzQkFBc0I3UCxRQUFRLE9BQU87Z0JBQ3hDa0csTUFBTTtnQkFDTmxHO1lBQ0Q7WUFDQSxNQUFNQTtRQUNQO0lBQ0Q7SUFDQSw0Q0FBNEMsR0FDNUMsTUFBTTBSLFlBQVlILGdCQUFnQixFQUFFQyxTQUFTLEVBQUU7UUFDOUMsSUFBSXJILFNBQVMsSUFBSTtRQUNqQixJQUFJO1lBQ0gsT0FBTztnQkFDTmpFLE1BQU0sTUFBTWlMLEtBQUtoSCxPQUFPekosS0FBSyxFQUFFLENBQUMsRUFBRXlKLE9BQU9yRSxHQUFHLENBQUMsWUFBWSxDQUFDLEVBQUU7b0JBQzNEeUw7b0JBQ0FDO2dCQUNELEdBQUc7b0JBQUU5TCxTQUFTeUUsT0FBT3pFLE9BQU87Z0JBQUMsTUFBTSxDQUFDO2dCQUNwQzFGLE9BQU87WUFDUjtRQUNELEVBQUUsT0FBT0EsT0FBTztZQUNmLElBQUltSyxPQUFPekQsa0JBQWtCLEVBQUUsTUFBTTFHO1lBQ3JDLElBQUk2UCxzQkFBc0I3UCxRQUFRLE9BQU87Z0JBQ3hDa0csTUFBTTtnQkFDTmxHO1lBQ0Q7WUFDQSxNQUFNQTtRQUNQO0lBQ0Q7QUFDRDtBQUVBLFlBQVk7QUFDWiwwQ0FBMEM7QUFDMUM7Ozs7QUFJQSxHQUNBLElBQUkyUixnQkFBZ0I7SUFDbkIseUNBQXlDLEdBQ3pDaFMsWUFBWW1HLEdBQUcsRUFBRUosVUFBVSxDQUFDLENBQUMsRUFBRXlDLE9BQU8sQ0FBRTtRQUN2QyxJQUFJLENBQUN6QixrQkFBa0IsR0FBRztRQUMxQixJQUFJLENBQUNaLEdBQUcsR0FBR0EsSUFBSXBFLE9BQU8sQ0FBQyxPQUFPO1FBQzlCLElBQUksQ0FBQ2dFLE9BQU8sR0FBR3ZCLGVBQWVBLGVBQWUsQ0FBQyxHQUFHdUwsa0JBQWtCaEs7UUFDbkUsSUFBSSxDQUFDaEYsS0FBSyxHQUFHd1AsYUFBYS9IO0lBQzNCO0lBQ0EscUVBQXFFLEdBQ3JFQyxlQUFlO1FBQ2QsSUFBSSxDQUFDMUIsa0JBQWtCLEdBQUc7UUFDMUIsT0FBTyxJQUFJO0lBQ1o7SUFDQSw0REFBNEQsR0FDNUQsTUFBTWtMLFdBQVc1TSxPQUFPLEVBQUU7UUFDekIsSUFBSThCLFFBQVEsSUFBSTtRQUNoQixJQUFJO1lBQ0gsSUFBSTlCLFFBQVE2TSxPQUFPLENBQUN4UCxNQUFNLEdBQUcsS0FBSzJDLFFBQVE2TSxPQUFPLENBQUN4UCxNQUFNLEdBQUcsS0FBSyxNQUFNLElBQUkzQyxNQUFNO1lBQ2hGLE9BQU87Z0JBQ053RyxNQUFNLE1BQU1pTCxLQUFLckssTUFBTXBHLEtBQUssRUFBRSxDQUFDLEVBQUVvRyxNQUFNaEIsR0FBRyxDQUFDLFdBQVcsQ0FBQyxFQUFFZCxTQUFTO29CQUFFVSxTQUFTb0IsTUFBTXBCLE9BQU87Z0JBQUMsTUFBTSxDQUFDO2dCQUNsRzFGLE9BQU87WUFDUjtRQUNELEVBQUUsT0FBT0EsT0FBTztZQUNmLElBQUk4RyxNQUFNSixrQkFBa0IsRUFBRSxNQUFNMUc7WUFDcEMsSUFBSTZQLHNCQUFzQjdQLFFBQVEsT0FBTztnQkFDeENrRyxNQUFNO2dCQUNObEc7WUFDRDtZQUNBLE1BQU1BO1FBQ1A7SUFDRDtJQUNBLDZDQUE2QyxHQUM3QyxNQUFNOFIsV0FBVzlNLE9BQU8sRUFBRTtRQUN6QixJQUFJaUosU0FBUyxJQUFJO1FBQ2pCLElBQUk7WUFDSCxPQUFPO2dCQUNOL0gsTUFBTSxNQUFNaUwsS0FBS2xELE9BQU92TixLQUFLLEVBQUUsQ0FBQyxFQUFFdU4sT0FBT25JLEdBQUcsQ0FBQyxXQUFXLENBQUMsRUFBRWQsU0FBUztvQkFBRVUsU0FBU3VJLE9BQU92SSxPQUFPO2dCQUFDO2dCQUM5RjFGLE9BQU87WUFDUjtRQUNELEVBQUUsT0FBT0EsT0FBTztZQUNmLElBQUlpTyxPQUFPdkgsa0JBQWtCLEVBQUUsTUFBTTFHO1lBQ3JDLElBQUk2UCxzQkFBc0I3UCxRQUFRLE9BQU87Z0JBQ3hDa0csTUFBTTtnQkFDTmxHO1lBQ0Q7WUFDQSxNQUFNQTtRQUNQO0lBQ0Q7SUFDQSw4Q0FBOEMsR0FDOUMsTUFBTStSLFlBQVkvTSxPQUFPLEVBQUU7UUFDMUIsSUFBSTZFLFNBQVMsSUFBSTtRQUNqQixJQUFJO1lBQ0gsSUFBSTdFLFFBQVFnTixZQUFZLEtBQUssS0FBSyxHQUFHO2dCQUNwQyxJQUFJaE4sUUFBUWdOLFlBQVksR0FBRyxLQUFLaE4sUUFBUWdOLFlBQVksR0FBRyxJQUFJLE1BQU0sSUFBSXRTLE1BQU07Z0JBQzNFLElBQUlzRixRQUFRaU4sWUFBWSxLQUFLLEtBQUssR0FBRztvQkFDcEMsSUFBSWpOLFFBQVFpTixZQUFZLEdBQUcsS0FBS2pOLFFBQVFpTixZQUFZLElBQUlqTixRQUFRZ04sWUFBWSxFQUFFLE1BQU0sSUFBSXRTLE1BQU0sQ0FBQyxtQ0FBbUMsRUFBRXNGLFFBQVFnTixZQUFZLEdBQUcsRUFBRSxDQUFDO2dCQUMvSjtZQUNEO1lBQ0EsT0FBTztnQkFDTjlMLE1BQU0sTUFBTWlMLEtBQUt0SCxPQUFPbkosS0FBSyxFQUFFLENBQUMsRUFBRW1KLE9BQU8vRCxHQUFHLENBQUMsWUFBWSxDQUFDLEVBQUVkLFNBQVM7b0JBQUVVLFNBQVNtRSxPQUFPbkUsT0FBTztnQkFBQztnQkFDL0YxRixPQUFPO1lBQ1I7UUFDRCxFQUFFLE9BQU9BLE9BQU87WUFDZixJQUFJNkosT0FBT25ELGtCQUFrQixFQUFFLE1BQU0xRztZQUNyQyxJQUFJNlAsc0JBQXNCN1AsUUFBUSxPQUFPO2dCQUN4Q2tHLE1BQU07Z0JBQ05sRztZQUNEO1lBQ0EsTUFBTUE7UUFDUDtJQUNEO0lBQ0EsMEVBQTBFLEdBQzFFLE1BQU1rUyxhQUFhbE4sT0FBTyxFQUFFO1FBQzNCLElBQUltRixTQUFTLElBQUk7UUFDakIsSUFBSTtZQUNILE9BQU87Z0JBQ05qRSxNQUFNLE1BQU1pTCxLQUFLaEgsT0FBT3pKLEtBQUssRUFBRSxDQUFDLEVBQUV5SixPQUFPckUsR0FBRyxDQUFDLGFBQWEsQ0FBQyxFQUFFZCxTQUFTO29CQUFFVSxTQUFTeUUsT0FBT3pFLE9BQU87Z0JBQUM7Z0JBQ2hHMUYsT0FBTztZQUNSO1FBQ0QsRUFBRSxPQUFPQSxPQUFPO1lBQ2YsSUFBSW1LLE9BQU96RCxrQkFBa0IsRUFBRSxNQUFNMUc7WUFDckMsSUFBSTZQLHNCQUFzQjdQLFFBQVEsT0FBTztnQkFDeENrRyxNQUFNO2dCQUNObEc7WUFDRDtZQUNBLE1BQU1BO1FBQ1A7SUFDRDtJQUNBLCtEQUErRCxHQUMvRCxNQUFNbVMsY0FBY25OLE9BQU8sRUFBRTtRQUM1QixJQUFJMkosU0FBUyxJQUFJO1FBQ2pCLElBQUk7WUFDSCxJQUFJM0osUUFBUXBCLElBQUksQ0FBQ3ZCLE1BQU0sR0FBRyxLQUFLMkMsUUFBUXBCLElBQUksQ0FBQ3ZCLE1BQU0sR0FBRyxLQUFLLE1BQU0sSUFBSTNDLE1BQU07WUFDMUUsT0FBTztnQkFDTndHLE1BQU0sTUFBTWlMLEtBQUt4QyxPQUFPak8sS0FBSyxFQUFFLENBQUMsRUFBRWlPLE9BQU83SSxHQUFHLENBQUMsY0FBYyxDQUFDLEVBQUVkLFNBQVM7b0JBQUVVLFNBQVNpSixPQUFPakosT0FBTztnQkFBQyxNQUFNLENBQUM7Z0JBQ3hHMUYsT0FBTztZQUNSO1FBQ0QsRUFBRSxPQUFPQSxPQUFPO1lBQ2YsSUFBSTJPLE9BQU9qSSxrQkFBa0IsRUFBRSxNQUFNMUc7WUFDckMsSUFBSTZQLHNCQUFzQjdQLFFBQVEsT0FBTztnQkFDeENrRyxNQUFNO2dCQUNObEc7WUFDRDtZQUNBLE1BQU1BO1FBQ1A7SUFDRDtBQUNEO0FBRUEsWUFBWTtBQUNaLDRDQUE0QztBQUM1Qzs7OztBQUlBLEdBQ0EsSUFBSW9TLGtCQUFrQjtJQUNyQiwyQ0FBMkMsR0FDM0N6UyxZQUFZbUcsR0FBRyxFQUFFSixVQUFVLENBQUMsQ0FBQyxFQUFFeUMsT0FBTyxDQUFFO1FBQ3ZDLElBQUksQ0FBQ3pCLGtCQUFrQixHQUFHO1FBQzFCLElBQUksQ0FBQ1osR0FBRyxHQUFHQSxJQUFJcEUsT0FBTyxDQUFDLE9BQU87UUFDOUIsSUFBSSxDQUFDZ0UsT0FBTyxHQUFHdkIsZUFBZUEsZUFBZSxDQUFDLEdBQUd1TCxrQkFBa0JoSztRQUNuRSxJQUFJLENBQUNoRixLQUFLLEdBQUd3UCxhQUFhL0g7SUFDM0I7SUFDQSxxRUFBcUUsR0FDckVDLGVBQWU7UUFDZCxJQUFJLENBQUMxQixrQkFBa0IsR0FBRztRQUMxQixPQUFPLElBQUk7SUFDWjtJQUNBLGdDQUFnQyxHQUNoQyxNQUFNd0gsYUFBYXFELGdCQUFnQixFQUFFO1FBQ3BDLElBQUl6SyxRQUFRLElBQUk7UUFDaEIsSUFBSTtZQUNILE9BQU87Z0JBQ05aLE1BQU0sTUFBTWlMLEtBQUtySyxNQUFNcEcsS0FBSyxFQUFFLENBQUMsRUFBRW9HLE1BQU1oQixHQUFHLENBQUMsbUJBQW1CLENBQUMsRUFBRTtvQkFBRXlMO2dCQUFpQixHQUFHO29CQUFFN0wsU0FBU29CLE1BQU1wQixPQUFPO2dCQUFDLE1BQU0sQ0FBQztnQkFDdkgxRixPQUFPO1lBQ1I7UUFDRCxFQUFFLE9BQU9BLE9BQU87WUFDZixJQUFJOEcsTUFBTUosa0JBQWtCLEVBQUUsTUFBTTFHO1lBQ3BDLElBQUk2UCxzQkFBc0I3UCxRQUFRLE9BQU87Z0JBQ3hDa0csTUFBTTtnQkFDTmxHO1lBQ0Q7WUFDQSxNQUFNQTtRQUNQO0lBQ0Q7SUFDQSxvREFBb0QsR0FDcEQsTUFBTWdPLFVBQVV1RCxnQkFBZ0IsRUFBRTtRQUNqQyxJQUFJdEQsU0FBUyxJQUFJO1FBQ2pCLElBQUk7WUFDSCxPQUFPO2dCQUNOL0gsTUFBTSxNQUFNaUwsS0FBS2xELE9BQU92TixLQUFLLEVBQUUsQ0FBQyxFQUFFdU4sT0FBT25JLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFO29CQUFFeUw7Z0JBQWlCLEdBQUc7b0JBQUU3TCxTQUFTdUksT0FBT3ZJLE9BQU87Z0JBQUM7Z0JBQ2hIMUYsT0FBTztZQUNSO1FBQ0QsRUFBRSxPQUFPQSxPQUFPO1lBQ2YsSUFBSWlPLE9BQU92SCxrQkFBa0IsRUFBRSxNQUFNMUc7WUFDckMsSUFBSTZQLHNCQUFzQjdQLFFBQVEsT0FBTztnQkFDeENrRyxNQUFNO2dCQUNObEc7WUFDRDtZQUNBLE1BQU1BO1FBQ1A7SUFDRDtJQUNBLGdFQUFnRSxHQUNoRSxNQUFNOE4sWUFBWTlJLFVBQVUsQ0FBQyxDQUFDLEVBQUU7UUFDL0IsSUFBSTZFLFNBQVMsSUFBSTtRQUNqQixJQUFJO1lBQ0gsT0FBTztnQkFDTjNELE1BQU0sTUFBTWlMLEtBQUt0SCxPQUFPbkosS0FBSyxFQUFFLENBQUMsRUFBRW1KLE9BQU8vRCxHQUFHLENBQUMsa0JBQWtCLENBQUMsRUFBRWQsU0FBUztvQkFBRVUsU0FBU21FLE9BQU9uRSxPQUFPO2dCQUFDO2dCQUNyRzFGLE9BQU87WUFDUjtRQUNELEVBQUUsT0FBT0EsT0FBTztZQUNmLElBQUk2SixPQUFPbkQsa0JBQWtCLEVBQUUsTUFBTTFHO1lBQ3JDLElBQUk2UCxzQkFBc0I3UCxRQUFRLE9BQU87Z0JBQ3hDa0csTUFBTTtnQkFDTmxHO1lBQ0Q7WUFDQSxNQUFNQTtRQUNQO0lBQ0Q7SUFDQSxrREFBa0QsR0FDbEQsTUFBTTRPLGFBQWEyQyxnQkFBZ0IsRUFBRTtRQUNwQyxJQUFJcEgsU0FBUyxJQUFJO1FBQ2pCLElBQUk7WUFDSCxPQUFPO2dCQUNOakUsTUFBTSxNQUFNaUwsS0FBS2hILE9BQU96SixLQUFLLEVBQUUsQ0FBQyxFQUFFeUosT0FBT3JFLEdBQUcsQ0FBQyxtQkFBbUIsQ0FBQyxFQUFFO29CQUFFeUw7Z0JBQWlCLEdBQUc7b0JBQUU3TCxTQUFTeUUsT0FBT3pFLE9BQU87Z0JBQUMsTUFBTSxDQUFDO2dCQUMxSDFGLE9BQU87WUFDUjtRQUNELEVBQUUsT0FBT0EsT0FBTztZQUNmLElBQUltSyxPQUFPekQsa0JBQWtCLEVBQUUsTUFBTTFHO1lBQ3JDLElBQUk2UCxzQkFBc0I3UCxRQUFRLE9BQU87Z0JBQ3hDa0csTUFBTTtnQkFDTmxHO1lBQ0Q7WUFDQSxNQUFNQTtRQUNQO0lBQ0Q7QUFDRDtBQUVBLFlBQVk7QUFDWixpREFBaUQ7QUFDakQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUNBLEdBQ0EsSUFBSXFTLHVCQUF1QixjQUFjRDtJQUN4Qzs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQSxHQUNBelMsWUFBWW1HLEdBQUcsRUFBRWQsVUFBVSxDQUFDLENBQUMsQ0FBRTtRQUM5QixLQUFLLENBQUNjLEtBQUtkLFFBQVFVLE9BQU8sSUFBSSxDQUFDLEdBQUdWLFFBQVF0RSxLQUFLO0lBQ2hEO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJBLEdBQ0FxTSxLQUFLd0UsZ0JBQWdCLEVBQUU7UUFDdEIsT0FBTyxJQUFJZSxrQkFBa0IsSUFBSSxDQUFDeE0sR0FBRyxFQUFFLElBQUksQ0FBQ0osT0FBTyxFQUFFNkwsa0JBQWtCLElBQUksQ0FBQzdRLEtBQUs7SUFDbEY7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FvQkEsR0FDQSxNQUFNd04sYUFBYXFELGdCQUFnQixFQUFFO1FBQ3BDLElBQUlnQiw2QkFBNkIsSUFBTSxLQUFLLENBQUNyRSxjQUFjcEgsUUFBUSxJQUFJO1FBQ3ZFLE9BQU95TCw2QkFBNkJ0UCxJQUFJLENBQUM2RCxPQUFPeUs7SUFDakQ7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBcUJBLEdBQ0EsTUFBTXZELFVBQVV1RCxnQkFBZ0IsRUFBRTtRQUNqQyxJQUFJaUIsMEJBQTBCLElBQU0sS0FBSyxDQUFDeEUsV0FBV0MsU0FBUyxJQUFJO1FBQ2xFLE9BQU91RSwwQkFBMEJ2UCxJQUFJLENBQUNnTCxRQUFRc0Q7SUFDL0M7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F1QkEsR0FDQSxNQUFNekQsWUFBWTlJLFVBQVUsQ0FBQyxDQUFDLEVBQUU7UUFDL0IsSUFBSXlOLDRCQUE0QixJQUFNLEtBQUssQ0FBQzNFLGFBQWFqRSxTQUFTLElBQUk7UUFDdEUsT0FBTzRJLDRCQUE0QnhQLElBQUksQ0FBQzRHLFFBQVE3RTtJQUNqRDtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW9CQSxHQUNBLE1BQU00SixhQUFhMkMsZ0JBQWdCLEVBQUU7UUFDcEMsSUFBSW1CLDZCQUE2QixJQUFNLEtBQUssQ0FBQzlELGNBQWN6RSxTQUFTLElBQUk7UUFDeEUsT0FBT3VJLDZCQUE2QnpQLElBQUksQ0FBQ2tILFFBQVFvSDtJQUNsRDtBQUNEO0FBQ0E7Ozs7Ozs7O0FBUUEsR0FDQSxJQUFJZSxvQkFBb0IsY0FBY2xCO0lBQ3JDOzs7Ozs7Ozs7Ozs7Q0FZQSxHQUNBelIsWUFBWW1HLEdBQUcsRUFBRUosT0FBTyxFQUFFNkwsZ0JBQWdCLEVBQUVwSixPQUFPLENBQUU7UUFDcEQsS0FBSyxDQUFDckMsS0FBS0osU0FBU3lDO1FBQ3BCLElBQUksQ0FBQ29KLGdCQUFnQixHQUFHQTtJQUN6QjtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTBCQSxHQUNBLE1BQU1GLFlBQVlyTSxPQUFPLEVBQUU7UUFDMUIsSUFBSTJOLDRCQUE0QixJQUFNLEtBQUssQ0FBQ3RCLGFBQWExQyxTQUFTLElBQUk7UUFDdEUsT0FBT2dFLDRCQUE0QjFQLElBQUksQ0FBQzBMLFFBQVF4SyxlQUFlQSxlQUFlLENBQUMsR0FBR2EsVUFBVSxDQUFDLEdBQUc7WUFBRXVNLGtCQUFrQjVDLE9BQU80QyxnQkFBZ0I7UUFBQztJQUM3STtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQkEsR0FDQSxNQUFNRSxZQUFZek0sVUFBVSxDQUFDLENBQUMsRUFBRTtRQUMvQixJQUFJNE4sNEJBQTRCLElBQU0sS0FBSyxDQUFDbkIsYUFBYWhILFNBQVMsSUFBSTtRQUN0RSxPQUFPbUksNEJBQTRCM1AsSUFBSSxDQUFDd0gsUUFBUXRHLGVBQWVBLGVBQWUsQ0FBQyxHQUFHYSxVQUFVLENBQUMsR0FBRztZQUFFdU0sa0JBQWtCOUcsT0FBTzhHLGdCQUFnQjtRQUFDO0lBQzdJO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtQkEsR0FDQSxNQUFNRCxTQUFTRSxTQUFTLEVBQUU7UUFDekIsSUFBSXFCLHlCQUF5QixJQUFNLEtBQUssQ0FBQ3ZCLFVBQVV4RyxTQUFTLElBQUk7UUFDaEUsT0FBTytILHlCQUF5QjVQLElBQUksQ0FBQzZILFFBQVFBLE9BQU95RyxnQkFBZ0IsRUFBRUM7SUFDdkU7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBa0JBLEdBQ0EsTUFBTUUsWUFBWUYsU0FBUyxFQUFFO1FBQzVCLElBQUlzQiw0QkFBNEIsSUFBTSxLQUFLLENBQUNwQixhQUFhekcsU0FBUyxJQUFJO1FBQ3RFLE9BQU82SCw0QkFBNEI3UCxJQUFJLENBQUNnSSxRQUFRQSxPQUFPc0csZ0JBQWdCLEVBQUVDO0lBQzFFO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQThCQSxHQUNBdUIsTUFBTXZCLFNBQVMsRUFBRTtRQUNoQixPQUFPLElBQUl3QixpQkFBaUIsSUFBSSxDQUFDbE4sR0FBRyxFQUFFLElBQUksQ0FBQ0osT0FBTyxFQUFFLElBQUksQ0FBQzZMLGdCQUFnQixFQUFFQyxXQUFXLElBQUksQ0FBQzlRLEtBQUs7SUFDakc7QUFDRDtBQUNBOzs7Ozs7OztBQVFBLEdBQ0EsSUFBSXNTLG1CQUFtQixjQUFjckI7SUFDcEM7Ozs7Ozs7Ozs7Ozs7Q0FhQSxHQUNBaFMsWUFBWW1HLEdBQUcsRUFBRUosT0FBTyxFQUFFNkwsZ0JBQWdCLEVBQUVDLFNBQVMsRUFBRXJKLE9BQU8sQ0FBRTtRQUMvRCxLQUFLLENBQUNyQyxLQUFLSixTQUFTeUM7UUFDcEIsSUFBSSxDQUFDb0osZ0JBQWdCLEdBQUdBO1FBQ3hCLElBQUksQ0FBQ0MsU0FBUyxHQUFHQTtJQUNsQjtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTBCQSxHQUNBLE1BQU1JLFdBQVc1TSxPQUFPLEVBQUU7UUFDekIsSUFBSWlPLDJCQUEyQixJQUFNLEtBQUssQ0FBQ3JCLFlBQVluRyxTQUFTLElBQUk7UUFDcEUsT0FBT3dILDJCQUEyQmhRLElBQUksQ0FBQ3dJLFFBQVF0SCxlQUFlQSxlQUFlLENBQUMsR0FBR2EsVUFBVSxDQUFDLEdBQUc7WUFDOUZ1TSxrQkFBa0I5RixPQUFPOEYsZ0JBQWdCO1lBQ3pDQyxXQUFXL0YsT0FBTytGLFNBQVM7UUFDNUI7SUFDRDtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FxQkEsR0FDQSxNQUFNTSxXQUFXOU0sT0FBTyxFQUFFO1FBQ3pCLElBQUlrTywyQkFBMkIsSUFBTSxLQUFLLENBQUNwQixZQUFZOUYsVUFBVSxJQUFJO1FBQ3JFLE9BQU9rSCwyQkFBMkJqUSxJQUFJLENBQUMrSSxTQUFTN0gsZUFBZUEsZUFBZSxDQUFDLEdBQUdhLFVBQVUsQ0FBQyxHQUFHO1lBQy9GdU0sa0JBQWtCdkYsUUFBUXVGLGdCQUFnQjtZQUMxQ0MsV0FBV3hGLFFBQVF3RixTQUFTO1FBQzdCO0lBQ0Q7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBcUJBLEdBQ0EsTUFBTU8sWUFBWS9NLFVBQVUsQ0FBQyxDQUFDLEVBQUU7UUFDL0IsSUFBSW1PLDRCQUE0QixJQUFNLEtBQUssQ0FBQ3BCLGFBQWE3RixVQUFVLElBQUk7UUFDdkUsT0FBT2lILDRCQUE0QmxRLElBQUksQ0FBQ2lKLFNBQVMvSCxlQUFlQSxlQUFlLENBQUMsR0FBR2EsVUFBVSxDQUFDLEdBQUc7WUFDaEd1TSxrQkFBa0JyRixRQUFRcUYsZ0JBQWdCO1lBQzFDQyxXQUFXdEYsUUFBUXNGLFNBQVM7UUFDN0I7SUFDRDtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F3QkEsR0FDQSxNQUFNVSxhQUFhbE4sT0FBTyxFQUFFO1FBQzNCLElBQUlvTyw2QkFBNkIsSUFBTSxLQUFLLENBQUNsQixjQUFjM0YsVUFBVSxJQUFJO1FBQ3pFLE9BQU82Ryw2QkFBNkJuUSxJQUFJLENBQUNzSixTQUFTcEksZUFBZUEsZUFBZSxDQUFDLEdBQUdhLFVBQVUsQ0FBQyxHQUFHO1lBQ2pHdU0sa0JBQWtCaEYsUUFBUWdGLGdCQUFnQjtZQUMxQ0MsV0FBV2pGLFFBQVFpRixTQUFTO1FBQzdCO0lBQ0Q7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FvQkEsR0FDQSxNQUFNVyxjQUFjbk4sT0FBTyxFQUFFO1FBQzVCLElBQUlxTyw4QkFBOEIsSUFBTSxLQUFLLENBQUNsQixlQUFlekYsVUFBVSxJQUFJO1FBQzNFLE9BQU8yRyw4QkFBOEJwUSxJQUFJLENBQUN5SixTQUFTdkksZUFBZUEsZUFBZSxDQUFDLEdBQUdhLFVBQVUsQ0FBQyxHQUFHO1lBQ2xHdU0sa0JBQWtCN0UsUUFBUTZFLGdCQUFnQjtZQUMxQ0MsV0FBVzlFLFFBQVE4RSxTQUFTO1FBQzdCO0lBQ0Q7QUFDRDtBQUVBLFlBQVk7QUFDWiw4QkFBOEI7QUFDOUIsSUFBSThCLGdCQUFnQixjQUFjOUY7SUFDakM7Ozs7Ozs7Ozs7Ozs7Q0FhQSxHQUNBN04sWUFBWW1HLEdBQUcsRUFBRUosVUFBVSxDQUFDLENBQUMsRUFBRXlDLE9BQU8sRUFBRXNGLElBQUksQ0FBRTtRQUM3QyxLQUFLLENBQUMzSCxLQUFLSixTQUFTeUMsU0FBU3NGO0lBQzlCO0lBQ0E7Ozs7Ozs7Ozs7Q0FVQSxHQUNBVixLQUFLekQsRUFBRSxFQUFFO1FBQ1IsT0FBTyxJQUFJckIsZUFBZSxJQUFJLENBQUNuQyxHQUFHLEVBQUUsSUFBSSxDQUFDSixPQUFPLEVBQUU0RCxJQUFJLElBQUksQ0FBQzVJLEtBQUs7SUFDakU7SUFDQTs7Ozs7Ozs7OztDQVVBLEdBQ0EsSUFBSW1SLFVBQVU7UUFDYixPQUFPLElBQUlRLHFCQUFxQixJQUFJLENBQUN2TSxHQUFHLEdBQUcsV0FBVztZQUNyREosU0FBUyxJQUFJLENBQUNBLE9BQU87WUFDckJoRixPQUFPLElBQUksQ0FBQ0EsS0FBSztRQUNsQjtJQUNEO0lBQ0E7Ozs7Ozs7Ozs7Q0FVQSxHQUNBLElBQUk2UyxZQUFZO1FBQ2YsT0FBTyxJQUFJdEUsdUJBQXVCLElBQUksQ0FBQ25KLEdBQUcsR0FBRyxZQUFZLElBQUksQ0FBQ0osT0FBTyxFQUFFLElBQUksQ0FBQ2hGLEtBQUs7SUFDbEY7QUFDRDtBQUVBLFlBQVk7QUFDd2EsQ0FDcGIsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac3VwYWJhc2Urc3RvcmFnZS1qc0AyLjkxLjAvbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdG9yYWdlLWpzL2Rpc3QvaW5kZXgubWpzP2E4ZDkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSWNlYmVyZ1Jlc3RDYXRhbG9nIH0gZnJvbSBcImljZWJlcmctanNcIjtcblxuLy8jcmVnaW9uIHNyYy9saWIvZXJyb3JzLnRzXG52YXIgU3RvcmFnZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG5cdGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcblx0XHRzdXBlcihtZXNzYWdlKTtcblx0XHR0aGlzLl9faXNTdG9yYWdlRXJyb3IgPSB0cnVlO1xuXHRcdHRoaXMubmFtZSA9IFwiU3RvcmFnZUVycm9yXCI7XG5cdH1cbn07XG5mdW5jdGlvbiBpc1N0b3JhZ2VFcnJvcihlcnJvcikge1xuXHRyZXR1cm4gdHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiICYmIGVycm9yICE9PSBudWxsICYmIFwiX19pc1N0b3JhZ2VFcnJvclwiIGluIGVycm9yO1xufVxudmFyIFN0b3JhZ2VBcGlFcnJvciA9IGNsYXNzIGV4dGVuZHMgU3RvcmFnZUVycm9yIHtcblx0Y29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzLCBzdGF0dXNDb2RlKSB7XG5cdFx0c3VwZXIobWVzc2FnZSk7XG5cdFx0dGhpcy5uYW1lID0gXCJTdG9yYWdlQXBpRXJyb3JcIjtcblx0XHR0aGlzLnN0YXR1cyA9IHN0YXR1cztcblx0XHR0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuXHR9XG5cdHRvSlNPTigpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0bmFtZTogdGhpcy5uYW1lLFxuXHRcdFx0bWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuXHRcdFx0c3RhdHVzOiB0aGlzLnN0YXR1cyxcblx0XHRcdHN0YXR1c0NvZGU6IHRoaXMuc3RhdHVzQ29kZVxuXHRcdH07XG5cdH1cbn07XG52YXIgU3RvcmFnZVVua25vd25FcnJvciA9IGNsYXNzIGV4dGVuZHMgU3RvcmFnZUVycm9yIHtcblx0Y29uc3RydWN0b3IobWVzc2FnZSwgb3JpZ2luYWxFcnJvcikge1xuXHRcdHN1cGVyKG1lc3NhZ2UpO1xuXHRcdHRoaXMubmFtZSA9IFwiU3RvcmFnZVVua25vd25FcnJvclwiO1xuXHRcdHRoaXMub3JpZ2luYWxFcnJvciA9IG9yaWdpbmFsRXJyb3I7XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9saWIvaGVscGVycy50c1xuY29uc3QgcmVzb2x2ZUZldGNoJDEgPSAoY3VzdG9tRmV0Y2gpID0+IHtcblx0aWYgKGN1c3RvbUZldGNoKSByZXR1cm4gKC4uLmFyZ3MpID0+IGN1c3RvbUZldGNoKC4uLmFyZ3MpO1xuXHRyZXR1cm4gKC4uLmFyZ3MpID0+IGZldGNoKC4uLmFyZ3MpO1xufTtcbmNvbnN0IHJlc29sdmVSZXNwb25zZSQxID0gKCkgPT4ge1xuXHRyZXR1cm4gUmVzcG9uc2U7XG59O1xuY29uc3QgcmVjdXJzaXZlVG9DYW1lbCA9IChpdGVtKSA9PiB7XG5cdGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSByZXR1cm4gaXRlbS5tYXAoKGVsKSA9PiByZWN1cnNpdmVUb0NhbWVsKGVsKSk7XG5cdGVsc2UgaWYgKHR5cGVvZiBpdGVtID09PSBcImZ1bmN0aW9uXCIgfHwgaXRlbSAhPT0gT2JqZWN0KGl0ZW0pKSByZXR1cm4gaXRlbTtcblx0Y29uc3QgcmVzdWx0ID0ge307XG5cdE9iamVjdC5lbnRyaWVzKGl0ZW0pLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuXHRcdGNvbnN0IG5ld0tleSA9IGtleS5yZXBsYWNlKC8oWy1fXVthLXpdKS9naSwgKGMpID0+IGMudG9VcHBlckNhc2UoKS5yZXBsYWNlKC9bLV9dL2csIFwiXCIpKTtcblx0XHRyZXN1bHRbbmV3S2V5XSA9IHJlY3Vyc2l2ZVRvQ2FtZWwodmFsdWUpO1xuXHR9KTtcblx0cmV0dXJuIHJlc3VsdDtcbn07XG4vKipcbiogRGV0ZXJtaW5lIGlmIGlucHV0IGlzIGEgcGxhaW4gb2JqZWN0XG4qIEFuIG9iamVjdCBpcyBwbGFpbiBpZiBpdCdzIGNyZWF0ZWQgYnkgZWl0aGVyIHt9LCBuZXcgT2JqZWN0KCksIG9yIE9iamVjdC5jcmVhdGUobnVsbClcbiogc291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL2lzLXBsYWluLW9ialxuKi9cbmNvbnN0IGlzUGxhaW5PYmplY3QkMSA9ICh2YWx1ZSkgPT4ge1xuXHRpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdGNvbnN0IHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XG5cdHJldHVybiAocHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG90eXBlKSA9PT0gbnVsbCkgJiYgIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWUpICYmICEoU3ltYm9sLml0ZXJhdG9yIGluIHZhbHVlKTtcbn07XG4vKipcbiogVmFsaWRhdGVzIGlmIGEgZ2l2ZW4gYnVja2V0IG5hbWUgaXMgdmFsaWQgYWNjb3JkaW5nIHRvIFN1cGFiYXNlIFN0b3JhZ2UgQVBJIHJ1bGVzXG4qIE1pcnJvcnMgYmFja2VuZCB2YWxpZGF0aW9uIGZyb206IHN0b3JhZ2Uvc3JjL3N0b3JhZ2UvbGltaXRzLnRzOmlzVmFsaWRCdWNrZXROYW1lKClcbipcbiogUnVsZXM6XG4qIC0gTGVuZ3RoOiAxLTEwMCBjaGFyYWN0ZXJzXG4qIC0gQWxsb3dlZCBjaGFyYWN0ZXJzOiBhbHBoYW51bWVyaWMgKGEteiwgQS1aLCAwLTkpLCB1bmRlcnNjb3JlIChfKSwgYW5kIHNhZmUgc3BlY2lhbCBjaGFyYWN0ZXJzXG4qIC0gU2FmZSBzcGVjaWFsIGNoYXJhY3RlcnM6ICEgLSAuICogJyAoICkgc3BhY2UgJiAkIEAgPSA7IDogKyAsID9cbiogLSBGb3JiaWRkZW46IHBhdGggc2VwYXJhdG9ycyAoLywgXFwpLCBwYXRoIHRyYXZlcnNhbCAoLi4pLCBsZWFkaW5nL3RyYWlsaW5nIHdoaXRlc3BhY2VcbipcbiogQVdTIFMzIFJlZmVyZW5jZTogaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FtYXpvblMzL2xhdGVzdC91c2VyZ3VpZGUvb2JqZWN0LWtleXMuaHRtbFxuKlxuKiBAcGFyYW0gYnVja2V0TmFtZSAtIFRoZSBidWNrZXQgbmFtZSB0byB2YWxpZGF0ZVxuKiBAcmV0dXJucyB0cnVlIGlmIHZhbGlkLCBmYWxzZSBvdGhlcndpc2VcbiovXG5jb25zdCBpc1ZhbGlkQnVja2V0TmFtZSA9IChidWNrZXROYW1lKSA9PiB7XG5cdGlmICghYnVja2V0TmFtZSB8fCB0eXBlb2YgYnVja2V0TmFtZSAhPT0gXCJzdHJpbmdcIikgcmV0dXJuIGZhbHNlO1xuXHRpZiAoYnVja2V0TmFtZS5sZW5ndGggPT09IDAgfHwgYnVja2V0TmFtZS5sZW5ndGggPiAxMDApIHJldHVybiBmYWxzZTtcblx0aWYgKGJ1Y2tldE5hbWUudHJpbSgpICE9PSBidWNrZXROYW1lKSByZXR1cm4gZmFsc2U7XG5cdGlmIChidWNrZXROYW1lLmluY2x1ZGVzKFwiL1wiKSB8fCBidWNrZXROYW1lLmluY2x1ZGVzKFwiXFxcXFwiKSkgcmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gL15bXFx3IS5cXConKCkgJiRAPTs6Kyw/LV0rJC8udGVzdChidWNrZXROYW1lKTtcbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIFxcMEBveGMtcHJvamVjdCtydW50aW1lQDAuMTAxLjAvaGVscGVycy90eXBlb2YuanNcbmZ1bmN0aW9uIF90eXBlb2Yobykge1xuXHRcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cdHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24obyQxKSB7XG5cdFx0cmV0dXJuIHR5cGVvZiBvJDE7XG5cdH0gOiBmdW5jdGlvbihvJDEpIHtcblx0XHRyZXR1cm4gbyQxICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8kMS5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8kMSAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbyQxO1xuXHR9LCBfdHlwZW9mKG8pO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBcXDBAb3hjLXByb2plY3QrcnVudGltZUAwLjEwMS4wL2hlbHBlcnMvdG9QcmltaXRpdmUuanNcbmZ1bmN0aW9uIHRvUHJpbWl0aXZlKHQsIHIpIHtcblx0aWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7XG5cdHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdO1xuXHRpZiAodm9pZCAwICE9PSBlKSB7XG5cdFx0dmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7XG5cdFx0aWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuXHR9XG5cdHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIFxcMEBveGMtcHJvamVjdCtydW50aW1lQDAuMTAxLjAvaGVscGVycy90b1Byb3BlcnR5S2V5LmpzXG5mdW5jdGlvbiB0b1Byb3BlcnR5S2V5KHQpIHtcblx0dmFyIGkgPSB0b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTtcblx0cmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gXFwwQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC4xMDEuMC9oZWxwZXJzL2RlZmluZVByb3BlcnR5LmpzXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkge1xuXHRyZXR1cm4gKHIgPSB0b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHtcblx0XHR2YWx1ZTogdCxcblx0XHRlbnVtZXJhYmxlOiAhMCxcblx0XHRjb25maWd1cmFibGU6ICEwLFxuXHRcdHdyaXRhYmxlOiAhMFxuXHR9KSA6IGVbcl0gPSB0LCBlO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBcXDBAb3hjLXByb2plY3QrcnVudGltZUAwLjEwMS4wL2hlbHBlcnMvb2JqZWN0U3ByZWFkMi5qc1xuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7XG5cdHZhciB0ID0gT2JqZWN0LmtleXMoZSk7XG5cdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0dmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuXHRcdHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbihyJDEpIHtcblx0XHRcdHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIkMSkuZW51bWVyYWJsZTtcblx0XHR9KSksIHQucHVzaC5hcHBseSh0LCBvKTtcblx0fVxuXHRyZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKGUpIHtcblx0Zm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHtcblx0XHR2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307XG5cdFx0ciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24ociQxKSB7XG5cdFx0XHRfZGVmaW5lUHJvcGVydHkoZSwgciQxLCB0W3IkMV0pO1xuXHRcdH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbihyJDEpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByJDEsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgciQxKSk7XG5cdFx0fSk7XG5cdH1cblx0cmV0dXJuIGU7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9saWIvZmV0Y2gudHNcbmNvbnN0IF9nZXRFcnJvck1lc3NhZ2UkMSA9IChlcnIpID0+IHtcblx0dmFyIF9lcnIkZXJyb3I7XG5cdHJldHVybiBlcnIubXNnIHx8IGVyci5tZXNzYWdlIHx8IGVyci5lcnJvcl9kZXNjcmlwdGlvbiB8fCAodHlwZW9mIGVyci5lcnJvciA9PT0gXCJzdHJpbmdcIiA/IGVyci5lcnJvciA6IChfZXJyJGVycm9yID0gZXJyLmVycm9yKSA9PT0gbnVsbCB8fCBfZXJyJGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXJyJGVycm9yLm1lc3NhZ2UpIHx8IEpTT04uc3RyaW5naWZ5KGVycik7XG59O1xuY29uc3QgaGFuZGxlRXJyb3IkMSA9IGFzeW5jIChlcnJvciwgcmVqZWN0LCBvcHRpb25zKSA9PiB7XG5cdGlmIChlcnJvciBpbnN0YW5jZW9mIGF3YWl0IHJlc29sdmVSZXNwb25zZSQxKCkgJiYgIShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubm9SZXNvbHZlSnNvbikpIGVycm9yLmpzb24oKS50aGVuKChlcnIpID0+IHtcblx0XHRjb25zdCBzdGF0dXMgPSBlcnJvci5zdGF0dXMgfHwgNTAwO1xuXHRcdGNvbnN0IHN0YXR1c0NvZGUgPSAoZXJyID09PSBudWxsIHx8IGVyciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyLnN0YXR1c0NvZGUpIHx8IHN0YXR1cyArIFwiXCI7XG5cdFx0cmVqZWN0KG5ldyBTdG9yYWdlQXBpRXJyb3IoX2dldEVycm9yTWVzc2FnZSQxKGVyciksIHN0YXR1cywgc3RhdHVzQ29kZSkpO1xuXHR9KS5jYXRjaCgoZXJyKSA9PiB7XG5cdFx0cmVqZWN0KG5ldyBTdG9yYWdlVW5rbm93bkVycm9yKF9nZXRFcnJvck1lc3NhZ2UkMShlcnIpLCBlcnIpKTtcblx0fSk7XG5cdGVsc2UgcmVqZWN0KG5ldyBTdG9yYWdlVW5rbm93bkVycm9yKF9nZXRFcnJvck1lc3NhZ2UkMShlcnJvciksIGVycm9yKSk7XG59O1xuY29uc3QgX2dldFJlcXVlc3RQYXJhbXMkMSA9IChtZXRob2QsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpID0+IHtcblx0Y29uc3QgcGFyYW1zID0ge1xuXHRcdG1ldGhvZCxcblx0XHRoZWFkZXJzOiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMpIHx8IHt9XG5cdH07XG5cdGlmIChtZXRob2QgPT09IFwiR0VUXCIgfHwgIWJvZHkpIHJldHVybiBwYXJhbXM7XG5cdGlmIChpc1BsYWluT2JqZWN0JDEoYm9keSkpIHtcblx0XHRwYXJhbXMuaGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMpO1xuXHRcdHBhcmFtcy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG5cdH0gZWxzZSBwYXJhbXMuYm9keSA9IGJvZHk7XG5cdGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZHVwbGV4KSBwYXJhbXMuZHVwbGV4ID0gb3B0aW9ucy5kdXBsZXg7XG5cdHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgcGFyYW1zKSwgcGFyYW1ldGVycyk7XG59O1xuYXN5bmMgZnVuY3Rpb24gX2hhbmRsZVJlcXVlc3QkMShmZXRjaGVyLCBtZXRob2QsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSkge1xuXHRyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdGZldGNoZXIodXJsLCBfZ2V0UmVxdWVzdFBhcmFtcyQxKG1ldGhvZCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSkpLnRoZW4oKHJlc3VsdCkgPT4ge1xuXHRcdFx0aWYgKCFyZXN1bHQub2spIHRocm93IHJlc3VsdDtcblx0XHRcdGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubm9SZXNvbHZlSnNvbikgcmV0dXJuIHJlc3VsdDtcblx0XHRcdHJldHVybiByZXN1bHQuanNvbigpO1xuXHRcdH0pLnRoZW4oKGRhdGEpID0+IHJlc29sdmUoZGF0YSkpLmNhdGNoKChlcnJvcikgPT4gaGFuZGxlRXJyb3IkMShlcnJvciwgcmVqZWN0LCBvcHRpb25zKSk7XG5cdH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0KGZldGNoZXIsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycykge1xuXHRyZXR1cm4gX2hhbmRsZVJlcXVlc3QkMShmZXRjaGVyLCBcIkdFVFwiLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMpO1xufVxuYXN5bmMgZnVuY3Rpb24gcG9zdCQxKGZldGNoZXIsIHVybCwgYm9keSwgb3B0aW9ucywgcGFyYW1ldGVycykge1xuXHRyZXR1cm4gX2hhbmRsZVJlcXVlc3QkMShmZXRjaGVyLCBcIlBPU1RcIiwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHB1dChmZXRjaGVyLCB1cmwsIGJvZHksIG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcblx0cmV0dXJuIF9oYW5kbGVSZXF1ZXN0JDEoZmV0Y2hlciwgXCJQVVRcIiwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhlYWQoZmV0Y2hlciwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XG5cdHJldHVybiBfaGFuZGxlUmVxdWVzdCQxKGZldGNoZXIsIFwiSEVBRFwiLCB1cmwsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBvcHRpb25zKSwge30sIHsgbm9SZXNvbHZlSnNvbjogdHJ1ZSB9KSwgcGFyYW1ldGVycyk7XG59XG5hc3luYyBmdW5jdGlvbiByZW1vdmUoZmV0Y2hlciwgdXJsLCBib2R5LCBvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XG5cdHJldHVybiBfaGFuZGxlUmVxdWVzdCQxKGZldGNoZXIsIFwiREVMRVRFXCIsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSk7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9wYWNrYWdlcy9TdHJlYW1Eb3dubG9hZEJ1aWxkZXIudHNcbnZhciBTdHJlYW1Eb3dubG9hZEJ1aWxkZXIgPSBjbGFzcyB7XG5cdGNvbnN0cnVjdG9yKGRvd25sb2FkRm4sIHNob3VsZFRocm93T25FcnJvcikge1xuXHRcdHRoaXMuZG93bmxvYWRGbiA9IGRvd25sb2FkRm47XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSBzaG91bGRUaHJvd09uRXJyb3I7XG5cdH1cblx0dGhlbihvbmZ1bGZpbGxlZCwgb25yZWplY3RlZCkge1xuXHRcdHJldHVybiB0aGlzLmV4ZWN1dGUoKS50aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKTtcblx0fVxuXHRhc3luYyBleGVjdXRlKCkge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IChhd2FpdCBfdGhpcy5kb3dubG9hZEZuKCkpLmJvZHksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvcGFja2FnZXMvQmxvYkRvd25sb2FkQnVpbGRlci50c1xubGV0IF9TeW1ib2wkdG9TdHJpbmdUYWc7XG5fU3ltYm9sJHRvU3RyaW5nVGFnID0gU3ltYm9sLnRvU3RyaW5nVGFnO1xudmFyIEJsb2JEb3dubG9hZEJ1aWxkZXIgPSBjbGFzcyB7XG5cdGNvbnN0cnVjdG9yKGRvd25sb2FkRm4sIHNob3VsZFRocm93T25FcnJvcikge1xuXHRcdHRoaXMuZG93bmxvYWRGbiA9IGRvd25sb2FkRm47XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSBzaG91bGRUaHJvd09uRXJyb3I7XG5cdFx0dGhpc1tfU3ltYm9sJHRvU3RyaW5nVGFnXSA9IFwiQmxvYkRvd25sb2FkQnVpbGRlclwiO1xuXHRcdHRoaXMucHJvbWlzZSA9IG51bGw7XG5cdH1cblx0YXNTdHJlYW0oKSB7XG5cdFx0cmV0dXJuIG5ldyBTdHJlYW1Eb3dubG9hZEJ1aWxkZXIodGhpcy5kb3dubG9hZEZuLCB0aGlzLnNob3VsZFRocm93T25FcnJvcik7XG5cdH1cblx0dGhlbihvbmZ1bGZpbGxlZCwgb25yZWplY3RlZCkge1xuXHRcdHJldHVybiB0aGlzLmdldFByb21pc2UoKS50aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKTtcblx0fVxuXHRjYXRjaChvbnJlamVjdGVkKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UHJvbWlzZSgpLmNhdGNoKG9ucmVqZWN0ZWQpO1xuXHR9XG5cdGZpbmFsbHkob25maW5hbGx5KSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UHJvbWlzZSgpLmZpbmFsbHkob25maW5hbGx5KTtcblx0fVxuXHRnZXRQcm9taXNlKCkge1xuXHRcdGlmICghdGhpcy5wcm9taXNlKSB0aGlzLnByb21pc2UgPSB0aGlzLmV4ZWN1dGUoKTtcblx0XHRyZXR1cm4gdGhpcy5wcm9taXNlO1xuXHR9XG5cdGFzeW5jIGV4ZWN1dGUoKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgKGF3YWl0IF90aGlzLmRvd25sb2FkRm4oKSkuYmxvYigpLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3BhY2thZ2VzL1N0b3JhZ2VGaWxlQXBpLnRzXG5jb25zdCBERUZBVUxUX1NFQVJDSF9PUFRJT05TID0ge1xuXHRsaW1pdDogMTAwLFxuXHRvZmZzZXQ6IDAsXG5cdHNvcnRCeToge1xuXHRcdGNvbHVtbjogXCJuYW1lXCIsXG5cdFx0b3JkZXI6IFwiYXNjXCJcblx0fVxufTtcbmNvbnN0IERFRkFVTFRfRklMRV9PUFRJT05TID0ge1xuXHRjYWNoZUNvbnRyb2w6IFwiMzYwMFwiLFxuXHRjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLThcIixcblx0dXBzZXJ0OiBmYWxzZVxufTtcbnZhciBTdG9yYWdlRmlsZUFwaSA9IGNsYXNzIHtcblx0Y29uc3RydWN0b3IodXJsLCBoZWFkZXJzID0ge30sIGJ1Y2tldElkLCBmZXRjaCQxKSB7XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSBmYWxzZTtcblx0XHR0aGlzLnVybCA9IHVybDtcblx0XHR0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuXHRcdHRoaXMuYnVja2V0SWQgPSBidWNrZXRJZDtcblx0XHR0aGlzLmZldGNoID0gcmVzb2x2ZUZldGNoJDEoZmV0Y2gkMSk7XG5cdH1cblx0LyoqXG5cdCogRW5hYmxlIHRocm93aW5nIGVycm9ycyBpbnN0ZWFkIG9mIHJldHVybmluZyB0aGVtLlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqL1xuXHR0aHJvd09uRXJyb3IoKSB7XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSB0cnVlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIFVwbG9hZHMgYSBmaWxlIHRvIGFuIGV4aXN0aW5nIGJ1Y2tldCBvciByZXBsYWNlcyBhbiBleGlzdGluZyBmaWxlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aCB3aXRoIGEgbmV3IG9uZS5cblx0KlxuXHQqIEBwYXJhbSBtZXRob2QgSFRUUCBtZXRob2QuXG5cdCogQHBhcmFtIHBhdGggVGhlIHJlbGF0aXZlIGZpbGUgcGF0aC4gU2hvdWxkIGJlIG9mIHRoZSBmb3JtYXQgYGZvbGRlci9zdWJmb2xkZXIvZmlsZW5hbWUucG5nYC4gVGhlIGJ1Y2tldCBtdXN0IGFscmVhZHkgZXhpc3QgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdXBsb2FkLlxuXHQqIEBwYXJhbSBmaWxlQm9keSBUaGUgYm9keSBvZiB0aGUgZmlsZSB0byBiZSBzdG9yZWQgaW4gdGhlIGJ1Y2tldC5cblx0Ki9cblx0YXN5bmMgdXBsb2FkT3JVcGRhdGUobWV0aG9kLCBwYXRoLCBmaWxlQm9keSwgZmlsZU9wdGlvbnMpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRsZXQgYm9keTtcblx0XHRcdGNvbnN0IG9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9GSUxFX09QVElPTlMpLCBmaWxlT3B0aW9ucyk7XG5cdFx0XHRsZXQgaGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBfdGhpcy5oZWFkZXJzKSwgbWV0aG9kID09PSBcIlBPU1RcIiAmJiB7IFwieC11cHNlcnRcIjogU3RyaW5nKG9wdGlvbnMudXBzZXJ0KSB9KTtcblx0XHRcdGNvbnN0IG1ldGFkYXRhID0gb3B0aW9ucy5tZXRhZGF0YTtcblx0XHRcdGlmICh0eXBlb2YgQmxvYiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBmaWxlQm9keSBpbnN0YW5jZW9mIEJsb2IpIHtcblx0XHRcdFx0Ym9keSA9IG5ldyBGb3JtRGF0YSgpO1xuXHRcdFx0XHRib2R5LmFwcGVuZChcImNhY2hlQ29udHJvbFwiLCBvcHRpb25zLmNhY2hlQ29udHJvbCk7XG5cdFx0XHRcdGlmIChtZXRhZGF0YSkgYm9keS5hcHBlbmQoXCJtZXRhZGF0YVwiLCBfdGhpcy5lbmNvZGVNZXRhZGF0YShtZXRhZGF0YSkpO1xuXHRcdFx0XHRib2R5LmFwcGVuZChcIlwiLCBmaWxlQm9keSk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBGb3JtRGF0YSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBmaWxlQm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG5cdFx0XHRcdGJvZHkgPSBmaWxlQm9keTtcblx0XHRcdFx0aWYgKCFib2R5LmhhcyhcImNhY2hlQ29udHJvbFwiKSkgYm9keS5hcHBlbmQoXCJjYWNoZUNvbnRyb2xcIiwgb3B0aW9ucy5jYWNoZUNvbnRyb2wpO1xuXHRcdFx0XHRpZiAobWV0YWRhdGEgJiYgIWJvZHkuaGFzKFwibWV0YWRhdGFcIikpIGJvZHkuYXBwZW5kKFwibWV0YWRhdGFcIiwgX3RoaXMuZW5jb2RlTWV0YWRhdGEobWV0YWRhdGEpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJvZHkgPSBmaWxlQm9keTtcblx0XHRcdFx0aGVhZGVyc1tcImNhY2hlLWNvbnRyb2xcIl0gPSBgbWF4LWFnZT0ke29wdGlvbnMuY2FjaGVDb250cm9sfWA7XG5cdFx0XHRcdGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPSBvcHRpb25zLmNvbnRlbnRUeXBlO1xuXHRcdFx0XHRpZiAobWV0YWRhdGEpIGhlYWRlcnNbXCJ4LW1ldGFkYXRhXCJdID0gX3RoaXMudG9CYXNlNjQoX3RoaXMuZW5jb2RlTWV0YWRhdGEobWV0YWRhdGEpKTtcblx0XHRcdFx0aWYgKCh0eXBlb2YgUmVhZGFibGVTdHJlYW0gIT09IFwidW5kZWZpbmVkXCIgJiYgYm9keSBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtIHx8IGJvZHkgJiYgdHlwZW9mIGJvZHkgPT09IFwib2JqZWN0XCIgJiYgXCJwaXBlXCIgaW4gYm9keSAmJiB0eXBlb2YgYm9keS5waXBlID09PSBcImZ1bmN0aW9uXCIpICYmICFvcHRpb25zLmR1cGxleCkgb3B0aW9ucy5kdXBsZXggPSBcImhhbGZcIjtcblx0XHRcdH1cblx0XHRcdGlmIChmaWxlT3B0aW9ucyA9PT0gbnVsbCB8fCBmaWxlT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlsZU9wdGlvbnMuaGVhZGVycykgaGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBoZWFkZXJzKSwgZmlsZU9wdGlvbnMuaGVhZGVycyk7XG5cdFx0XHRjb25zdCBjbGVhblBhdGggPSBfdGhpcy5fcmVtb3ZlRW1wdHlGb2xkZXJzKHBhdGgpO1xuXHRcdFx0Y29uc3QgX3BhdGggPSBfdGhpcy5fZ2V0RmluYWxQYXRoKGNsZWFuUGF0aCk7XG5cdFx0XHRjb25zdCBkYXRhID0gYXdhaXQgKG1ldGhvZCA9PSBcIlBVVFwiID8gcHV0IDogcG9zdCQxKShfdGhpcy5mZXRjaCwgYCR7X3RoaXMudXJsfS9vYmplY3QvJHtfcGF0aH1gLCBib2R5LCBfb2JqZWN0U3ByZWFkMih7IGhlYWRlcnMgfSwgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kdXBsZXgpID8geyBkdXBsZXg6IG9wdGlvbnMuZHVwbGV4IH0gOiB7fSkpO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YToge1xuXHRcdFx0XHRcdHBhdGg6IGNsZWFuUGF0aCxcblx0XHRcdFx0XHRpZDogZGF0YS5JZCxcblx0XHRcdFx0XHRmdWxsUGF0aDogZGF0YS5LZXlcblx0XHRcdFx0fSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqXG5cdCogVXBsb2FkcyBhIGZpbGUgdG8gYW4gZXhpc3RpbmcgYnVja2V0LlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBwYXRoIFRoZSBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgZmlsZSBuYW1lLiBTaG91bGQgYmUgb2YgdGhlIGZvcm1hdCBgZm9sZGVyL3N1YmZvbGRlci9maWxlbmFtZS5wbmdgLiBUaGUgYnVja2V0IG11c3QgYWxyZWFkeSBleGlzdCBiZWZvcmUgYXR0ZW1wdGluZyB0byB1cGxvYWQuXG5cdCogQHBhcmFtIGZpbGVCb2R5IFRoZSBib2R5IG9mIHRoZSBmaWxlIHRvIGJlIHN0b3JlZCBpbiB0aGUgYnVja2V0LlxuXHQqIEBwYXJhbSBmaWxlT3B0aW9ucyBPcHRpb25hbCBmaWxlIHVwbG9hZCBvcHRpb25zIGluY2x1ZGluZyBjYWNoZUNvbnRyb2wsIGNvbnRlbnRUeXBlLCB1cHNlcnQsIGFuZCBtZXRhZGF0YS5cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBmaWxlIHBhdGgsIGlkLCBhbmQgZnVsbFBhdGggb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIFVwbG9hZCBmaWxlXG5cdCogYGBganNcblx0KiBjb25zdCBhdmF0YXJGaWxlID0gZXZlbnQudGFyZ2V0LmZpbGVzWzBdXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAudXBsb2FkKCdwdWJsaWMvYXZhdGFyMS5wbmcnLCBhdmF0YXJGaWxlLCB7XG5cdCogICAgIGNhY2hlQ29udHJvbDogJzM2MDAnLFxuXHQqICAgICB1cHNlcnQ6IGZhbHNlXG5cdCogICB9KVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiB7XG5cdCogICAgIFwicGF0aFwiOiBcInB1YmxpYy9hdmF0YXIxLnBuZ1wiLFxuXHQqICAgICBcImZ1bGxQYXRoXCI6IFwiYXZhdGFycy9wdWJsaWMvYXZhdGFyMS5wbmdcIlxuXHQqICAgfSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0KlxuXHQqIEBleGFtcGxlIFVwbG9hZCBmaWxlIHVzaW5nIGBBcnJheUJ1ZmZlcmAgZnJvbSBiYXNlNjQgZmlsZSBkYXRhXG5cdCogYGBganNcblx0KiBpbXBvcnQgeyBkZWNvZGUgfSBmcm9tICdiYXNlNjQtYXJyYXlidWZmZXInXG5cdCpcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdhdmF0YXJzJylcblx0KiAgIC51cGxvYWQoJ3B1YmxpYy9hdmF0YXIxLnBuZycsIGRlY29kZSgnYmFzZTY0RmlsZURhdGEnKSwge1xuXHQqICAgICBjb250ZW50VHlwZTogJ2ltYWdlL3BuZydcblx0KiAgIH0pXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIHVwbG9hZChwYXRoLCBmaWxlQm9keSwgZmlsZU9wdGlvbnMpIHtcblx0XHRyZXR1cm4gdGhpcy51cGxvYWRPclVwZGF0ZShcIlBPU1RcIiwgcGF0aCwgZmlsZUJvZHksIGZpbGVPcHRpb25zKTtcblx0fVxuXHQvKipcblx0KiBVcGxvYWQgYSBmaWxlIHdpdGggYSB0b2tlbiBnZW5lcmF0ZWQgZnJvbSBgY3JlYXRlU2lnbmVkVXBsb2FkVXJsYC5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gcGF0aCBUaGUgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGZpbGUgbmFtZS4gU2hvdWxkIGJlIG9mIHRoZSBmb3JtYXQgYGZvbGRlci9zdWJmb2xkZXIvZmlsZW5hbWUucG5nYC4gVGhlIGJ1Y2tldCBtdXN0IGFscmVhZHkgZXhpc3QgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdXBsb2FkLlxuXHQqIEBwYXJhbSB0b2tlbiBUaGUgdG9rZW4gZ2VuZXJhdGVkIGZyb20gYGNyZWF0ZVNpZ25lZFVwbG9hZFVybGBcblx0KiBAcGFyYW0gZmlsZUJvZHkgVGhlIGJvZHkgb2YgdGhlIGZpbGUgdG8gYmUgc3RvcmVkIGluIHRoZSBidWNrZXQuXG5cdCogQHBhcmFtIGZpbGVPcHRpb25zIEhUVFAgaGVhZGVycyAoY2FjaGVDb250cm9sLCBjb250ZW50VHlwZSwgZXRjLikuXG5cdCogKipOb3RlOioqIFRoZSBgdXBzZXJ0YCBvcHRpb24gaGFzIG5vIGVmZmVjdCBoZXJlLiBUbyBlbmFibGUgdXBzZXJ0IGJlaGF2aW9yLFxuXHQqIHBhc3MgYHsgdXBzZXJ0OiB0cnVlIH1gIHdoZW4gY2FsbGluZyBgY3JlYXRlU2lnbmVkVXBsb2FkVXJsKClgIGluc3RlYWQuXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgZmlsZSBwYXRoIGFuZCBmdWxsUGF0aCBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgVXBsb2FkIHRvIGEgc2lnbmVkIFVSTFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAudXBsb2FkVG9TaWduZWRVcmwoJ2ZvbGRlci9jYXQuanBnJywgJ3Rva2VuLWZyb20tY3JlYXRlU2lnbmVkVXBsb2FkVXJsJywgZmlsZSlcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjoge1xuXHQqICAgICBcInBhdGhcIjogXCJmb2xkZXIvY2F0LmpwZ1wiLFxuXHQqICAgICBcImZ1bGxQYXRoXCI6IFwiYXZhdGFycy9mb2xkZXIvY2F0LmpwZ1wiXG5cdCogICB9LFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyB1cGxvYWRUb1NpZ25lZFVybChwYXRoLCB0b2tlbiwgZmlsZUJvZHksIGZpbGVPcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzMyA9IHRoaXM7XG5cdFx0Y29uc3QgY2xlYW5QYXRoID0gX3RoaXMzLl9yZW1vdmVFbXB0eUZvbGRlcnMocGF0aCk7XG5cdFx0Y29uc3QgX3BhdGggPSBfdGhpczMuX2dldEZpbmFsUGF0aChjbGVhblBhdGgpO1xuXHRcdGNvbnN0IHVybCA9IG5ldyBVUkwoX3RoaXMzLnVybCArIGAvb2JqZWN0L3VwbG9hZC9zaWduLyR7X3BhdGh9YCk7XG5cdFx0dXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJ0b2tlblwiLCB0b2tlbik7XG5cdFx0dHJ5IHtcblx0XHRcdGxldCBib2R5O1xuXHRcdFx0Y29uc3Qgb3B0aW9ucyA9IF9vYmplY3RTcHJlYWQyKHsgdXBzZXJ0OiBERUZBVUxUX0ZJTEVfT1BUSU9OUy51cHNlcnQgfSwgZmlsZU9wdGlvbnMpO1xuXHRcdFx0Y29uc3QgaGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBfdGhpczMuaGVhZGVycyksIHsgXCJ4LXVwc2VydFwiOiBTdHJpbmcob3B0aW9ucy51cHNlcnQpIH0pO1xuXHRcdFx0aWYgKHR5cGVvZiBCbG9iICE9PSBcInVuZGVmaW5lZFwiICYmIGZpbGVCb2R5IGluc3RhbmNlb2YgQmxvYikge1xuXHRcdFx0XHRib2R5ID0gbmV3IEZvcm1EYXRhKCk7XG5cdFx0XHRcdGJvZHkuYXBwZW5kKFwiY2FjaGVDb250cm9sXCIsIG9wdGlvbnMuY2FjaGVDb250cm9sKTtcblx0XHRcdFx0Ym9keS5hcHBlbmQoXCJcIiwgZmlsZUJvZHkpO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgRm9ybURhdGEgIT09IFwidW5kZWZpbmVkXCIgJiYgZmlsZUJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuXHRcdFx0XHRib2R5ID0gZmlsZUJvZHk7XG5cdFx0XHRcdGJvZHkuYXBwZW5kKFwiY2FjaGVDb250cm9sXCIsIG9wdGlvbnMuY2FjaGVDb250cm9sKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJvZHkgPSBmaWxlQm9keTtcblx0XHRcdFx0aGVhZGVyc1tcImNhY2hlLWNvbnRyb2xcIl0gPSBgbWF4LWFnZT0ke29wdGlvbnMuY2FjaGVDb250cm9sfWA7XG5cdFx0XHRcdGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPSBvcHRpb25zLmNvbnRlbnRUeXBlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YToge1xuXHRcdFx0XHRcdHBhdGg6IGNsZWFuUGF0aCxcblx0XHRcdFx0XHRmdWxsUGF0aDogKGF3YWl0IHB1dChfdGhpczMuZmV0Y2gsIHVybC50b1N0cmluZygpLCBib2R5LCB7IGhlYWRlcnMgfSkpLktleVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzMy5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqXG5cdCogQ3JlYXRlcyBhIHNpZ25lZCB1cGxvYWQgVVJMLlxuXHQqIFNpZ25lZCB1cGxvYWQgVVJMcyBjYW4gYmUgdXNlZCB0byB1cGxvYWQgZmlsZXMgdG8gdGhlIGJ1Y2tldCB3aXRob3V0IGZ1cnRoZXIgYXV0aGVudGljYXRpb24uXG5cdCogVGhleSBhcmUgdmFsaWQgZm9yIDIgaG91cnMuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIHBhdGggVGhlIGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBjdXJyZW50IGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuXHQqIEBwYXJhbSBvcHRpb25zLnVwc2VydCBJZiBzZXQgdG8gdHJ1ZSwgYWxsb3dzIHRoZSBmaWxlIHRvIGJlIG92ZXJ3cml0dGVuIGlmIGl0IGFscmVhZHkgZXhpc3RzLlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIHNpZ25lZCB1cGxvYWQgVVJMLCB0b2tlbiwgYW5kIHBhdGggb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIENyZWF0ZSBTaWduZWQgVXBsb2FkIFVSTFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAuY3JlYXRlU2lnbmVkVXBsb2FkVXJsKCdmb2xkZXIvY2F0LmpwZycpXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IHtcblx0KiAgICAgXCJzaWduZWRVcmxcIjogXCJodHRwczovL2V4YW1wbGUuc3VwYWJhc2UuY28vc3RvcmFnZS92MS9vYmplY3QvdXBsb2FkL3NpZ24vYXZhdGFycy9mb2xkZXIvY2F0LmpwZz90b2tlbj08VE9LRU4+XCIsXG5cdCogICAgIFwicGF0aFwiOiBcImZvbGRlci9jYXQuanBnXCIsXG5cdCogICAgIFwidG9rZW5cIjogXCI8VE9LRU4+XCJcblx0KiAgIH0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGNyZWF0ZVNpZ25lZFVwbG9hZFVybChwYXRoLCBvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzNCA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdGxldCBfcGF0aCA9IF90aGlzNC5fZ2V0RmluYWxQYXRoKHBhdGgpO1xuXHRcdFx0Y29uc3QgaGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKHt9LCBfdGhpczQuaGVhZGVycyk7XG5cdFx0XHRpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnVwc2VydCkgaGVhZGVyc1tcIngtdXBzZXJ0XCJdID0gXCJ0cnVlXCI7XG5cdFx0XHRjb25zdCBkYXRhID0gYXdhaXQgcG9zdCQxKF90aGlzNC5mZXRjaCwgYCR7X3RoaXM0LnVybH0vb2JqZWN0L3VwbG9hZC9zaWduLyR7X3BhdGh9YCwge30sIHsgaGVhZGVycyB9KTtcblx0XHRcdGNvbnN0IHVybCA9IG5ldyBVUkwoX3RoaXM0LnVybCArIGRhdGEudXJsKTtcblx0XHRcdGNvbnN0IHRva2VuID0gdXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJ0b2tlblwiKTtcblx0XHRcdGlmICghdG9rZW4pIHRocm93IG5ldyBTdG9yYWdlRXJyb3IoXCJObyB0b2tlbiByZXR1cm5lZCBieSBBUElcIik7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiB7XG5cdFx0XHRcdFx0c2lnbmVkVXJsOiB1cmwudG9TdHJpbmcoKSxcblx0XHRcdFx0XHRwYXRoLFxuXHRcdFx0XHRcdHRva2VuXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXM0LnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKipcblx0KiBSZXBsYWNlcyBhbiBleGlzdGluZyBmaWxlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aCB3aXRoIGEgbmV3IG9uZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gcGF0aCBUaGUgcmVsYXRpdmUgZmlsZSBwYXRoLiBTaG91bGQgYmUgb2YgdGhlIGZvcm1hdCBgZm9sZGVyL3N1YmZvbGRlci9maWxlbmFtZS5wbmdgLiBUaGUgYnVja2V0IG11c3QgYWxyZWFkeSBleGlzdCBiZWZvcmUgYXR0ZW1wdGluZyB0byB1cGRhdGUuXG5cdCogQHBhcmFtIGZpbGVCb2R5IFRoZSBib2R5IG9mIHRoZSBmaWxlIHRvIGJlIHN0b3JlZCBpbiB0aGUgYnVja2V0LlxuXHQqIEBwYXJhbSBmaWxlT3B0aW9ucyBPcHRpb25hbCBmaWxlIHVwbG9hZCBvcHRpb25zIGluY2x1ZGluZyBjYWNoZUNvbnRyb2wsIGNvbnRlbnRUeXBlLCB1cHNlcnQsIGFuZCBtZXRhZGF0YS5cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBmaWxlIHBhdGgsIGlkLCBhbmQgZnVsbFBhdGggb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIFVwZGF0ZSBmaWxlXG5cdCogYGBganNcblx0KiBjb25zdCBhdmF0YXJGaWxlID0gZXZlbnQudGFyZ2V0LmZpbGVzWzBdXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAudXBkYXRlKCdwdWJsaWMvYXZhdGFyMS5wbmcnLCBhdmF0YXJGaWxlLCB7XG5cdCogICAgIGNhY2hlQ29udHJvbDogJzM2MDAnLFxuXHQqICAgICB1cHNlcnQ6IHRydWVcblx0KiAgIH0pXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IHtcblx0KiAgICAgXCJwYXRoXCI6IFwicHVibGljL2F2YXRhcjEucG5nXCIsXG5cdCogICAgIFwiZnVsbFBhdGhcIjogXCJhdmF0YXJzL3B1YmxpYy9hdmF0YXIxLnBuZ1wiXG5cdCogICB9LFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqXG5cdCogQGV4YW1wbGUgVXBkYXRlIGZpbGUgdXNpbmcgYEFycmF5QnVmZmVyYCBmcm9tIGJhc2U2NCBmaWxlIGRhdGFcblx0KiBgYGBqc1xuXHQqIGltcG9ydCB7ZGVjb2RlfSBmcm9tICdiYXNlNjQtYXJyYXlidWZmZXInXG5cdCpcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdhdmF0YXJzJylcblx0KiAgIC51cGRhdGUoJ3B1YmxpYy9hdmF0YXIxLnBuZycsIGRlY29kZSgnYmFzZTY0RmlsZURhdGEnKSwge1xuXHQqICAgICBjb250ZW50VHlwZTogJ2ltYWdlL3BuZydcblx0KiAgIH0pXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIHVwZGF0ZShwYXRoLCBmaWxlQm9keSwgZmlsZU9wdGlvbnMpIHtcblx0XHRyZXR1cm4gdGhpcy51cGxvYWRPclVwZGF0ZShcIlBVVFwiLCBwYXRoLCBmaWxlQm9keSwgZmlsZU9wdGlvbnMpO1xuXHR9XG5cdC8qKlxuXHQqIE1vdmVzIGFuIGV4aXN0aW5nIGZpbGUgdG8gYSBuZXcgcGF0aCBpbiB0aGUgc2FtZSBidWNrZXQuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIGZyb21QYXRoIFRoZSBvcmlnaW5hbCBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgY3VycmVudCBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UucG5nYC5cblx0KiBAcGFyYW0gdG9QYXRoIFRoZSBuZXcgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIG5ldyBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UtbmV3LnBuZ2AuXG5cdCogQHBhcmFtIG9wdGlvbnMgVGhlIGRlc3RpbmF0aW9uIG9wdGlvbnMuXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgc3VjY2VzcyBtZXNzYWdlIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBNb3ZlIGZpbGVcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLm1vdmUoJ3B1YmxpYy9hdmF0YXIxLnBuZycsICdwcml2YXRlL2F2YXRhcjIucG5nJylcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjoge1xuXHQqICAgICBcIm1lc3NhZ2VcIjogXCJTdWNjZXNzZnVsbHkgbW92ZWRcIlxuXHQqICAgfSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgbW92ZShmcm9tUGF0aCwgdG9QYXRoLCBvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzNiA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHBvc3QkMShfdGhpczYuZmV0Y2gsIGAke190aGlzNi51cmx9L29iamVjdC9tb3ZlYCwge1xuXHRcdFx0XHRcdGJ1Y2tldElkOiBfdGhpczYuYnVja2V0SWQsXG5cdFx0XHRcdFx0c291cmNlS2V5OiBmcm9tUGF0aCxcblx0XHRcdFx0XHRkZXN0aW5hdGlvbktleTogdG9QYXRoLFxuXHRcdFx0XHRcdGRlc3RpbmF0aW9uQnVja2V0OiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVzdGluYXRpb25CdWNrZXRcblx0XHRcdFx0fSwgeyBoZWFkZXJzOiBfdGhpczYuaGVhZGVycyB9KSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczYuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQqIENvcGllcyBhbiBleGlzdGluZyBmaWxlIHRvIGEgbmV3IHBhdGggaW4gdGhlIHNhbWUgYnVja2V0LlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBmcm9tUGF0aCBUaGUgb3JpZ2luYWwgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG5cdCogQHBhcmFtIHRvUGF0aCBUaGUgbmV3IGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBuZXcgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLWNvcHkucG5nYC5cblx0KiBAcGFyYW0gb3B0aW9ucyBUaGUgZGVzdGluYXRpb24gb3B0aW9ucy5cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBjb3BpZWQgZmlsZSBwYXRoIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBDb3B5IGZpbGVcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmNvcHkoJ3B1YmxpYy9hdmF0YXIxLnBuZycsICdwcml2YXRlL2F2YXRhcjIucG5nJylcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjoge1xuXHQqICAgICBcInBhdGhcIjogXCJhdmF0YXJzL3ByaXZhdGUvYXZhdGFyMi5wbmdcIlxuXHQqICAgfSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgY29weShmcm9tUGF0aCwgdG9QYXRoLCBvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzNyA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IHsgcGF0aDogKGF3YWl0IHBvc3QkMShfdGhpczcuZmV0Y2gsIGAke190aGlzNy51cmx9L29iamVjdC9jb3B5YCwge1xuXHRcdFx0XHRcdGJ1Y2tldElkOiBfdGhpczcuYnVja2V0SWQsXG5cdFx0XHRcdFx0c291cmNlS2V5OiBmcm9tUGF0aCxcblx0XHRcdFx0XHRkZXN0aW5hdGlvbktleTogdG9QYXRoLFxuXHRcdFx0XHRcdGRlc3RpbmF0aW9uQnVja2V0OiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVzdGluYXRpb25CdWNrZXRcblx0XHRcdFx0fSwgeyBoZWFkZXJzOiBfdGhpczcuaGVhZGVycyB9KSkuS2V5IH0sXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXM3LnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKipcblx0KiBDcmVhdGVzIGEgc2lnbmVkIFVSTC4gVXNlIGEgc2lnbmVkIFVSTCB0byBzaGFyZSBhIGZpbGUgZm9yIGEgZml4ZWQgYW1vdW50IG9mIHRpbWUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIHBhdGggVGhlIGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBjdXJyZW50IGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuXHQqIEBwYXJhbSBleHBpcmVzSW4gVGhlIG51bWJlciBvZiBzZWNvbmRzIHVudGlsIHRoZSBzaWduZWQgVVJMIGV4cGlyZXMuIEZvciBleGFtcGxlLCBgNjBgIGZvciBhIFVSTCB3aGljaCBpcyB2YWxpZCBmb3Igb25lIG1pbnV0ZS5cblx0KiBAcGFyYW0gb3B0aW9ucy5kb3dubG9hZCB0cmlnZ2VycyB0aGUgZmlsZSBhcyBhIGRvd25sb2FkIGlmIHNldCB0byB0cnVlLiBTZXQgdGhpcyBwYXJhbWV0ZXIgYXMgdGhlIG5hbWUgb2YgdGhlIGZpbGUgaWYgeW91IHdhbnQgdG8gdHJpZ2dlciB0aGUgZG93bmxvYWQgd2l0aCBhIGRpZmZlcmVudCBmaWxlbmFtZS5cblx0KiBAcGFyYW0gb3B0aW9ucy50cmFuc2Zvcm0gVHJhbnNmb3JtIHRoZSBhc3NldCBiZWZvcmUgc2VydmluZyBpdCB0byB0aGUgY2xpZW50LlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIHNpZ25lZCBVUkwgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIENyZWF0ZSBTaWduZWQgVVJMXG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdhdmF0YXJzJylcblx0KiAgIC5jcmVhdGVTaWduZWRVcmwoJ2ZvbGRlci9hdmF0YXIxLnBuZycsIDYwKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiB7XG5cdCogICAgIFwic2lnbmVkVXJsXCI6IFwiaHR0cHM6Ly9leGFtcGxlLnN1cGFiYXNlLmNvL3N0b3JhZ2UvdjEvb2JqZWN0L3NpZ24vYXZhdGFycy9mb2xkZXIvYXZhdGFyMS5wbmc/dG9rZW49PFRPS0VOPlwiXG5cdCogICB9LFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqXG5cdCogQGV4YW1wbGUgQ3JlYXRlIGEgc2lnbmVkIFVSTCBmb3IgYW4gYXNzZXQgd2l0aCB0cmFuc2Zvcm1hdGlvbnNcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAuY3JlYXRlU2lnbmVkVXJsKCdmb2xkZXIvYXZhdGFyMS5wbmcnLCA2MCwge1xuXHQqICAgICB0cmFuc2Zvcm06IHtcblx0KiAgICAgICB3aWR0aDogMTAwLFxuXHQqICAgICAgIGhlaWdodDogMTAwLFxuXHQqICAgICB9XG5cdCogICB9KVxuXHQqIGBgYFxuXHQqXG5cdCogQGV4YW1wbGUgQ3JlYXRlIGEgc2lnbmVkIFVSTCB3aGljaCB0cmlnZ2VycyB0aGUgZG93bmxvYWQgb2YgdGhlIGFzc2V0XG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmNyZWF0ZVNpZ25lZFVybCgnZm9sZGVyL2F2YXRhcjEucG5nJywgNjAsIHtcblx0KiAgICAgZG93bmxvYWQ6IHRydWUsXG5cdCogICB9KVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBjcmVhdGVTaWduZWRVcmwocGF0aCwgZXhwaXJlc0luLCBvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzOCA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdGxldCBfcGF0aCA9IF90aGlzOC5fZ2V0RmluYWxQYXRoKHBhdGgpO1xuXHRcdFx0bGV0IGRhdGEgPSBhd2FpdCBwb3N0JDEoX3RoaXM4LmZldGNoLCBgJHtfdGhpczgudXJsfS9vYmplY3Qvc2lnbi8ke19wYXRofWAsIF9vYmplY3RTcHJlYWQyKHsgZXhwaXJlc0luIH0sIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhbnNmb3JtKSA/IHsgdHJhbnNmb3JtOiBvcHRpb25zLnRyYW5zZm9ybSB9IDoge30pLCB7IGhlYWRlcnM6IF90aGlzOC5oZWFkZXJzIH0pO1xuXHRcdFx0Y29uc3QgZG93bmxvYWRRdWVyeVBhcmFtID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kb3dubG9hZCkgPyBgJmRvd25sb2FkPSR7b3B0aW9ucy5kb3dubG9hZCA9PT0gdHJ1ZSA/IFwiXCIgOiBvcHRpb25zLmRvd25sb2FkfWAgOiBcIlwiO1xuXHRcdFx0ZGF0YSA9IHsgc2lnbmVkVXJsOiBlbmNvZGVVUkkoYCR7X3RoaXM4LnVybH0ke2RhdGEuc2lnbmVkVVJMfSR7ZG93bmxvYWRRdWVyeVBhcmFtfWApIH07XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzOC5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqXG5cdCogQ3JlYXRlcyBtdWx0aXBsZSBzaWduZWQgVVJMcy4gVXNlIGEgc2lnbmVkIFVSTCB0byBzaGFyZSBhIGZpbGUgZm9yIGEgZml4ZWQgYW1vdW50IG9mIHRpbWUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIHBhdGhzIFRoZSBmaWxlIHBhdGhzIHRvIGJlIGRvd25sb2FkZWQsIGluY2x1ZGluZyB0aGUgY3VycmVudCBmaWxlIG5hbWVzLiBGb3IgZXhhbXBsZSBgWydmb2xkZXIvaW1hZ2UucG5nJywgJ2ZvbGRlcjIvaW1hZ2UyLnBuZyddYC5cblx0KiBAcGFyYW0gZXhwaXJlc0luIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyB1bnRpbCB0aGUgc2lnbmVkIFVSTHMgZXhwaXJlLiBGb3IgZXhhbXBsZSwgYDYwYCBmb3IgVVJMcyB3aGljaCBhcmUgdmFsaWQgZm9yIG9uZSBtaW51dGUuXG5cdCogQHBhcmFtIG9wdGlvbnMuZG93bmxvYWQgdHJpZ2dlcnMgdGhlIGZpbGUgYXMgYSBkb3dubG9hZCBpZiBzZXQgdG8gdHJ1ZS4gU2V0IHRoaXMgcGFyYW1ldGVyIGFzIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGlmIHlvdSB3YW50IHRvIHRyaWdnZXIgdGhlIGRvd25sb2FkIHdpdGggYSBkaWZmZXJlbnQgZmlsZW5hbWUuXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIHNpZ25lZFVybCwgcGF0aCwgYW5kIGVycm9yIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBDcmVhdGUgU2lnbmVkIFVSTHNcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmNyZWF0ZVNpZ25lZFVybHMoWydmb2xkZXIvYXZhdGFyMS5wbmcnLCAnZm9sZGVyL2F2YXRhcjIucG5nJ10sIDYwKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiBbXG5cdCogICAgIHtcblx0KiAgICAgICBcImVycm9yXCI6IG51bGwsXG5cdCogICAgICAgXCJwYXRoXCI6IFwiZm9sZGVyL2F2YXRhcjEucG5nXCIsXG5cdCogICAgICAgXCJzaWduZWRVUkxcIjogXCIvb2JqZWN0L3NpZ24vYXZhdGFycy9mb2xkZXIvYXZhdGFyMS5wbmc/dG9rZW49PFRPS0VOPlwiLFxuXHQqICAgICAgIFwic2lnbmVkVXJsXCI6IFwiaHR0cHM6Ly9leGFtcGxlLnN1cGFiYXNlLmNvL3N0b3JhZ2UvdjEvb2JqZWN0L3NpZ24vYXZhdGFycy9mb2xkZXIvYXZhdGFyMS5wbmc/dG9rZW49PFRPS0VOPlwiXG5cdCogICAgIH0sXG5cdCogICAgIHtcblx0KiAgICAgICBcImVycm9yXCI6IG51bGwsXG5cdCogICAgICAgXCJwYXRoXCI6IFwiZm9sZGVyL2F2YXRhcjIucG5nXCIsXG5cdCogICAgICAgXCJzaWduZWRVUkxcIjogXCIvb2JqZWN0L3NpZ24vYXZhdGFycy9mb2xkZXIvYXZhdGFyMi5wbmc/dG9rZW49PFRPS0VOPlwiLFxuXHQqICAgICAgIFwic2lnbmVkVXJsXCI6IFwiaHR0cHM6Ly9leGFtcGxlLnN1cGFiYXNlLmNvL3N0b3JhZ2UvdjEvb2JqZWN0L3NpZ24vYXZhdGFycy9mb2xkZXIvYXZhdGFyMi5wbmc/dG9rZW49PFRPS0VOPlwiXG5cdCogICAgIH1cblx0KiAgIF0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGNyZWF0ZVNpZ25lZFVybHMocGF0aHMsIGV4cGlyZXNJbiwgb3B0aW9ucykge1xuXHRcdHZhciBfdGhpczkgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBkYXRhID0gYXdhaXQgcG9zdCQxKF90aGlzOS5mZXRjaCwgYCR7X3RoaXM5LnVybH0vb2JqZWN0L3NpZ24vJHtfdGhpczkuYnVja2V0SWR9YCwge1xuXHRcdFx0XHRleHBpcmVzSW4sXG5cdFx0XHRcdHBhdGhzXG5cdFx0XHR9LCB7IGhlYWRlcnM6IF90aGlzOS5oZWFkZXJzIH0pO1xuXHRcdFx0Y29uc3QgZG93bmxvYWRRdWVyeVBhcmFtID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kb3dubG9hZCkgPyBgJmRvd25sb2FkPSR7b3B0aW9ucy5kb3dubG9hZCA9PT0gdHJ1ZSA/IFwiXCIgOiBvcHRpb25zLmRvd25sb2FkfWAgOiBcIlwiO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogZGF0YS5tYXAoKGRhdHVtKSA9PiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZGF0dW0pLCB7fSwgeyBzaWduZWRVcmw6IGRhdHVtLnNpZ25lZFVSTCA/IGVuY29kZVVSSShgJHtfdGhpczkudXJsfSR7ZGF0dW0uc2lnbmVkVVJMfSR7ZG93bmxvYWRRdWVyeVBhcmFtfWApIDogbnVsbCB9KSksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXM5LnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKipcblx0KiBEb3dubG9hZHMgYSBmaWxlIGZyb20gYSBwcml2YXRlIGJ1Y2tldC4gRm9yIHB1YmxpYyBidWNrZXRzLCBtYWtlIGEgcmVxdWVzdCB0byB0aGUgVVJMIHJldHVybmVkIGZyb20gYGdldFB1YmxpY1VybGAgaW5zdGVhZC5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gcGF0aCBUaGUgZnVsbCBwYXRoIGFuZCBmaWxlIG5hbWUgb2YgdGhlIGZpbGUgdG8gYmUgZG93bmxvYWRlZC4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuXHQqIEBwYXJhbSBvcHRpb25zLnRyYW5zZm9ybSBUcmFuc2Zvcm0gdGhlIGFzc2V0IGJlZm9yZSBzZXJ2aW5nIGl0IHRvIHRoZSBjbGllbnQuXG5cdCogQHJldHVybnMgQmxvYkRvd25sb2FkQnVpbGRlciBpbnN0YW5jZSBmb3IgZG93bmxvYWRpbmcgdGhlIGZpbGVcblx0KlxuXHQqIEBleGFtcGxlIERvd25sb2FkIGZpbGVcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmRvd25sb2FkKCdmb2xkZXIvYXZhdGFyMS5wbmcnKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiA8QkxPQj4sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCpcblx0KiBAZXhhbXBsZSBEb3dubG9hZCBmaWxlIHdpdGggdHJhbnNmb3JtYXRpb25zXG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdhdmF0YXJzJylcblx0KiAgIC5kb3dubG9hZCgnZm9sZGVyL2F2YXRhcjEucG5nJywge1xuXHQqICAgICB0cmFuc2Zvcm06IHtcblx0KiAgICAgICB3aWR0aDogMTAwLFxuXHQqICAgICAgIGhlaWdodDogMTAwLFxuXHQqICAgICAgIHF1YWxpdHk6IDgwXG5cdCogICAgIH1cblx0KiAgIH0pXG5cdCogYGBgXG5cdCovXG5cdGRvd25sb2FkKHBhdGgsIG9wdGlvbnMpIHtcblx0XHRjb25zdCByZW5kZXJQYXRoID0gdHlwZW9mIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhbnNmb3JtKSAhPT0gXCJ1bmRlZmluZWRcIiA/IFwicmVuZGVyL2ltYWdlL2F1dGhlbnRpY2F0ZWRcIiA6IFwib2JqZWN0XCI7XG5cdFx0Y29uc3QgdHJhbnNmb3JtYXRpb25RdWVyeSA9IHRoaXMudHJhbnNmb3JtT3B0c1RvUXVlcnlTdHJpbmcoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50cmFuc2Zvcm0pIHx8IHt9KTtcblx0XHRjb25zdCBxdWVyeVN0cmluZyA9IHRyYW5zZm9ybWF0aW9uUXVlcnkgPyBgPyR7dHJhbnNmb3JtYXRpb25RdWVyeX1gIDogXCJcIjtcblx0XHRjb25zdCBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChwYXRoKTtcblx0XHRjb25zdCBkb3dubG9hZEZuID0gKCkgPT4gZ2V0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS8ke3JlbmRlclBhdGh9LyR7X3BhdGh9JHtxdWVyeVN0cmluZ31gLCB7XG5cdFx0XHRoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG5cdFx0XHRub1Jlc29sdmVKc29uOiB0cnVlXG5cdFx0fSk7XG5cdFx0cmV0dXJuIG5ldyBCbG9iRG93bmxvYWRCdWlsZGVyKGRvd25sb2FkRm4sIHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yKTtcblx0fVxuXHQvKipcblx0KiBSZXRyaWV2ZXMgdGhlIGRldGFpbHMgb2YgYW4gZXhpc3RpbmcgZmlsZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gcGF0aCBUaGUgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIGZpbGUgbWV0YWRhdGEgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIEdldCBmaWxlIGluZm9cblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmluZm8oJ2ZvbGRlci9hdmF0YXIxLnBuZycpXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGluZm8ocGF0aCkge1xuXHRcdHZhciBfdGhpczEwID0gdGhpcztcblx0XHRjb25zdCBfcGF0aCA9IF90aGlzMTAuX2dldEZpbmFsUGF0aChwYXRoKTtcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogcmVjdXJzaXZlVG9DYW1lbChhd2FpdCBnZXQoX3RoaXMxMC5mZXRjaCwgYCR7X3RoaXMxMC51cmx9L29iamVjdC9pbmZvLyR7X3BhdGh9YCwgeyBoZWFkZXJzOiBfdGhpczEwLmhlYWRlcnMgfSkpLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzMTAuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQqIENoZWNrcyB0aGUgZXhpc3RlbmNlIG9mIGEgZmlsZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gcGF0aCBUaGUgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIGJvb2xlYW4gaW5kaWNhdGluZyBmaWxlIGV4aXN0ZW5jZSBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgQ2hlY2sgZmlsZSBleGlzdGVuY2Vcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmV4aXN0cygnZm9sZGVyL2F2YXRhcjEucG5nJylcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgZXhpc3RzKHBhdGgpIHtcblx0XHR2YXIgX3RoaXMxMSA9IHRoaXM7XG5cdFx0Y29uc3QgX3BhdGggPSBfdGhpczExLl9nZXRGaW5hbFBhdGgocGF0aCk7XG5cdFx0dHJ5IHtcblx0XHRcdGF3YWl0IGhlYWQoX3RoaXMxMS5mZXRjaCwgYCR7X3RoaXMxMS51cmx9L29iamVjdC8ke19wYXRofWAsIHsgaGVhZGVyczogX3RoaXMxMS5oZWFkZXJzIH0pO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogdHJ1ZSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczExLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpICYmIGVycm9yIGluc3RhbmNlb2YgU3RvcmFnZVVua25vd25FcnJvcikge1xuXHRcdFx0XHRjb25zdCBvcmlnaW5hbEVycm9yID0gZXJyb3Iub3JpZ2luYWxFcnJvcjtcblx0XHRcdFx0aWYgKFs0MDAsIDQwNF0uaW5jbHVkZXMob3JpZ2luYWxFcnJvciA9PT0gbnVsbCB8fCBvcmlnaW5hbEVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbEVycm9yLnN0YXR1cykpIHJldHVybiB7XG5cdFx0XHRcdFx0ZGF0YTogZmFsc2UsXG5cdFx0XHRcdFx0ZXJyb3Jcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKipcblx0KiBBIHNpbXBsZSBjb252ZW5pZW5jZSBmdW5jdGlvbiB0byBnZXQgdGhlIFVSTCBmb3IgYW4gYXNzZXQgaW4gYSBwdWJsaWMgYnVja2V0LiBJZiB5b3UgZG8gbm90IHdhbnQgdG8gdXNlIHRoaXMgZnVuY3Rpb24sIHlvdSBjYW4gY29uc3RydWN0IHRoZSBwdWJsaWMgVVJMIGJ5IGNvbmNhdGVuYXRpbmcgdGhlIGJ1Y2tldCBVUkwgd2l0aCB0aGUgcGF0aCB0byB0aGUgYXNzZXQuXG5cdCogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCB2ZXJpZnkgaWYgdGhlIGJ1Y2tldCBpcyBwdWJsaWMuIElmIGEgcHVibGljIFVSTCBpcyBjcmVhdGVkIGZvciBhIGJ1Y2tldCB3aGljaCBpcyBub3QgcHVibGljLCB5b3Ugd2lsbCBub3QgYmUgYWJsZSB0byBkb3dubG9hZCB0aGUgYXNzZXQuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIHBhdGggVGhlIHBhdGggYW5kIG5hbWUgb2YgdGhlIGZpbGUgdG8gZ2VuZXJhdGUgdGhlIHB1YmxpYyBVUkwgZm9yLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG5cdCogQHBhcmFtIG9wdGlvbnMuZG93bmxvYWQgVHJpZ2dlcnMgdGhlIGZpbGUgYXMgYSBkb3dubG9hZCBpZiBzZXQgdG8gdHJ1ZS4gU2V0IHRoaXMgcGFyYW1ldGVyIGFzIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGlmIHlvdSB3YW50IHRvIHRyaWdnZXIgdGhlIGRvd25sb2FkIHdpdGggYSBkaWZmZXJlbnQgZmlsZW5hbWUuXG5cdCogQHBhcmFtIG9wdGlvbnMudHJhbnNmb3JtIFRyYW5zZm9ybSB0aGUgYXNzZXQgYmVmb3JlIHNlcnZpbmcgaXQgdG8gdGhlIGNsaWVudC5cblx0KiBAcmV0dXJucyBPYmplY3Qgd2l0aCBwdWJsaWMgVVJMXG5cdCpcblx0KiBAZXhhbXBsZSBSZXR1cm5zIHRoZSBVUkwgZm9yIGFuIGFzc2V0IGluIGEgcHVibGljIGJ1Y2tldFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhIH0gPSBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdwdWJsaWMtYnVja2V0Jylcblx0KiAgIC5nZXRQdWJsaWNVcmwoJ2ZvbGRlci9hdmF0YXIxLnBuZycpXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IHtcblx0KiAgICAgXCJwdWJsaWNVcmxcIjogXCJodHRwczovL2V4YW1wbGUuc3VwYWJhc2UuY28vc3RvcmFnZS92MS9vYmplY3QvcHVibGljL3B1YmxpYy1idWNrZXQvZm9sZGVyL2F2YXRhcjEucG5nXCJcblx0KiAgIH1cblx0KiB9XG5cdCogYGBgXG5cdCpcblx0KiBAZXhhbXBsZSBSZXR1cm5zIHRoZSBVUkwgZm9yIGFuIGFzc2V0IGluIGEgcHVibGljIGJ1Y2tldCB3aXRoIHRyYW5zZm9ybWF0aW9uc1xuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhIH0gPSBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdwdWJsaWMtYnVja2V0Jylcblx0KiAgIC5nZXRQdWJsaWNVcmwoJ2ZvbGRlci9hdmF0YXIxLnBuZycsIHtcblx0KiAgICAgdHJhbnNmb3JtOiB7XG5cdCogICAgICAgd2lkdGg6IDEwMCxcblx0KiAgICAgICBoZWlnaHQ6IDEwMCxcblx0KiAgICAgfVxuXHQqICAgfSlcblx0KiBgYGBcblx0KlxuXHQqIEBleGFtcGxlIFJldHVybnMgdGhlIFVSTCB3aGljaCB0cmlnZ2VycyB0aGUgZG93bmxvYWQgb2YgYW4gYXNzZXQgaW4gYSBwdWJsaWMgYnVja2V0XG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEgfSA9IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ3B1YmxpYy1idWNrZXQnKVxuXHQqICAgLmdldFB1YmxpY1VybCgnZm9sZGVyL2F2YXRhcjEucG5nJywge1xuXHQqICAgICBkb3dubG9hZDogdHJ1ZSxcblx0KiAgIH0pXG5cdCogYGBgXG5cdCovXG5cdGdldFB1YmxpY1VybChwYXRoLCBvcHRpb25zKSB7XG5cdFx0Y29uc3QgX3BhdGggPSB0aGlzLl9nZXRGaW5hbFBhdGgocGF0aCk7XG5cdFx0Y29uc3QgX3F1ZXJ5U3RyaW5nID0gW107XG5cdFx0Y29uc3QgZG93bmxvYWRRdWVyeVBhcmFtID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kb3dubG9hZCkgPyBgZG93bmxvYWQ9JHtvcHRpb25zLmRvd25sb2FkID09PSB0cnVlID8gXCJcIiA6IG9wdGlvbnMuZG93bmxvYWR9YCA6IFwiXCI7XG5cdFx0aWYgKGRvd25sb2FkUXVlcnlQYXJhbSAhPT0gXCJcIikgX3F1ZXJ5U3RyaW5nLnB1c2goZG93bmxvYWRRdWVyeVBhcmFtKTtcblx0XHRjb25zdCByZW5kZXJQYXRoID0gdHlwZW9mIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhbnNmb3JtKSAhPT0gXCJ1bmRlZmluZWRcIiA/IFwicmVuZGVyL2ltYWdlXCIgOiBcIm9iamVjdFwiO1xuXHRcdGNvbnN0IHRyYW5zZm9ybWF0aW9uUXVlcnkgPSB0aGlzLnRyYW5zZm9ybU9wdHNUb1F1ZXJ5U3RyaW5nKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhbnNmb3JtKSB8fCB7fSk7XG5cdFx0aWYgKHRyYW5zZm9ybWF0aW9uUXVlcnkgIT09IFwiXCIpIF9xdWVyeVN0cmluZy5wdXNoKHRyYW5zZm9ybWF0aW9uUXVlcnkpO1xuXHRcdGxldCBxdWVyeVN0cmluZyA9IF9xdWVyeVN0cmluZy5qb2luKFwiJlwiKTtcblx0XHRpZiAocXVlcnlTdHJpbmcgIT09IFwiXCIpIHF1ZXJ5U3RyaW5nID0gYD8ke3F1ZXJ5U3RyaW5nfWA7XG5cdFx0cmV0dXJuIHsgZGF0YTogeyBwdWJsaWNVcmw6IGVuY29kZVVSSShgJHt0aGlzLnVybH0vJHtyZW5kZXJQYXRofS9wdWJsaWMvJHtfcGF0aH0ke3F1ZXJ5U3RyaW5nfWApIH0gfTtcblx0fVxuXHQvKipcblx0KiBEZWxldGVzIGZpbGVzIHdpdGhpbiB0aGUgc2FtZSBidWNrZXRcblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gcGF0aHMgQW4gYXJyYXkgb2YgZmlsZXMgdG8gZGVsZXRlLCBpbmNsdWRpbmcgdGhlIHBhdGggYW5kIGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgW2AnZm9sZGVyL2ltYWdlLnBuZydgXS5cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBhcnJheSBvZiBkZWxldGVkIGZpbGUgb2JqZWN0cyBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgRGVsZXRlIGZpbGVcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLnJlbW92ZShbJ2ZvbGRlci9hdmF0YXIxLnBuZyddKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiBbXSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgcmVtb3ZlKHBhdGhzKSB7XG5cdFx0dmFyIF90aGlzMTIgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCByZW1vdmUoX3RoaXMxMi5mZXRjaCwgYCR7X3RoaXMxMi51cmx9L29iamVjdC8ke190aGlzMTIuYnVja2V0SWR9YCwgeyBwcmVmaXhlczogcGF0aHMgfSwgeyBoZWFkZXJzOiBfdGhpczEyLmhlYWRlcnMgfSksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMxMi5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqXG5cdCogR2V0IGZpbGUgbWV0YWRhdGFcblx0KiBAcGFyYW0gaWQgdGhlIGZpbGUgaWQgdG8gcmV0cmlldmUgbWV0YWRhdGFcblx0Ki9cblx0LyoqXG5cdCogVXBkYXRlIGZpbGUgbWV0YWRhdGFcblx0KiBAcGFyYW0gaWQgdGhlIGZpbGUgaWQgdG8gdXBkYXRlIG1ldGFkYXRhXG5cdCogQHBhcmFtIG1ldGEgdGhlIG5ldyBmaWxlIG1ldGFkYXRhXG5cdCovXG5cdC8qKlxuXHQqIExpc3RzIGFsbCB0aGUgZmlsZXMgYW5kIGZvbGRlcnMgd2l0aGluIGEgcGF0aCBvZiB0aGUgYnVja2V0LlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBwYXRoIFRoZSBmb2xkZXIgcGF0aC5cblx0KiBAcGFyYW0gb3B0aW9ucyBTZWFyY2ggb3B0aW9ucyBpbmNsdWRpbmcgbGltaXQgKGRlZmF1bHRzIHRvIDEwMCksIG9mZnNldCwgc29ydEJ5LCBhbmQgc2VhcmNoXG5cdCogQHBhcmFtIHBhcmFtZXRlcnMgT3B0aW9uYWwgZmV0Y2ggcGFyYW1ldGVycyBpbmNsdWRpbmcgc2lnbmFsIGZvciBjYW5jZWxsYXRpb25cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBhcnJheSBvZiBmaWxlcyBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgTGlzdCBmaWxlcyBpbiBhIGJ1Y2tldFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAubGlzdCgnZm9sZGVyJywge1xuXHQqICAgICBsaW1pdDogMTAwLFxuXHQqICAgICBvZmZzZXQ6IDAsXG5cdCogICAgIHNvcnRCeTogeyBjb2x1bW46ICduYW1lJywgb3JkZXI6ICdhc2MnIH0sXG5cdCogICB9KVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiBbXG5cdCogICAgIHtcblx0KiAgICAgICBcIm5hbWVcIjogXCJhdmF0YXIxLnBuZ1wiLFxuXHQqICAgICAgIFwiaWRcIjogXCJlNjY4Y2Y3Zi04MjFiLTRhMmYtOWRjZS03ZGZhNWRkMWNmZDJcIixcblx0KiAgICAgICBcInVwZGF0ZWRfYXRcIjogXCIyMDI0LTA1LTIyVDIzOjA2OjA1LjU4MFpcIixcblx0KiAgICAgICBcImNyZWF0ZWRfYXRcIjogXCIyMDI0LTA1LTIyVDIzOjA0OjM0LjQ0M1pcIixcblx0KiAgICAgICBcImxhc3RfYWNjZXNzZWRfYXRcIjogXCIyMDI0LTA1LTIyVDIzOjA0OjM0LjQ0M1pcIixcblx0KiAgICAgICBcIm1ldGFkYXRhXCI6IHtcblx0KiAgICAgICAgIFwiZVRhZ1wiOiBcIlxcXCJjNWU4YzU1MzIzNWQ5YWYzMGVmNGY2ZTI4MDc5MGI5MlxcXCJcIixcblx0KiAgICAgICAgIFwic2l6ZVwiOiAzMjE3NSxcblx0KiAgICAgICAgIFwibWltZXR5cGVcIjogXCJpbWFnZS9wbmdcIixcblx0KiAgICAgICAgIFwiY2FjaGVDb250cm9sXCI6IFwibWF4LWFnZT0zNjAwXCIsXG5cdCogICAgICAgICBcImxhc3RNb2RpZmllZFwiOiBcIjIwMjQtMDUtMjJUMjM6MDY6MDUuNTc0WlwiLFxuXHQqICAgICAgICAgXCJjb250ZW50TGVuZ3RoXCI6IDMyMTc1LFxuXHQqICAgICAgICAgXCJodHRwU3RhdHVzQ29kZVwiOiAyMDBcblx0KiAgICAgICB9XG5cdCogICAgIH1cblx0KiAgIF0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCpcblx0KiBAZXhhbXBsZSBTZWFyY2ggZmlsZXMgaW4gYSBidWNrZXRcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmxpc3QoJ2ZvbGRlcicsIHtcblx0KiAgICAgbGltaXQ6IDEwMCxcblx0KiAgICAgb2Zmc2V0OiAwLFxuXHQqICAgICBzb3J0Qnk6IHsgY29sdW1uOiAnbmFtZScsIG9yZGVyOiAnYXNjJyB9LFxuXHQqICAgICBzZWFyY2g6ICdqb24nXG5cdCogICB9KVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBsaXN0KHBhdGgsIG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcblx0XHR2YXIgX3RoaXMxMyA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IGJvZHkgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9TRUFSQ0hfT1BUSU9OUyksIG9wdGlvbnMpLCB7fSwgeyBwcmVmaXg6IHBhdGggfHwgXCJcIiB9KTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHBvc3QkMShfdGhpczEzLmZldGNoLCBgJHtfdGhpczEzLnVybH0vb2JqZWN0L2xpc3QvJHtfdGhpczEzLmJ1Y2tldElkfWAsIGJvZHksIHsgaGVhZGVyczogX3RoaXMxMy5oZWFkZXJzIH0sIHBhcmFtZXRlcnMpLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzMTMuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQqIEBleHBlcmltZW50YWwgdGhpcyBtZXRob2Qgc2lnbmF0dXJlIG1pZ2h0IGNoYW5nZSBpbiB0aGUgZnV0dXJlXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIG9wdGlvbnMgc2VhcmNoIG9wdGlvbnNcblx0KiBAcGFyYW0gcGFyYW1ldGVyc1xuXHQqL1xuXHRhc3luYyBsaXN0VjIob3B0aW9ucywgcGFyYW1ldGVycykge1xuXHRcdHZhciBfdGhpczE0ID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgYm9keSA9IF9vYmplY3RTcHJlYWQyKHt9LCBvcHRpb25zKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHBvc3QkMShfdGhpczE0LmZldGNoLCBgJHtfdGhpczE0LnVybH0vb2JqZWN0L2xpc3QtdjIvJHtfdGhpczE0LmJ1Y2tldElkfWAsIGJvZHksIHsgaGVhZGVyczogX3RoaXMxNC5oZWFkZXJzIH0sIHBhcmFtZXRlcnMpLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzMTQuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdGVuY29kZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKTtcblx0fVxuXHR0b0Jhc2U2NChkYXRhKSB7XG5cdFx0aWYgKHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBCdWZmZXIuZnJvbShkYXRhKS50b1N0cmluZyhcImJhc2U2NFwiKTtcblx0XHRyZXR1cm4gYnRvYShkYXRhKTtcblx0fVxuXHRfZ2V0RmluYWxQYXRoKHBhdGgpIHtcblx0XHRyZXR1cm4gYCR7dGhpcy5idWNrZXRJZH0vJHtwYXRoLnJlcGxhY2UoL15cXC8rLywgXCJcIil9YDtcblx0fVxuXHRfcmVtb3ZlRW1wdHlGb2xkZXJzKHBhdGgpIHtcblx0XHRyZXR1cm4gcGF0aC5yZXBsYWNlKC9eXFwvfFxcLyQvZywgXCJcIikucmVwbGFjZSgvXFwvKy9nLCBcIi9cIik7XG5cdH1cblx0dHJhbnNmb3JtT3B0c1RvUXVlcnlTdHJpbmcodHJhbnNmb3JtKSB7XG5cdFx0Y29uc3QgcGFyYW1zID0gW107XG5cdFx0aWYgKHRyYW5zZm9ybS53aWR0aCkgcGFyYW1zLnB1c2goYHdpZHRoPSR7dHJhbnNmb3JtLndpZHRofWApO1xuXHRcdGlmICh0cmFuc2Zvcm0uaGVpZ2h0KSBwYXJhbXMucHVzaChgaGVpZ2h0PSR7dHJhbnNmb3JtLmhlaWdodH1gKTtcblx0XHRpZiAodHJhbnNmb3JtLnJlc2l6ZSkgcGFyYW1zLnB1c2goYHJlc2l6ZT0ke3RyYW5zZm9ybS5yZXNpemV9YCk7XG5cdFx0aWYgKHRyYW5zZm9ybS5mb3JtYXQpIHBhcmFtcy5wdXNoKGBmb3JtYXQ9JHt0cmFuc2Zvcm0uZm9ybWF0fWApO1xuXHRcdGlmICh0cmFuc2Zvcm0ucXVhbGl0eSkgcGFyYW1zLnB1c2goYHF1YWxpdHk9JHt0cmFuc2Zvcm0ucXVhbGl0eX1gKTtcblx0XHRyZXR1cm4gcGFyYW1zLmpvaW4oXCImXCIpO1xuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvbGliL3ZlcnNpb24udHNcbmNvbnN0IHZlcnNpb24gPSBcIjIuOTEuMFwiO1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvbGliL2NvbnN0YW50cy50c1xuY29uc3QgREVGQVVMVF9IRUFERVJTJDEgPSB7IFwiWC1DbGllbnQtSW5mb1wiOiBgc3RvcmFnZS1qcy8ke3ZlcnNpb259YCB9O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvcGFja2FnZXMvU3RvcmFnZUJ1Y2tldEFwaS50c1xudmFyIFN0b3JhZ2VCdWNrZXRBcGkgPSBjbGFzcyB7XG5cdGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycyA9IHt9LCBmZXRjaCQxLCBvcHRzKSB7XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSBmYWxzZTtcblx0XHRjb25zdCBiYXNlVXJsID0gbmV3IFVSTCh1cmwpO1xuXHRcdGlmIChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMudXNlTmV3SG9zdG5hbWUpIHtcblx0XHRcdGlmICgvc3VwYWJhc2VcXC4oY298aW58cmVkKSQvLnRlc3QoYmFzZVVybC5ob3N0bmFtZSkgJiYgIWJhc2VVcmwuaG9zdG5hbWUuaW5jbHVkZXMoXCJzdG9yYWdlLnN1cGFiYXNlLlwiKSkgYmFzZVVybC5ob3N0bmFtZSA9IGJhc2VVcmwuaG9zdG5hbWUucmVwbGFjZShcInN1cGFiYXNlLlwiLCBcInN0b3JhZ2Uuc3VwYWJhc2UuXCIpO1xuXHRcdH1cblx0XHR0aGlzLnVybCA9IGJhc2VVcmwuaHJlZi5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG5cdFx0dGhpcy5oZWFkZXJzID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIERFRkFVTFRfSEVBREVSUyQxKSwgaGVhZGVycyk7XG5cdFx0dGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaCQxKGZldGNoJDEpO1xuXHR9XG5cdC8qKlxuXHQqIEVuYWJsZSB0aHJvd2luZyBlcnJvcnMgaW5zdGVhZCBvZiByZXR1cm5pbmcgdGhlbS5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0Ki9cblx0dGhyb3dPbkVycm9yKCkge1xuXHRcdHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gdHJ1ZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBSZXRyaWV2ZXMgdGhlIGRldGFpbHMgb2YgYWxsIFN0b3JhZ2UgYnVja2V0cyB3aXRoaW4gYW4gZXhpc3RpbmcgcHJvamVjdC5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gb3B0aW9ucyBRdWVyeSBwYXJhbWV0ZXJzIGZvciBsaXN0aW5nIGJ1Y2tldHNcblx0KiBAcGFyYW0gb3B0aW9ucy5saW1pdCBNYXhpbXVtIG51bWJlciBvZiBidWNrZXRzIHRvIHJldHVyblxuXHQqIEBwYXJhbSBvcHRpb25zLm9mZnNldCBOdW1iZXIgb2YgYnVja2V0cyB0byBza2lwXG5cdCogQHBhcmFtIG9wdGlvbnMuc29ydENvbHVtbiBDb2x1bW4gdG8gc29ydCBieSAoJ2lkJywgJ25hbWUnLCAnY3JlYXRlZF9hdCcsICd1cGRhdGVkX2F0Jylcblx0KiBAcGFyYW0gb3B0aW9ucy5zb3J0T3JkZXIgU29ydCBvcmRlciAoJ2FzYycgb3IgJ2Rlc2MnKVxuXHQqIEBwYXJhbSBvcHRpb25zLnNlYXJjaCBTZWFyY2ggdGVybSB0byBmaWx0ZXIgYnVja2V0IG5hbWVzXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgYXJyYXkgb2YgYnVja2V0cyBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgTGlzdCBidWNrZXRzXG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5saXN0QnVja2V0cygpXG5cdCogYGBgXG5cdCpcblx0KiBAZXhhbXBsZSBMaXN0IGJ1Y2tldHMgd2l0aCBvcHRpb25zXG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5saXN0QnVja2V0cyh7XG5cdCogICAgIGxpbWl0OiAxMCxcblx0KiAgICAgb2Zmc2V0OiAwLFxuXHQqICAgICBzb3J0Q29sdW1uOiAnY3JlYXRlZF9hdCcsXG5cdCogICAgIHNvcnRPcmRlcjogJ2Rlc2MnLFxuXHQqICAgICBzZWFyY2g6ICdwcm9kJ1xuXHQqICAgfSlcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgbGlzdEJ1Y2tldHMob3B0aW9ucykge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHF1ZXJ5U3RyaW5nID0gX3RoaXMubGlzdEJ1Y2tldE9wdGlvbnNUb1F1ZXJ5U3RyaW5nKG9wdGlvbnMpO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgZ2V0KF90aGlzLmZldGNoLCBgJHtfdGhpcy51cmx9L2J1Y2tldCR7cXVlcnlTdHJpbmd9YCwgeyBoZWFkZXJzOiBfdGhpcy5oZWFkZXJzIH0pLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKipcblx0KiBSZXRyaWV2ZXMgdGhlIGRldGFpbHMgb2YgYW4gZXhpc3RpbmcgU3RvcmFnZSBidWNrZXQuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgYnVja2V0IHlvdSB3b3VsZCBsaWtlIHRvIHJldHJpZXZlLlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIGJ1Y2tldCBkZXRhaWxzIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBHZXQgYnVja2V0XG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5nZXRCdWNrZXQoJ2F2YXRhcnMnKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiB7XG5cdCogICAgIFwiaWRcIjogXCJhdmF0YXJzXCIsXG5cdCogICAgIFwibmFtZVwiOiBcImF2YXRhcnNcIixcblx0KiAgICAgXCJvd25lclwiOiBcIlwiLFxuXHQqICAgICBcInB1YmxpY1wiOiBmYWxzZSxcblx0KiAgICAgXCJmaWxlX3NpemVfbGltaXRcIjogMTAyNCxcblx0KiAgICAgXCJhbGxvd2VkX21pbWVfdHlwZXNcIjogW1xuXHQqICAgICAgIFwiaW1hZ2UvcG5nXCJcblx0KiAgICAgXSxcblx0KiAgICAgXCJjcmVhdGVkX2F0XCI6IFwiMjAyNC0wNS0yMlQyMjoyNjowNS4xMDBaXCIsXG5cdCogICAgIFwidXBkYXRlZF9hdFwiOiBcIjIwMjQtMDUtMjJUMjI6MjY6MDUuMTAwWlwiXG5cdCogICB9LFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBnZXRCdWNrZXQoaWQpIHtcblx0XHR2YXIgX3RoaXMyID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgZ2V0KF90aGlzMi5mZXRjaCwgYCR7X3RoaXMyLnVybH0vYnVja2V0LyR7aWR9YCwgeyBoZWFkZXJzOiBfdGhpczIuaGVhZGVycyB9KSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczIuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQqIENyZWF0ZXMgYSBuZXcgU3RvcmFnZSBidWNrZXRcblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gaWQgQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGJ1Y2tldCB5b3UgYXJlIGNyZWF0aW5nLlxuXHQqIEBwYXJhbSBvcHRpb25zLnB1YmxpYyBUaGUgdmlzaWJpbGl0eSBvZiB0aGUgYnVja2V0LiBQdWJsaWMgYnVja2V0cyBkb24ndCByZXF1aXJlIGFuIGF1dGhvcml6YXRpb24gdG9rZW4gdG8gZG93bmxvYWQgb2JqZWN0cywgYnV0IHN0aWxsIHJlcXVpcmUgYSB2YWxpZCB0b2tlbiBmb3IgYWxsIG90aGVyIG9wZXJhdGlvbnMuIEJ5IGRlZmF1bHQsIGJ1Y2tldHMgYXJlIHByaXZhdGUuXG5cdCogQHBhcmFtIG9wdGlvbnMuZmlsZVNpemVMaW1pdCBzcGVjaWZpZXMgdGhlIG1heCBmaWxlIHNpemUgaW4gYnl0ZXMgdGhhdCBjYW4gYmUgdXBsb2FkZWQgdG8gdGhpcyBidWNrZXQuXG5cdCogVGhlIGdsb2JhbCBmaWxlIHNpemUgbGltaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRoaXMgdmFsdWUuXG5cdCogVGhlIGRlZmF1bHQgdmFsdWUgaXMgbnVsbCwgd2hpY2ggZG9lc24ndCBzZXQgYSBwZXIgYnVja2V0IGZpbGUgc2l6ZSBsaW1pdC5cblx0KiBAcGFyYW0gb3B0aW9ucy5hbGxvd2VkTWltZVR5cGVzIHNwZWNpZmllcyB0aGUgYWxsb3dlZCBtaW1lIHR5cGVzIHRoYXQgdGhpcyBidWNrZXQgY2FuIGFjY2VwdCBkdXJpbmcgdXBsb2FkLlxuXHQqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIG51bGwsIHdoaWNoIGFsbG93cyBmaWxlcyB3aXRoIGFsbCBtaW1lIHR5cGVzIHRvIGJlIHVwbG9hZGVkLlxuXHQqIEVhY2ggbWltZSB0eXBlIHNwZWNpZmllZCBjYW4gYmUgYSB3aWxkY2FyZCwgZS5nLiBpbWFnZS8qLCBvciBhIHNwZWNpZmljIG1pbWUgdHlwZSwgZS5nLiBpbWFnZS9wbmcuXG5cdCogQHBhcmFtIG9wdGlvbnMudHlwZSAocHJpdmF0ZS1iZXRhKSBzcGVjaWZpZXMgdGhlIGJ1Y2tldCB0eXBlLiBzZWUgYEJ1Y2tldFR5cGVgIGZvciBtb3JlIGRldGFpbHMuXG5cdCogICAtIGRlZmF1bHQgYnVja2V0IHR5cGUgaXMgYFNUQU5EQVJEYFxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIG5ld2x5IGNyZWF0ZWQgYnVja2V0IG5hbWUgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIENyZWF0ZSBidWNrZXRcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmNyZWF0ZUJ1Y2tldCgnYXZhdGFycycsIHtcblx0KiAgICAgcHVibGljOiBmYWxzZSxcblx0KiAgICAgYWxsb3dlZE1pbWVUeXBlczogWydpbWFnZS9wbmcnXSxcblx0KiAgICAgZmlsZVNpemVMaW1pdDogMTAyNFxuXHQqICAgfSlcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjoge1xuXHQqICAgICBcIm5hbWVcIjogXCJhdmF0YXJzXCJcblx0KiAgIH0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGNyZWF0ZUJ1Y2tldChpZCwgb3B0aW9ucyA9IHsgcHVibGljOiBmYWxzZSB9KSB7XG5cdFx0dmFyIF90aGlzMyA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHBvc3QkMShfdGhpczMuZmV0Y2gsIGAke190aGlzMy51cmx9L2J1Y2tldGAsIHtcblx0XHRcdFx0XHRpZCxcblx0XHRcdFx0XHRuYW1lOiBpZCxcblx0XHRcdFx0XHR0eXBlOiBvcHRpb25zLnR5cGUsXG5cdFx0XHRcdFx0cHVibGljOiBvcHRpb25zLnB1YmxpYyxcblx0XHRcdFx0XHRmaWxlX3NpemVfbGltaXQ6IG9wdGlvbnMuZmlsZVNpemVMaW1pdCxcblx0XHRcdFx0XHRhbGxvd2VkX21pbWVfdHlwZXM6IG9wdGlvbnMuYWxsb3dlZE1pbWVUeXBlc1xuXHRcdFx0XHR9LCB7IGhlYWRlcnM6IF90aGlzMy5oZWFkZXJzIH0pLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzMy5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqXG5cdCogVXBkYXRlcyBhIFN0b3JhZ2UgYnVja2V0XG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIGlkIEEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBidWNrZXQgeW91IGFyZSB1cGRhdGluZy5cblx0KiBAcGFyYW0gb3B0aW9ucy5wdWJsaWMgVGhlIHZpc2liaWxpdHkgb2YgdGhlIGJ1Y2tldC4gUHVibGljIGJ1Y2tldHMgZG9uJ3QgcmVxdWlyZSBhbiBhdXRob3JpemF0aW9uIHRva2VuIHRvIGRvd25sb2FkIG9iamVjdHMsIGJ1dCBzdGlsbCByZXF1aXJlIGEgdmFsaWQgdG9rZW4gZm9yIGFsbCBvdGhlciBvcGVyYXRpb25zLlxuXHQqIEBwYXJhbSBvcHRpb25zLmZpbGVTaXplTGltaXQgc3BlY2lmaWVzIHRoZSBtYXggZmlsZSBzaXplIGluIGJ5dGVzIHRoYXQgY2FuIGJlIHVwbG9hZGVkIHRvIHRoaXMgYnVja2V0LlxuXHQqIFRoZSBnbG9iYWwgZmlsZSBzaXplIGxpbWl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciB0aGlzIHZhbHVlLlxuXHQqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIG51bGwsIHdoaWNoIGRvZXNuJ3Qgc2V0IGEgcGVyIGJ1Y2tldCBmaWxlIHNpemUgbGltaXQuXG5cdCogQHBhcmFtIG9wdGlvbnMuYWxsb3dlZE1pbWVUeXBlcyBzcGVjaWZpZXMgdGhlIGFsbG93ZWQgbWltZSB0eXBlcyB0aGF0IHRoaXMgYnVja2V0IGNhbiBhY2NlcHQgZHVyaW5nIHVwbG9hZC5cblx0KiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBudWxsLCB3aGljaCBhbGxvd3MgZmlsZXMgd2l0aCBhbGwgbWltZSB0eXBlcyB0byBiZSB1cGxvYWRlZC5cblx0KiBFYWNoIG1pbWUgdHlwZSBzcGVjaWZpZWQgY2FuIGJlIGEgd2lsZGNhcmQsIGUuZy4gaW1hZ2UvKiwgb3IgYSBzcGVjaWZpYyBtaW1lIHR5cGUsIGUuZy4gaW1hZ2UvcG5nLlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIHN1Y2Nlc3MgbWVzc2FnZSBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgVXBkYXRlIGJ1Y2tldFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAudXBkYXRlQnVja2V0KCdhdmF0YXJzJywge1xuXHQqICAgICBwdWJsaWM6IGZhbHNlLFxuXHQqICAgICBhbGxvd2VkTWltZVR5cGVzOiBbJ2ltYWdlL3BuZyddLFxuXHQqICAgICBmaWxlU2l6ZUxpbWl0OiAxMDI0XG5cdCogICB9KVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiB7XG5cdCogICAgIFwibWVzc2FnZVwiOiBcIlN1Y2Nlc3NmdWxseSB1cGRhdGVkXCJcblx0KiAgIH0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIHVwZGF0ZUJ1Y2tldChpZCwgb3B0aW9ucykge1xuXHRcdHZhciBfdGhpczQgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBwdXQoX3RoaXM0LmZldGNoLCBgJHtfdGhpczQudXJsfS9idWNrZXQvJHtpZH1gLCB7XG5cdFx0XHRcdFx0aWQsXG5cdFx0XHRcdFx0bmFtZTogaWQsXG5cdFx0XHRcdFx0cHVibGljOiBvcHRpb25zLnB1YmxpYyxcblx0XHRcdFx0XHRmaWxlX3NpemVfbGltaXQ6IG9wdGlvbnMuZmlsZVNpemVMaW1pdCxcblx0XHRcdFx0XHRhbGxvd2VkX21pbWVfdHlwZXM6IG9wdGlvbnMuYWxsb3dlZE1pbWVUeXBlc1xuXHRcdFx0XHR9LCB7IGhlYWRlcnM6IF90aGlzNC5oZWFkZXJzIH0pLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzNC5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqXG5cdCogUmVtb3ZlcyBhbGwgb2JqZWN0cyBpbnNpZGUgYSBzaW5nbGUgYnVja2V0LlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBpZCBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGJ1Y2tldCB5b3Ugd291bGQgbGlrZSB0byBlbXB0eS5cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggc3VjY2VzcyBtZXNzYWdlIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBFbXB0eSBidWNrZXRcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmVtcHR5QnVja2V0KCdhdmF0YXJzJylcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjoge1xuXHQqICAgICBcIm1lc3NhZ2VcIjogXCJTdWNjZXNzZnVsbHkgZW1wdGllZFwiXG5cdCogICB9LFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBlbXB0eUJ1Y2tldChpZCkge1xuXHRcdHZhciBfdGhpczUgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBwb3N0JDEoX3RoaXM1LmZldGNoLCBgJHtfdGhpczUudXJsfS9idWNrZXQvJHtpZH0vZW1wdHlgLCB7fSwgeyBoZWFkZXJzOiBfdGhpczUuaGVhZGVycyB9KSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczUuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQqIERlbGV0ZXMgYW4gZXhpc3RpbmcgYnVja2V0LiBBIGJ1Y2tldCBjYW4ndCBiZSBkZWxldGVkIHdpdGggZXhpc3Rpbmcgb2JqZWN0cyBpbnNpZGUgaXQuXG5cdCogWW91IG11c3QgZmlyc3QgYGVtcHR5KClgIHRoZSBidWNrZXQuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgYnVja2V0IHlvdSB3b3VsZCBsaWtlIHRvIGRlbGV0ZS5cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggc3VjY2VzcyBtZXNzYWdlIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBEZWxldGUgYnVja2V0XG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5kZWxldGVCdWNrZXQoJ2F2YXRhcnMnKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiB7XG5cdCogICAgIFwibWVzc2FnZVwiOiBcIlN1Y2Nlc3NmdWxseSBkZWxldGVkXCJcblx0KiAgIH0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGRlbGV0ZUJ1Y2tldChpZCkge1xuXHRcdHZhciBfdGhpczYgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCByZW1vdmUoX3RoaXM2LmZldGNoLCBgJHtfdGhpczYudXJsfS9idWNrZXQvJHtpZH1gLCB7fSwgeyBoZWFkZXJzOiBfdGhpczYuaGVhZGVycyB9KSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczYuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdGxpc3RCdWNrZXRPcHRpb25zVG9RdWVyeVN0cmluZyhvcHRpb25zKSB7XG5cdFx0Y29uc3QgcGFyYW1zID0ge307XG5cdFx0aWYgKG9wdGlvbnMpIHtcblx0XHRcdGlmIChcImxpbWl0XCIgaW4gb3B0aW9ucykgcGFyYW1zLmxpbWl0ID0gU3RyaW5nKG9wdGlvbnMubGltaXQpO1xuXHRcdFx0aWYgKFwib2Zmc2V0XCIgaW4gb3B0aW9ucykgcGFyYW1zLm9mZnNldCA9IFN0cmluZyhvcHRpb25zLm9mZnNldCk7XG5cdFx0XHRpZiAob3B0aW9ucy5zZWFyY2gpIHBhcmFtcy5zZWFyY2ggPSBvcHRpb25zLnNlYXJjaDtcblx0XHRcdGlmIChvcHRpb25zLnNvcnRDb2x1bW4pIHBhcmFtcy5zb3J0Q29sdW1uID0gb3B0aW9ucy5zb3J0Q29sdW1uO1xuXHRcdFx0aWYgKG9wdGlvbnMuc29ydE9yZGVyKSBwYXJhbXMuc29ydE9yZGVyID0gb3B0aW9ucy5zb3J0T3JkZXI7XG5cdFx0fVxuXHRcdHJldHVybiBPYmplY3Qua2V5cyhwYXJhbXMpLmxlbmd0aCA+IDAgPyBcIj9cIiArIG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1zKS50b1N0cmluZygpIDogXCJcIjtcblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3BhY2thZ2VzL1N0b3JhZ2VBbmFseXRpY3NDbGllbnQudHNcbi8qKlxuKiBDbGllbnQgY2xhc3MgZm9yIG1hbmFnaW5nIEFuYWx5dGljcyBCdWNrZXRzIHVzaW5nIEljZWJlcmcgdGFibGVzXG4qIFByb3ZpZGVzIG1ldGhvZHMgZm9yIGNyZWF0aW5nLCBsaXN0aW5nLCBhbmQgZGVsZXRpbmcgYW5hbHl0aWNzIGJ1Y2tldHNcbiovXG52YXIgU3RvcmFnZUFuYWx5dGljc0NsaWVudCA9IGNsYXNzIHtcblx0LyoqXG5cdCogQGFscGhhXG5cdCpcblx0KiBDcmVhdGVzIGEgbmV3IFN0b3JhZ2VBbmFseXRpY3NDbGllbnQgaW5zdGFuY2Vcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgQW5hbHl0aWNzIEJ1Y2tldHNcblx0KiBAcGFyYW0gdXJsIC0gVGhlIGJhc2UgVVJMIGZvciB0aGUgc3RvcmFnZSBBUElcblx0KiBAcGFyYW0gaGVhZGVycyAtIEhUVFAgaGVhZGVycyB0byBpbmNsdWRlIGluIHJlcXVlc3RzXG5cdCogQHBhcmFtIGZldGNoIC0gT3B0aW9uYWwgY3VzdG9tIGZldGNoIGltcGxlbWVudGF0aW9uXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCBjbGllbnQgPSBuZXcgU3RvcmFnZUFuYWx5dGljc0NsaWVudCh1cmwsIGhlYWRlcnMpXG5cdCogYGBgXG5cdCovXG5cdGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycyA9IHt9LCBmZXRjaCQxKSB7XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSBmYWxzZTtcblx0XHR0aGlzLnVybCA9IHVybC5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG5cdFx0dGhpcy5oZWFkZXJzID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIERFRkFVTFRfSEVBREVSUyQxKSwgaGVhZGVycyk7XG5cdFx0dGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaCQxKGZldGNoJDEpO1xuXHR9XG5cdC8qKlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogRW5hYmxlIHRocm93aW5nIGVycm9ycyBpbnN0ZWFkIG9mIHJldHVybmluZyB0aGVtIGluIHRoZSByZXNwb25zZVxuXHQqIFdoZW4gZW5hYmxlZCwgZmFpbGVkIG9wZXJhdGlvbnMgd2lsbCB0aHJvdyBpbnN0ZWFkIG9mIHJldHVybmluZyB7IGRhdGE6IG51bGwsIGVycm9yIH1cblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgQW5hbHl0aWNzIEJ1Y2tldHNcblx0KiBAcmV0dXJucyBUaGlzIGluc3RhbmNlIGZvciBtZXRob2QgY2hhaW5pbmdcblx0Ki9cblx0dGhyb3dPbkVycm9yKCkge1xuXHRcdHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gdHJ1ZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBAYWxwaGFcblx0KlxuXHQqIENyZWF0ZXMgYSBuZXcgYW5hbHl0aWNzIGJ1Y2tldCB1c2luZyBJY2ViZXJnIHRhYmxlc1xuXHQqIEFuYWx5dGljcyBidWNrZXRzIGFyZSBvcHRpbWl6ZWQgZm9yIGFuYWx5dGljYWwgcXVlcmllcyBhbmQgZGF0YSBwcm9jZXNzaW5nXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IEFuYWx5dGljcyBCdWNrZXRzXG5cdCogQHBhcmFtIG5hbWUgQSB1bmlxdWUgbmFtZSBmb3IgdGhlIGJ1Y2tldCB5b3UgYXJlIGNyZWF0aW5nXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgbmV3bHkgY3JlYXRlZCBhbmFseXRpY3MgYnVja2V0IG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBDcmVhdGUgYW5hbHl0aWNzIGJ1Y2tldFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuYW5hbHl0aWNzXG5cdCogICAuY3JlYXRlQnVja2V0KCdhbmFseXRpY3MtZGF0YScpXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IHtcblx0KiAgICAgXCJuYW1lXCI6IFwiYW5hbHl0aWNzLWRhdGFcIixcblx0KiAgICAgXCJ0eXBlXCI6IFwiQU5BTFlUSUNTXCIsXG5cdCogICAgIFwiZm9ybWF0XCI6IFwiaWNlYmVyZ1wiLFxuXHQqICAgICBcImNyZWF0ZWRfYXRcIjogXCIyMDI0LTA1LTIyVDIyOjI2OjA1LjEwMFpcIixcblx0KiAgICAgXCJ1cGRhdGVkX2F0XCI6IFwiMjAyNC0wNS0yMlQyMjoyNjowNS4xMDBaXCJcblx0KiAgIH0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGNyZWF0ZUJ1Y2tldChuYW1lKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgcG9zdCQxKF90aGlzLmZldGNoLCBgJHtfdGhpcy51cmx9L2J1Y2tldGAsIHsgbmFtZSB9LCB7IGhlYWRlcnM6IF90aGlzLmhlYWRlcnMgfSksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogUmV0cmlldmVzIHRoZSBkZXRhaWxzIG9mIGFsbCBBbmFseXRpY3MgU3RvcmFnZSBidWNrZXRzIHdpdGhpbiBhbiBleGlzdGluZyBwcm9qZWN0XG5cdCogT25seSByZXR1cm5zIGJ1Y2tldHMgb2YgdHlwZSAnQU5BTFlUSUNTJ1xuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBBbmFseXRpY3MgQnVja2V0c1xuXHQqIEBwYXJhbSBvcHRpb25zIFF1ZXJ5IHBhcmFtZXRlcnMgZm9yIGxpc3RpbmcgYnVja2V0c1xuXHQqIEBwYXJhbSBvcHRpb25zLmxpbWl0IE1heGltdW0gbnVtYmVyIG9mIGJ1Y2tldHMgdG8gcmV0dXJuXG5cdCogQHBhcmFtIG9wdGlvbnMub2Zmc2V0IE51bWJlciBvZiBidWNrZXRzIHRvIHNraXBcblx0KiBAcGFyYW0gb3B0aW9ucy5zb3J0Q29sdW1uIENvbHVtbiB0byBzb3J0IGJ5ICgnbmFtZScsICdjcmVhdGVkX2F0JywgJ3VwZGF0ZWRfYXQnKVxuXHQqIEBwYXJhbSBvcHRpb25zLnNvcnRPcmRlciBTb3J0IG9yZGVyICgnYXNjJyBvciAnZGVzYycpXG5cdCogQHBhcmFtIG9wdGlvbnMuc2VhcmNoIFNlYXJjaCB0ZXJtIHRvIGZpbHRlciBidWNrZXQgbmFtZXNcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBhcnJheSBvZiBhbmFseXRpY3MgYnVja2V0cyBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgTGlzdCBhbmFseXRpY3MgYnVja2V0c1xuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuYW5hbHl0aWNzXG5cdCogICAubGlzdEJ1Y2tldHMoe1xuXHQqICAgICBsaW1pdDogMTAsXG5cdCogICAgIG9mZnNldDogMCxcblx0KiAgICAgc29ydENvbHVtbjogJ2NyZWF0ZWRfYXQnLFxuXHQqICAgICBzb3J0T3JkZXI6ICdkZXNjJ1xuXHQqICAgfSlcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjogW1xuXHQqICAgICB7XG5cdCogICAgICAgXCJuYW1lXCI6IFwiYW5hbHl0aWNzLWRhdGFcIixcblx0KiAgICAgICBcInR5cGVcIjogXCJBTkFMWVRJQ1NcIixcblx0KiAgICAgICBcImZvcm1hdFwiOiBcImljZWJlcmdcIixcblx0KiAgICAgICBcImNyZWF0ZWRfYXRcIjogXCIyMDI0LTA1LTIyVDIyOjI2OjA1LjEwMFpcIixcblx0KiAgICAgICBcInVwZGF0ZWRfYXRcIjogXCIyMDI0LTA1LTIyVDIyOjI2OjA1LjEwMFpcIlxuXHQqICAgICB9XG5cdCogICBdLFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBsaXN0QnVja2V0cyhvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzMiA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuXHRcdFx0aWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubGltaXQpICE9PSB2b2lkIDApIHF1ZXJ5UGFyYW1zLnNldChcImxpbWl0XCIsIG9wdGlvbnMubGltaXQudG9TdHJpbmcoKSk7XG5cdFx0XHRpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vZmZzZXQpICE9PSB2b2lkIDApIHF1ZXJ5UGFyYW1zLnNldChcIm9mZnNldFwiLCBvcHRpb25zLm9mZnNldC50b1N0cmluZygpKTtcblx0XHRcdGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc29ydENvbHVtbikgcXVlcnlQYXJhbXMuc2V0KFwic29ydENvbHVtblwiLCBvcHRpb25zLnNvcnRDb2x1bW4pO1xuXHRcdFx0aWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zb3J0T3JkZXIpIHF1ZXJ5UGFyYW1zLnNldChcInNvcnRPcmRlclwiLCBvcHRpb25zLnNvcnRPcmRlcik7XG5cdFx0XHRpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNlYXJjaCkgcXVlcnlQYXJhbXMuc2V0KFwic2VhcmNoXCIsIG9wdGlvbnMuc2VhcmNoKTtcblx0XHRcdGNvbnN0IHF1ZXJ5U3RyaW5nID0gcXVlcnlQYXJhbXMudG9TdHJpbmcoKTtcblx0XHRcdGNvbnN0IHVybCA9IHF1ZXJ5U3RyaW5nID8gYCR7X3RoaXMyLnVybH0vYnVja2V0PyR7cXVlcnlTdHJpbmd9YCA6IGAke190aGlzMi51cmx9L2J1Y2tldGA7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBnZXQoX3RoaXMyLmZldGNoLCB1cmwsIHsgaGVhZGVyczogX3RoaXMyLmhlYWRlcnMgfSksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMyLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKipcblx0KiBAYWxwaGFcblx0KlxuXHQqIERlbGV0ZXMgYW4gZXhpc3RpbmcgYW5hbHl0aWNzIGJ1Y2tldFxuXHQqIEEgYnVja2V0IGNhbid0IGJlIGRlbGV0ZWQgd2l0aCBleGlzdGluZyBvYmplY3RzIGluc2lkZSBpdFxuXHQqIFlvdSBtdXN0IGZpcnN0IGVtcHR5IHRoZSBidWNrZXQgYmVmb3JlIGRlbGV0aW9uXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IEFuYWx5dGljcyBCdWNrZXRzXG5cdCogQHBhcmFtIGJ1Y2tldE5hbWUgVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBidWNrZXQgeW91IHdvdWxkIGxpa2UgdG8gZGVsZXRlXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgc3VjY2VzcyBtZXNzYWdlIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBEZWxldGUgYW5hbHl0aWNzIGJ1Y2tldFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuYW5hbHl0aWNzXG5cdCogICAuZGVsZXRlQnVja2V0KCdhbmFseXRpY3MtZGF0YScpXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IHtcblx0KiAgICAgXCJtZXNzYWdlXCI6IFwiU3VjY2Vzc2Z1bGx5IGRlbGV0ZWRcIlxuXHQqICAgfSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgZGVsZXRlQnVja2V0KGJ1Y2tldE5hbWUpIHtcblx0XHR2YXIgX3RoaXMzID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgcmVtb3ZlKF90aGlzMy5mZXRjaCwgYCR7X3RoaXMzLnVybH0vYnVja2V0LyR7YnVja2V0TmFtZX1gLCB7fSwgeyBoZWFkZXJzOiBfdGhpczMuaGVhZGVycyB9KSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczMuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogR2V0IGFuIEljZWJlcmcgUkVTVCBDYXRhbG9nIGNsaWVudCBjb25maWd1cmVkIGZvciBhIHNwZWNpZmljIGFuYWx5dGljcyBidWNrZXRcblx0KiBVc2UgdGhpcyB0byBwZXJmb3JtIGFkdmFuY2VkIHRhYmxlIGFuZCBuYW1lc3BhY2Ugb3BlcmF0aW9ucyB3aXRoaW4gdGhlIGJ1Y2tldFxuXHQqIFRoZSByZXR1cm5lZCBjbGllbnQgcHJvdmlkZXMgZnVsbCBhY2Nlc3MgdG8gdGhlIEFwYWNoZSBJY2ViZXJnIFJFU1QgQ2F0YWxvZyBBUElcblx0KiB3aXRoIHRoZSBTdXBhYmFzZSBgeyBkYXRhLCBlcnJvciB9YCBwYXR0ZXJuIGZvciBjb25zaXN0ZW50IGVycm9yIGhhbmRsaW5nIG9uIGFsbCBvcGVyYXRpb25zLlxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBBbmFseXRpY3MgQnVja2V0c1xuXHQqIEBwYXJhbSBidWNrZXROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGFuYWx5dGljcyBidWNrZXQgKHdhcmVob3VzZSkgdG8gY29ubmVjdCB0b1xuXHQqIEByZXR1cm5zIFRoZSB3cmFwcGVkIEljZWJlcmcgY2F0YWxvZyBjbGllbnRcblx0KiBAdGhyb3dzIHtTdG9yYWdlRXJyb3J9IElmIHRoZSBidWNrZXQgbmFtZSBpcyBpbnZhbGlkXG5cdCpcblx0KiBAZXhhbXBsZSBHZXQgY2F0YWxvZyBhbmQgY3JlYXRlIHRhYmxlXG5cdCogYGBganNcblx0KiAvLyBGaXJzdCwgY3JlYXRlIGFuIGFuYWx5dGljcyBidWNrZXRcblx0KiBjb25zdCB7IGRhdGE6IGJ1Y2tldCwgZXJyb3I6IGJ1Y2tldEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5hbmFseXRpY3Ncblx0KiAgIC5jcmVhdGVCdWNrZXQoJ2FuYWx5dGljcy1kYXRhJylcblx0KlxuXHQqIC8vIEdldCB0aGUgSWNlYmVyZyBjYXRhbG9nIGZvciB0aGF0IGJ1Y2tldFxuXHQqIGNvbnN0IGNhdGFsb2cgPSBzdXBhYmFzZS5zdG9yYWdlLmFuYWx5dGljcy5mcm9tKCdhbmFseXRpY3MtZGF0YScpXG5cdCpcblx0KiAvLyBDcmVhdGUgYSBuYW1lc3BhY2Vcblx0KiBjb25zdCB7IGVycm9yOiBuc0Vycm9yIH0gPSBhd2FpdCBjYXRhbG9nLmNyZWF0ZU5hbWVzcGFjZSh7IG5hbWVzcGFjZTogWydkZWZhdWx0J10gfSlcblx0KlxuXHQqIC8vIENyZWF0ZSBhIHRhYmxlIHdpdGggc2NoZW1hXG5cdCogY29uc3QgeyBkYXRhOiB0YWJsZU1ldGFkYXRhLCBlcnJvcjogdGFibGVFcnJvciB9ID0gYXdhaXQgY2F0YWxvZy5jcmVhdGVUYWJsZShcblx0KiAgIHsgbmFtZXNwYWNlOiBbJ2RlZmF1bHQnXSB9LFxuXHQqICAge1xuXHQqICAgICBuYW1lOiAnZXZlbnRzJyxcblx0KiAgICAgc2NoZW1hOiB7XG5cdCogICAgICAgdHlwZTogJ3N0cnVjdCcsXG5cdCogICAgICAgZmllbGRzOiBbXG5cdCogICAgICAgICB7IGlkOiAxLCBuYW1lOiAnaWQnLCB0eXBlOiAnbG9uZycsIHJlcXVpcmVkOiB0cnVlIH0sXG5cdCogICAgICAgICB7IGlkOiAyLCBuYW1lOiAndGltZXN0YW1wJywgdHlwZTogJ3RpbWVzdGFtcCcsIHJlcXVpcmVkOiB0cnVlIH0sXG5cdCogICAgICAgICB7IGlkOiAzLCBuYW1lOiAndXNlcl9pZCcsIHR5cGU6ICdzdHJpbmcnLCByZXF1aXJlZDogZmFsc2UgfVxuXHQqICAgICAgIF0sXG5cdCogICAgICAgJ3NjaGVtYS1pZCc6IDAsXG5cdCogICAgICAgJ2lkZW50aWZpZXItZmllbGQtaWRzJzogWzFdXG5cdCogICAgIH0sXG5cdCogICAgICdwYXJ0aXRpb24tc3BlYyc6IHtcblx0KiAgICAgICAnc3BlYy1pZCc6IDAsXG5cdCogICAgICAgZmllbGRzOiBbXVxuXHQqICAgICB9LFxuXHQqICAgICAnd3JpdGUtb3JkZXInOiB7XG5cdCogICAgICAgJ29yZGVyLWlkJzogMCxcblx0KiAgICAgICBmaWVsZHM6IFtdXG5cdCogICAgIH0sXG5cdCogICAgIHByb3BlcnRpZXM6IHtcblx0KiAgICAgICAnd3JpdGUuZm9ybWF0LmRlZmF1bHQnOiAncGFycXVldCdcblx0KiAgICAgfVxuXHQqICAgfVxuXHQqIClcblx0KiBgYGBcblx0KlxuXHQqIEBleGFtcGxlIExpc3QgdGFibGVzIGluIG5hbWVzcGFjZVxuXHQqIGBgYGpzXG5cdCogY29uc3QgY2F0YWxvZyA9IHN1cGFiYXNlLnN0b3JhZ2UuYW5hbHl0aWNzLmZyb20oJ2FuYWx5dGljcy1kYXRhJylcblx0KlxuXHQqIC8vIExpc3QgYWxsIHRhYmxlcyBpbiB0aGUgZGVmYXVsdCBuYW1lc3BhY2Vcblx0KiBjb25zdCB7IGRhdGE6IHRhYmxlcywgZXJyb3I6IGxpc3RFcnJvciB9ID0gYXdhaXQgY2F0YWxvZy5saXN0VGFibGVzKHsgbmFtZXNwYWNlOiBbJ2RlZmF1bHQnXSB9KVxuXHQqIGlmIChsaXN0RXJyb3IpIHtcblx0KiAgIGlmIChsaXN0RXJyb3IuaXNOb3RGb3VuZCgpKSB7XG5cdCogICAgIGNvbnNvbGUubG9nKCdOYW1lc3BhY2Ugbm90IGZvdW5kJylcblx0KiAgIH1cblx0KiAgIHJldHVyblxuXHQqIH1cblx0KiBjb25zb2xlLmxvZyh0YWJsZXMpIC8vIFt7IG5hbWVzcGFjZTogWydkZWZhdWx0J10sIG5hbWU6ICdldmVudHMnIH1dXG5cdCogYGBgXG5cdCpcblx0KiBAZXhhbXBsZSBXb3JraW5nIHdpdGggbmFtZXNwYWNlc1xuXHQqIGBgYGpzXG5cdCogY29uc3QgY2F0YWxvZyA9IHN1cGFiYXNlLnN0b3JhZ2UuYW5hbHl0aWNzLmZyb20oJ2FuYWx5dGljcy1kYXRhJylcblx0KlxuXHQqIC8vIExpc3QgYWxsIG5hbWVzcGFjZXNcblx0KiBjb25zdCB7IGRhdGE6IG5hbWVzcGFjZXMgfSA9IGF3YWl0IGNhdGFsb2cubGlzdE5hbWVzcGFjZXMoKVxuXHQqXG5cdCogLy8gQ3JlYXRlIG5hbWVzcGFjZSB3aXRoIHByb3BlcnRpZXNcblx0KiBhd2FpdCBjYXRhbG9nLmNyZWF0ZU5hbWVzcGFjZShcblx0KiAgIHsgbmFtZXNwYWNlOiBbJ3Byb2R1Y3Rpb24nXSB9LFxuXHQqICAgeyBwcm9wZXJ0aWVzOiB7IG93bmVyOiAnZGF0YS10ZWFtJywgZW52OiAncHJvZCcgfSB9XG5cdCogKVxuXHQqIGBgYFxuXHQqXG5cdCogQGV4YW1wbGUgQ2xlYW51cCBvcGVyYXRpb25zXG5cdCogYGBganNcblx0KiBjb25zdCBjYXRhbG9nID0gc3VwYWJhc2Uuc3RvcmFnZS5hbmFseXRpY3MuZnJvbSgnYW5hbHl0aWNzLWRhdGEnKVxuXHQqXG5cdCogLy8gRHJvcCB0YWJsZSB3aXRoIHB1cmdlIG9wdGlvbiAocmVtb3ZlcyBhbGwgZGF0YSlcblx0KiBjb25zdCB7IGVycm9yOiBkcm9wRXJyb3IgfSA9IGF3YWl0IGNhdGFsb2cuZHJvcFRhYmxlKFxuXHQqICAgeyBuYW1lc3BhY2U6IFsnZGVmYXVsdCddLCBuYW1lOiAnZXZlbnRzJyB9LFxuXHQqICAgeyBwdXJnZTogdHJ1ZSB9XG5cdCogKVxuXHQqXG5cdCogaWYgKGRyb3BFcnJvcj8uaXNOb3RGb3VuZCgpKSB7XG5cdCogICBjb25zb2xlLmxvZygnVGFibGUgZG9lcyBub3QgZXhpc3QnKVxuXHQqIH1cblx0KlxuXHQqIC8vIERyb3AgbmFtZXNwYWNlIChtdXN0IGJlIGVtcHR5KVxuXHQqIGF3YWl0IGNhdGFsb2cuZHJvcE5hbWVzcGFjZSh7IG5hbWVzcGFjZTogWydkZWZhdWx0J10gfSlcblx0KiBgYGBcblx0KlxuXHQqIEByZW1hcmtzXG5cdCogVGhpcyBtZXRob2QgcHJvdmlkZXMgYSBicmlkZ2UgYmV0d2VlbiBTdXBhYmFzZSdzIGJ1Y2tldCBtYW5hZ2VtZW50IGFuZCB0aGUgc3RhbmRhcmRcblx0KiBBcGFjaGUgSWNlYmVyZyBSRVNUIENhdGFsb2cgQVBJLiBUaGUgYnVja2V0IG5hbWUgbWFwcyB0byB0aGUgSWNlYmVyZyB3YXJlaG91c2UgcGFyYW1ldGVyLlxuXHQqIEFsbCBhdXRoZW50aWNhdGlvbiBhbmQgY29uZmlndXJhdGlvbiBpcyBoYW5kbGVkIGF1dG9tYXRpY2FsbHkgdXNpbmcgeW91ciBTdXBhYmFzZSBjcmVkZW50aWFscy5cblx0KlxuXHQqICoqRXJyb3IgSGFuZGxpbmcqKjogSW52YWxpZCBidWNrZXQgbmFtZXMgdGhyb3cgaW1tZWRpYXRlbHkuIEFsbCBjYXRhbG9nXG5cdCogb3BlcmF0aW9ucyByZXR1cm4gYHsgZGF0YSwgZXJyb3IgfWAgd2hlcmUgZXJyb3JzIGFyZSBgSWNlYmVyZ0Vycm9yYCBpbnN0YW5jZXMgZnJvbSBpY2ViZXJnLWpzLlxuXHQqIFVzZSBoZWxwZXIgbWV0aG9kcyBsaWtlIGBlcnJvci5pc05vdEZvdW5kKClgIG9yIGNoZWNrIGBlcnJvci5zdGF0dXNgIGZvciBzcGVjaWZpYyBlcnJvciBoYW5kbGluZy5cblx0KiBVc2UgYC50aHJvd09uRXJyb3IoKWAgb24gdGhlIGFuYWx5dGljcyBjbGllbnQgaWYgeW91IHByZWZlciBleGNlcHRpb25zIGZvciBjYXRhbG9nIG9wZXJhdGlvbnMuXG5cdCpcblx0KiAqKkNsZWFudXAgT3BlcmF0aW9ucyoqOiBXaGVuIHVzaW5nIGBkcm9wVGFibGVgLCB0aGUgYHB1cmdlOiB0cnVlYCBvcHRpb24gcGVybWFuZW50bHlcblx0KiBkZWxldGVzIGFsbCB0YWJsZSBkYXRhLiBXaXRob3V0IGl0LCB0aGUgdGFibGUgaXMgbWFya2VkIGFzIGRlbGV0ZWQgYnV0IGRhdGEgcmVtYWlucy5cblx0KlxuXHQqICoqTGlicmFyeSBEZXBlbmRlbmN5Kio6IFRoZSByZXR1cm5lZCBjYXRhbG9nIHdyYXBzIGBJY2ViZXJnUmVzdENhdGFsb2dgIGZyb20gaWNlYmVyZy1qcy5cblx0KiBGb3IgY29tcGxldGUgQVBJIGRvY3VtZW50YXRpb24gYW5kIGFkdmFuY2VkIHVzYWdlLCByZWZlciB0byB0aGVcblx0KiBbaWNlYmVyZy1qcyBkb2N1bWVudGF0aW9uXShodHRwczovL3N1cGFiYXNlLmdpdGh1Yi5pby9pY2ViZXJnLWpzLykuXG5cdCovXG5cdGZyb20oYnVja2V0TmFtZSkge1xuXHRcdHZhciBfdGhpczQgPSB0aGlzO1xuXHRcdGlmICghaXNWYWxpZEJ1Y2tldE5hbWUoYnVja2V0TmFtZSkpIHRocm93IG5ldyBTdG9yYWdlRXJyb3IoXCJJbnZhbGlkIGJ1Y2tldCBuYW1lOiBGaWxlLCBmb2xkZXIsIGFuZCBidWNrZXQgbmFtZXMgbXVzdCBmb2xsb3cgQVdTIG9iamVjdCBrZXkgbmFtaW5nIGd1aWRlbGluZXMgYW5kIHNob3VsZCBhdm9pZCB0aGUgdXNlIG9mIGFueSBvdGhlciBjaGFyYWN0ZXJzLlwiKTtcblx0XHRjb25zdCBjYXRhbG9nID0gbmV3IEljZWJlcmdSZXN0Q2F0YWxvZyh7XG5cdFx0XHRiYXNlVXJsOiB0aGlzLnVybCxcblx0XHRcdGNhdGFsb2dOYW1lOiBidWNrZXROYW1lLFxuXHRcdFx0YXV0aDoge1xuXHRcdFx0XHR0eXBlOiBcImN1c3RvbVwiLFxuXHRcdFx0XHRnZXRIZWFkZXJzOiBhc3luYyAoKSA9PiBfdGhpczQuaGVhZGVyc1xuXHRcdFx0fSxcblx0XHRcdGZldGNoOiB0aGlzLmZldGNoXG5cdFx0fSk7XG5cdFx0Y29uc3Qgc2hvdWxkVGhyb3dPbkVycm9yID0gdGhpcy5zaG91bGRUaHJvd09uRXJyb3I7XG5cdFx0cmV0dXJuIG5ldyBQcm94eShjYXRhbG9nLCB7IGdldCh0YXJnZXQsIHByb3ApIHtcblx0XHRcdGNvbnN0IHZhbHVlID0gdGFyZ2V0W3Byb3BdO1xuXHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdmFsdWU7XG5cdFx0XHRyZXR1cm4gYXN5bmMgKC4uLmFyZ3MpID0+IHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0ZGF0YTogYXdhaXQgdmFsdWUuYXBwbHkodGFyZ2V0LCBhcmdzKSxcblx0XHRcdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHRpZiAoc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0XHRcdGVycm9yXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9IH0pO1xuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvbGliL3ZlY3RvcnMvY29uc3RhbnRzLnRzXG5jb25zdCBERUZBVUxUX0hFQURFUlMgPSB7XG5cdFwiWC1DbGllbnQtSW5mb1wiOiBgc3RvcmFnZS1qcy8ke3ZlcnNpb259YCxcblx0XCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9saWIvdmVjdG9ycy9lcnJvcnMudHNcbi8qKlxuKiBCYXNlIGVycm9yIGNsYXNzIGZvciBhbGwgU3RvcmFnZSBWZWN0b3JzIGVycm9yc1xuKi9cbnZhciBTdG9yYWdlVmVjdG9yc0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG5cdGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcblx0XHRzdXBlcihtZXNzYWdlKTtcblx0XHR0aGlzLl9faXNTdG9yYWdlVmVjdG9yc0Vycm9yID0gdHJ1ZTtcblx0XHR0aGlzLm5hbWUgPSBcIlN0b3JhZ2VWZWN0b3JzRXJyb3JcIjtcblx0fVxufTtcbi8qKlxuKiBUeXBlIGd1YXJkIHRvIGNoZWNrIGlmIGFuIGVycm9yIGlzIGEgU3RvcmFnZVZlY3RvcnNFcnJvclxuKiBAcGFyYW0gZXJyb3IgLSBUaGUgZXJyb3IgdG8gY2hlY2tcbiogQHJldHVybnMgVHJ1ZSBpZiB0aGUgZXJyb3IgaXMgYSBTdG9yYWdlVmVjdG9yc0Vycm9yXG4qL1xuZnVuY3Rpb24gaXNTdG9yYWdlVmVjdG9yc0Vycm9yKGVycm9yKSB7XG5cdHJldHVybiB0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgJiYgZXJyb3IgIT09IG51bGwgJiYgXCJfX2lzU3RvcmFnZVZlY3RvcnNFcnJvclwiIGluIGVycm9yO1xufVxuLyoqXG4qIEFQSSBlcnJvciByZXR1cm5lZCBmcm9tIFMzIFZlY3RvcnMgc2VydmljZVxuKiBJbmNsdWRlcyBIVFRQIHN0YXR1cyBjb2RlIGFuZCBzZXJ2aWNlLXNwZWNpZmljIGVycm9yIGNvZGVcbiovXG52YXIgU3RvcmFnZVZlY3RvcnNBcGlFcnJvciA9IGNsYXNzIGV4dGVuZHMgU3RvcmFnZVZlY3RvcnNFcnJvciB7XG5cdGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1cywgc3RhdHVzQ29kZSkge1xuXHRcdHN1cGVyKG1lc3NhZ2UpO1xuXHRcdHRoaXMubmFtZSA9IFwiU3RvcmFnZVZlY3RvcnNBcGlFcnJvclwiO1xuXHRcdHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuXHRcdHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG5cdH1cblx0dG9KU09OKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRuYW1lOiB0aGlzLm5hbWUsXG5cdFx0XHRtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG5cdFx0XHRzdGF0dXM6IHRoaXMuc3RhdHVzLFxuXHRcdFx0c3RhdHVzQ29kZTogdGhpcy5zdGF0dXNDb2RlXG5cdFx0fTtcblx0fVxufTtcbi8qKlxuKiBVbmtub3duIGVycm9yIHRoYXQgZG9lc24ndCBtYXRjaCBleHBlY3RlZCBlcnJvciBwYXR0ZXJuc1xuKiBXcmFwcyB0aGUgb3JpZ2luYWwgZXJyb3IgZm9yIGRlYnVnZ2luZ1xuKi9cbnZhciBTdG9yYWdlVmVjdG9yc1Vua25vd25FcnJvciA9IGNsYXNzIGV4dGVuZHMgU3RvcmFnZVZlY3RvcnNFcnJvciB7XG5cdGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9yaWdpbmFsRXJyb3IpIHtcblx0XHRzdXBlcihtZXNzYWdlKTtcblx0XHR0aGlzLm5hbWUgPSBcIlN0b3JhZ2VWZWN0b3JzVW5rbm93bkVycm9yXCI7XG5cdFx0dGhpcy5vcmlnaW5hbEVycm9yID0gb3JpZ2luYWxFcnJvcjtcblx0fVxufTtcbi8qKlxuKiBFcnJvciBjb2RlcyBzcGVjaWZpYyB0byBTMyBWZWN0b3JzIEFQSVxuKiBNYXBzIEFXUyBzZXJ2aWNlIGVycm9ycyB0byBhcHBsaWNhdGlvbi1mcmllbmRseSBlcnJvciBjb2Rlc1xuKi9cbmxldCBTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbihTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSQxKSB7XG5cdC8qKiBJbnRlcm5hbCBzZXJ2ZXIgZmF1bHQgKEhUVFAgNTAwKSAqL1xuXHRTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSQxW1wiSW50ZXJuYWxFcnJvclwiXSA9IFwiSW50ZXJuYWxFcnJvclwiO1xuXHQvKiogUmVzb3VyY2UgYWxyZWFkeSBleGlzdHMgLyBjb25mbGljdCAoSFRUUCA0MDkpICovXG5cdFN0b3JhZ2VWZWN0b3JzRXJyb3JDb2RlJDFbXCJTM1ZlY3RvckNvbmZsaWN0RXhjZXB0aW9uXCJdID0gXCJTM1ZlY3RvckNvbmZsaWN0RXhjZXB0aW9uXCI7XG5cdC8qKiBSZXNvdXJjZSBub3QgZm91bmQgKEhUVFAgNDA0KSAqL1xuXHRTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSQxW1wiUzNWZWN0b3JOb3RGb3VuZEV4Y2VwdGlvblwiXSA9IFwiUzNWZWN0b3JOb3RGb3VuZEV4Y2VwdGlvblwiO1xuXHQvKiogRGVsZXRlIGJ1Y2tldCB3aGlsZSBub3QgZW1wdHkgKEhUVFAgNDAwKSAqL1xuXHRTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSQxW1wiUzNWZWN0b3JCdWNrZXROb3RFbXB0eVwiXSA9IFwiUzNWZWN0b3JCdWNrZXROb3RFbXB0eVwiO1xuXHQvKiogRXhjZWVkcyBidWNrZXQgcXVvdGEvbGltaXQgKEhUVFAgNDAwKSAqL1xuXHRTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSQxW1wiUzNWZWN0b3JNYXhCdWNrZXRzRXhjZWVkZWRcIl0gPSBcIlMzVmVjdG9yTWF4QnVja2V0c0V4Y2VlZGVkXCI7XG5cdC8qKiBFeGNlZWRzIGluZGV4IHF1b3RhL2xpbWl0IChIVFRQIDQwMCkgKi9cblx0U3RvcmFnZVZlY3RvcnNFcnJvckNvZGUkMVtcIlMzVmVjdG9yTWF4SW5kZXhlc0V4Y2VlZGVkXCJdID0gXCJTM1ZlY3Rvck1heEluZGV4ZXNFeGNlZWRlZFwiO1xuXHRyZXR1cm4gU3RvcmFnZVZlY3RvcnNFcnJvckNvZGUkMTtcbn0oe30pO1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvbGliL3ZlY3RvcnMvaGVscGVycy50c1xuLyoqXG4qIFJlc29sdmVzIHRoZSBmZXRjaCBpbXBsZW1lbnRhdGlvbiB0byB1c2VcbiogVXNlcyBjdXN0b20gZmV0Y2ggaWYgcHJvdmlkZWQsIG90aGVyd2lzZSB1c2VzIG5hdGl2ZSBmZXRjaFxuKlxuKiBAcGFyYW0gY3VzdG9tRmV0Y2ggLSBPcHRpb25hbCBjdXN0b20gZmV0Y2ggaW1wbGVtZW50YXRpb25cbiogQHJldHVybnMgUmVzb2x2ZWQgZmV0Y2ggZnVuY3Rpb25cbiovXG5jb25zdCByZXNvbHZlRmV0Y2ggPSAoY3VzdG9tRmV0Y2gpID0+IHtcblx0aWYgKGN1c3RvbUZldGNoKSByZXR1cm4gKC4uLmFyZ3MpID0+IGN1c3RvbUZldGNoKC4uLmFyZ3MpO1xuXHRyZXR1cm4gKC4uLmFyZ3MpID0+IGZldGNoKC4uLmFyZ3MpO1xufTtcbi8qKlxuKiBSZXNvbHZlcyB0aGUgUmVzcG9uc2UgY29uc3RydWN0b3IgdG8gdXNlXG4qIFJldHVybnMgbmF0aXZlIFJlc3BvbnNlIGNvbnN0cnVjdG9yXG4qXG4qIEByZXR1cm5zIFJlc3BvbnNlIGNvbnN0cnVjdG9yXG4qL1xuY29uc3QgcmVzb2x2ZVJlc3BvbnNlID0gKCkgPT4ge1xuXHRyZXR1cm4gUmVzcG9uc2U7XG59O1xuLyoqXG4qIERldGVybWluZSBpZiBpbnB1dCBpcyBhIHBsYWluIG9iamVjdFxuKiBBbiBvYmplY3QgaXMgcGxhaW4gaWYgaXQncyBjcmVhdGVkIGJ5IGVpdGhlciB7fSwgbmV3IE9iamVjdCgpLCBvciBPYmplY3QuY3JlYXRlKG51bGwpXG4qXG4qIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrXG4qIEByZXR1cm5zIFRydWUgaWYgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3RcbiogQHNvdXJjZSBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL2lzLXBsYWluLW9ialxuKi9cbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAodmFsdWUpID0+IHtcblx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuXHRyZXR1cm4gKHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGUgfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvdHlwZSkgPT09IG51bGwpICYmICEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIHZhbHVlKSAmJiAhKFN5bWJvbC5pdGVyYXRvciBpbiB2YWx1ZSk7XG59O1xuLyoqXG4qIE5vcm1hbGl6ZXMgYSBudW1iZXIgYXJyYXkgdG8gZmxvYXQzMiBmb3JtYXRcbiogRW5zdXJlcyBhbGwgdmVjdG9yIHZhbHVlcyBhcmUgdmFsaWQgMzItYml0IGZsb2F0c1xuKlxuKiBAcGFyYW0gdmFsdWVzIC0gQXJyYXkgb2YgbnVtYmVycyB0byBub3JtYWxpemVcbiogQHJldHVybnMgTm9ybWFsaXplZCBmbG9hdDMyIGFycmF5XG4qL1xuY29uc3Qgbm9ybWFsaXplVG9GbG9hdDMyID0gKHZhbHVlcykgPT4ge1xuXHRyZXR1cm4gQXJyYXkuZnJvbShuZXcgRmxvYXQzMkFycmF5KHZhbHVlcykpO1xufTtcbi8qKlxuKiBWYWxpZGF0ZXMgdmVjdG9yIGRpbWVuc2lvbnMgbWF0Y2ggZXhwZWN0ZWQgZGltZW5zaW9uXG4qIFRocm93cyBlcnJvciBpZiBkaW1lbnNpb25zIGRvbid0IG1hdGNoXG4qXG4qIEBwYXJhbSB2ZWN0b3IgLSBWZWN0b3IgZGF0YSB0byB2YWxpZGF0ZVxuKiBAcGFyYW0gZXhwZWN0ZWREaW1lbnNpb24gLSBFeHBlY3RlZCB2ZWN0b3IgZGltZW5zaW9uXG4qIEB0aHJvd3MgRXJyb3IgaWYgZGltZW5zaW9ucyBkb24ndCBtYXRjaFxuKi9cbmNvbnN0IHZhbGlkYXRlVmVjdG9yRGltZW5zaW9uID0gKHZlY3RvciwgZXhwZWN0ZWREaW1lbnNpb24pID0+IHtcblx0aWYgKGV4cGVjdGVkRGltZW5zaW9uICE9PSB2b2lkIDAgJiYgdmVjdG9yLmZsb2F0MzIubGVuZ3RoICE9PSBleHBlY3RlZERpbWVuc2lvbikgdGhyb3cgbmV3IEVycm9yKGBWZWN0b3IgZGltZW5zaW9uIG1pc21hdGNoOiBleHBlY3RlZCAke2V4cGVjdGVkRGltZW5zaW9ufSwgZ290ICR7dmVjdG9yLmZsb2F0MzIubGVuZ3RofWApO1xufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2xpYi92ZWN0b3JzL2ZldGNoLnRzXG4vKipcbiogRXh0cmFjdHMgZXJyb3IgbWVzc2FnZSBmcm9tIHZhcmlvdXMgZXJyb3IgcmVzcG9uc2UgZm9ybWF0c1xuKiBAcGFyYW0gZXJyIC0gRXJyb3Igb2JqZWN0IGZyb20gQVBJXG4qIEByZXR1cm5zIEh1bWFuLXJlYWRhYmxlIGVycm9yIG1lc3NhZ2VcbiovXG5jb25zdCBfZ2V0RXJyb3JNZXNzYWdlID0gKGVycikgPT4gZXJyLm1zZyB8fCBlcnIubWVzc2FnZSB8fCBlcnIuZXJyb3JfZGVzY3JpcHRpb24gfHwgZXJyLmVycm9yIHx8IEpTT04uc3RyaW5naWZ5KGVycik7XG4vKipcbiogSGFuZGxlcyBmZXRjaCBlcnJvcnMgYW5kIGNvbnZlcnRzIHRoZW0gdG8gU3RvcmFnZVZlY3RvcnMgZXJyb3IgdHlwZXNcbiogQHBhcmFtIGVycm9yIC0gVGhlIGVycm9yIGNhdWdodCBmcm9tIGZldGNoXG4qIEBwYXJhbSByZWplY3QgLSBQcm9taXNlIHJlamVjdGlvbiBmdW5jdGlvblxuKiBAcGFyYW0gb3B0aW9ucyAtIEZldGNoIG9wdGlvbnMgdGhhdCBtYXkgYWZmZWN0IGVycm9yIGhhbmRsaW5nXG4qL1xuY29uc3QgaGFuZGxlRXJyb3IgPSBhc3luYyAoZXJyb3IsIHJlamVjdCwgb3B0aW9ucykgPT4ge1xuXHRpZiAoZXJyb3IgJiYgdHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiICYmIFwic3RhdHVzXCIgaW4gZXJyb3IgJiYgXCJva1wiIGluIGVycm9yICYmIHR5cGVvZiBlcnJvci5zdGF0dXMgPT09IFwibnVtYmVyXCIgJiYgIShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubm9SZXNvbHZlSnNvbikpIHtcblx0XHRjb25zdCBzdGF0dXMgPSBlcnJvci5zdGF0dXMgfHwgNTAwO1xuXHRcdGNvbnN0IHJlc3BvbnNlRXJyb3IgPSBlcnJvcjtcblx0XHRpZiAodHlwZW9mIHJlc3BvbnNlRXJyb3IuanNvbiA9PT0gXCJmdW5jdGlvblwiKSByZXNwb25zZUVycm9yLmpzb24oKS50aGVuKChlcnIpID0+IHtcblx0XHRcdGNvbnN0IHN0YXR1c0NvZGUgPSAoZXJyID09PSBudWxsIHx8IGVyciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyLnN0YXR1c0NvZGUpIHx8IChlcnIgPT09IG51bGwgfHwgZXJyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnIuY29kZSkgfHwgc3RhdHVzICsgXCJcIjtcblx0XHRcdHJlamVjdChuZXcgU3RvcmFnZVZlY3RvcnNBcGlFcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGVyciksIHN0YXR1cywgc3RhdHVzQ29kZSkpO1xuXHRcdH0pLmNhdGNoKCgpID0+IHtcblx0XHRcdGNvbnN0IHN0YXR1c0NvZGUgPSBzdGF0dXMgKyBcIlwiO1xuXHRcdFx0cmVqZWN0KG5ldyBTdG9yYWdlVmVjdG9yc0FwaUVycm9yKHJlc3BvbnNlRXJyb3Iuc3RhdHVzVGV4dCB8fCBgSFRUUCAke3N0YXR1c30gZXJyb3JgLCBzdGF0dXMsIHN0YXR1c0NvZGUpKTtcblx0XHR9KTtcblx0XHRlbHNlIHtcblx0XHRcdGNvbnN0IHN0YXR1c0NvZGUgPSBzdGF0dXMgKyBcIlwiO1xuXHRcdFx0cmVqZWN0KG5ldyBTdG9yYWdlVmVjdG9yc0FwaUVycm9yKHJlc3BvbnNlRXJyb3Iuc3RhdHVzVGV4dCB8fCBgSFRUUCAke3N0YXR1c30gZXJyb3JgLCBzdGF0dXMsIHN0YXR1c0NvZGUpKTtcblx0XHR9XG5cdH0gZWxzZSByZWplY3QobmV3IFN0b3JhZ2VWZWN0b3JzVW5rbm93bkVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZXJyb3IpLCBlcnJvcikpO1xufTtcbi8qKlxuKiBCdWlsZHMgcmVxdWVzdCBwYXJhbWV0ZXJzIGZvciBmZXRjaCBjYWxsc1xuKiBAcGFyYW0gbWV0aG9kIC0gSFRUUCBtZXRob2RcbiogQHBhcmFtIG9wdGlvbnMgLSBDdXN0b20gZmV0Y2ggb3B0aW9uc1xuKiBAcGFyYW0gcGFyYW1ldGVycyAtIEFkZGl0aW9uYWwgZmV0Y2ggcGFyYW1ldGVycyBsaWtlIEFib3J0U2lnbmFsXG4qIEBwYXJhbSBib2R5IC0gUmVxdWVzdCBib2R5ICh3aWxsIGJlIEpTT04gc3RyaW5naWZpZWQgaWYgcGxhaW4gb2JqZWN0KVxuKiBAcmV0dXJucyBDb21wbGV0ZSBmZXRjaCByZXF1ZXN0IHBhcmFtZXRlcnNcbiovXG5jb25zdCBfZ2V0UmVxdWVzdFBhcmFtcyA9IChtZXRob2QsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpID0+IHtcblx0Y29uc3QgcGFyYW1zID0ge1xuXHRcdG1ldGhvZCxcblx0XHRoZWFkZXJzOiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMpIHx8IHt9XG5cdH07XG5cdGlmIChtZXRob2QgPT09IFwiR0VUXCIgfHwgIWJvZHkpIHJldHVybiBwYXJhbXM7XG5cdGlmIChpc1BsYWluT2JqZWN0KGJvZHkpKSB7XG5cdFx0cGFyYW1zLmhlYWRlcnMgPSBfb2JqZWN0U3ByZWFkMih7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzKTtcblx0XHRwYXJhbXMuYm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkpO1xuXHR9IGVsc2UgcGFyYW1zLmJvZHkgPSBib2R5O1xuXHRyZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHBhcmFtcyksIHBhcmFtZXRlcnMpO1xufTtcbi8qKlxuKiBJbnRlcm5hbCByZXF1ZXN0IGhhbmRsZXIgdGhhdCB3cmFwcyBmZXRjaCB3aXRoIGVycm9yIGhhbmRsaW5nXG4qIEBwYXJhbSBmZXRjaGVyIC0gRmV0Y2ggZnVuY3Rpb24gdG8gdXNlXG4qIEBwYXJhbSBtZXRob2QgLSBIVFRQIG1ldGhvZFxuKiBAcGFyYW0gdXJsIC0gUmVxdWVzdCBVUkxcbiogQHBhcmFtIG9wdGlvbnMgLSBDdXN0b20gZmV0Y2ggb3B0aW9uc1xuKiBAcGFyYW0gcGFyYW1ldGVycyAtIEFkZGl0aW9uYWwgZmV0Y2ggcGFyYW1ldGVyc1xuKiBAcGFyYW0gYm9keSAtIFJlcXVlc3QgYm9keVxuKiBAcmV0dXJucyBQcm9taXNlIHdpdGggcGFyc2VkIHJlc3BvbnNlIG9yIGVycm9yXG4qL1xuYXN5bmMgZnVuY3Rpb24gX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgbWV0aG9kLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRmZXRjaGVyKHVybCwgX2dldFJlcXVlc3RQYXJhbXMobWV0aG9kLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KSkudGhlbigocmVzdWx0KSA9PiB7XG5cdFx0XHRpZiAoIXJlc3VsdC5vaykgdGhyb3cgcmVzdWx0O1xuXHRcdFx0aWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ub1Jlc29sdmVKc29uKSByZXR1cm4gcmVzdWx0O1xuXHRcdFx0Y29uc3QgY29udGVudFR5cGUgPSByZXN1bHQuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik7XG5cdFx0XHRpZiAoIWNvbnRlbnRUeXBlIHx8ICFjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHJldHVybiB7fTtcblx0XHRcdHJldHVybiByZXN1bHQuanNvbigpO1xuXHRcdH0pLnRoZW4oKGRhdGEpID0+IHJlc29sdmUoZGF0YSkpLmNhdGNoKChlcnJvcikgPT4gaGFuZGxlRXJyb3IoZXJyb3IsIHJlamVjdCwgb3B0aW9ucykpO1xuXHR9KTtcbn1cbi8qKlxuKiBQZXJmb3JtcyBhIFBPU1QgcmVxdWVzdFxuKiBAcGFyYW0gZmV0Y2hlciAtIEZldGNoIGZ1bmN0aW9uIHRvIHVzZVxuKiBAcGFyYW0gdXJsIC0gUmVxdWVzdCBVUkxcbiogQHBhcmFtIGJvZHkgLSBSZXF1ZXN0IGJvZHkgdG8gYmUgSlNPTiBzdHJpbmdpZmllZFxuKiBAcGFyYW0gb3B0aW9ucyAtIEN1c3RvbSBmZXRjaCBvcHRpb25zXG4qIEBwYXJhbSBwYXJhbWV0ZXJzIC0gQWRkaXRpb25hbCBmZXRjaCBwYXJhbWV0ZXJzXG4qIEByZXR1cm5zIFByb21pc2Ugd2l0aCBwYXJzZWQgcmVzcG9uc2VcbiovXG5hc3luYyBmdW5jdGlvbiBwb3N0KGZldGNoZXIsIHVybCwgYm9keSwgb3B0aW9ucywgcGFyYW1ldGVycykge1xuXHRyZXR1cm4gX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgXCJQT1NUXCIsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSk7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9saWIvdmVjdG9ycy9WZWN0b3JJbmRleEFwaS50c1xuLyoqXG4qIEBoaWRkZW5cbiogQmFzZSBpbXBsZW1lbnRhdGlvbiBmb3IgdmVjdG9yIGluZGV4IG9wZXJhdGlvbnMuXG4qIFVzZSB7QGxpbmsgVmVjdG9yQnVja2V0U2NvcGV9IHZpYSBgc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2J1Y2tldCcpYCBpbnN0ZWFkLlxuKi9cbnZhciBWZWN0b3JJbmRleEFwaSA9IGNsYXNzIHtcblx0LyoqIENyZWF0ZXMgYSBuZXcgVmVjdG9ySW5kZXhBcGkgaW5zdGFuY2UgKi9cblx0Y29uc3RydWN0b3IodXJsLCBoZWFkZXJzID0ge30sIGZldGNoJDEpIHtcblx0XHR0aGlzLnNob3VsZFRocm93T25FcnJvciA9IGZhbHNlO1xuXHRcdHRoaXMudXJsID0gdXJsLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcblx0XHR0aGlzLmhlYWRlcnMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9IRUFERVJTKSwgaGVhZGVycyk7XG5cdFx0dGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaChmZXRjaCQxKTtcblx0fVxuXHQvKiogRW5hYmxlIHRocm93aW5nIGVycm9ycyBpbnN0ZWFkIG9mIHJldHVybmluZyB0aGVtIGluIHRoZSByZXNwb25zZSAqL1xuXHR0aHJvd09uRXJyb3IoKSB7XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSB0cnVlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKiBDcmVhdGVzIGEgbmV3IHZlY3RvciBpbmRleCB3aXRoaW4gYSBidWNrZXQgKi9cblx0YXN5bmMgY3JlYXRlSW5kZXgob3B0aW9ucykge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHBvc3QoX3RoaXMuZmV0Y2gsIGAke190aGlzLnVybH0vQ3JlYXRlSW5kZXhgLCBvcHRpb25zLCB7IGhlYWRlcnM6IF90aGlzLmhlYWRlcnMgfSkgfHwge30sXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VWZWN0b3JzRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKiogUmV0cmlldmVzIG1ldGFkYXRhIGZvciBhIHNwZWNpZmljIHZlY3RvciBpbmRleCAqL1xuXHRhc3luYyBnZXRJbmRleCh2ZWN0b3JCdWNrZXROYW1lLCBpbmRleE5hbWUpIHtcblx0XHR2YXIgX3RoaXMyID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgcG9zdChfdGhpczIuZmV0Y2gsIGAke190aGlzMi51cmx9L0dldEluZGV4YCwge1xuXHRcdFx0XHRcdHZlY3RvckJ1Y2tldE5hbWUsXG5cdFx0XHRcdFx0aW5kZXhOYW1lXG5cdFx0XHRcdH0sIHsgaGVhZGVyczogX3RoaXMyLmhlYWRlcnMgfSksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMyLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlVmVjdG9yc0Vycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqIExpc3RzIHZlY3RvciBpbmRleGVzIHdpdGhpbiBhIGJ1Y2tldCB3aXRoIG9wdGlvbmFsIGZpbHRlcmluZyBhbmQgcGFnaW5hdGlvbiAqL1xuXHRhc3luYyBsaXN0SW5kZXhlcyhvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzMyA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHBvc3QoX3RoaXMzLmZldGNoLCBgJHtfdGhpczMudXJsfS9MaXN0SW5kZXhlc2AsIG9wdGlvbnMsIHsgaGVhZGVyczogX3RoaXMzLmhlYWRlcnMgfSksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMzLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlVmVjdG9yc0Vycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqIERlbGV0ZXMgYSB2ZWN0b3IgaW5kZXggYW5kIGFsbCBpdHMgZGF0YSAqL1xuXHRhc3luYyBkZWxldGVJbmRleCh2ZWN0b3JCdWNrZXROYW1lLCBpbmRleE5hbWUpIHtcblx0XHR2YXIgX3RoaXM0ID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgcG9zdChfdGhpczQuZmV0Y2gsIGAke190aGlzNC51cmx9L0RlbGV0ZUluZGV4YCwge1xuXHRcdFx0XHRcdHZlY3RvckJ1Y2tldE5hbWUsXG5cdFx0XHRcdFx0aW5kZXhOYW1lXG5cdFx0XHRcdH0sIHsgaGVhZGVyczogX3RoaXM0LmhlYWRlcnMgfSkgfHwge30sXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXM0LnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlVmVjdG9yc0Vycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9saWIvdmVjdG9ycy9WZWN0b3JEYXRhQXBpLnRzXG4vKipcbiogQGhpZGRlblxuKiBCYXNlIGltcGxlbWVudGF0aW9uIGZvciB2ZWN0b3IgZGF0YSBvcGVyYXRpb25zLlxuKiBVc2Uge0BsaW5rIFZlY3RvckluZGV4U2NvcGV9IHZpYSBgc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2J1Y2tldCcpLmluZGV4KCdpZHgnKWAgaW5zdGVhZC5cbiovXG52YXIgVmVjdG9yRGF0YUFwaSA9IGNsYXNzIHtcblx0LyoqIENyZWF0ZXMgYSBuZXcgVmVjdG9yRGF0YUFwaSBpbnN0YW5jZSAqL1xuXHRjb25zdHJ1Y3Rvcih1cmwsIGhlYWRlcnMgPSB7fSwgZmV0Y2gkMSkge1xuXHRcdHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gZmFsc2U7XG5cdFx0dGhpcy51cmwgPSB1cmwucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuXHRcdHRoaXMuaGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBERUZBVUxUX0hFQURFUlMpLCBoZWFkZXJzKTtcblx0XHR0aGlzLmZldGNoID0gcmVzb2x2ZUZldGNoKGZldGNoJDEpO1xuXHR9XG5cdC8qKiBFbmFibGUgdGhyb3dpbmcgZXJyb3JzIGluc3RlYWQgb2YgcmV0dXJuaW5nIHRoZW0gaW4gdGhlIHJlc3BvbnNlICovXG5cdHRocm93T25FcnJvcigpIHtcblx0XHR0aGlzLnNob3VsZFRocm93T25FcnJvciA9IHRydWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqIEluc2VydHMgb3IgdXBkYXRlcyB2ZWN0b3JzIGluIGJhdGNoICgxLTUwMCBwZXIgcmVxdWVzdCkgKi9cblx0YXN5bmMgcHV0VmVjdG9ycyhvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0aWYgKG9wdGlvbnMudmVjdG9ycy5sZW5ndGggPCAxIHx8IG9wdGlvbnMudmVjdG9ycy5sZW5ndGggPiA1MDApIHRocm93IG5ldyBFcnJvcihcIlZlY3RvciBiYXRjaCBzaXplIG11c3QgYmUgYmV0d2VlbiAxIGFuZCA1MDAgaXRlbXNcIik7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBwb3N0KF90aGlzLmZldGNoLCBgJHtfdGhpcy51cmx9L1B1dFZlY3RvcnNgLCBvcHRpb25zLCB7IGhlYWRlcnM6IF90aGlzLmhlYWRlcnMgfSkgfHwge30sXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VWZWN0b3JzRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKiogUmV0cmlldmVzIHZlY3RvcnMgYnkgdGhlaXIga2V5cyBpbiBiYXRjaCAqL1xuXHRhc3luYyBnZXRWZWN0b3JzKG9wdGlvbnMpIHtcblx0XHR2YXIgX3RoaXMyID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgcG9zdChfdGhpczIuZmV0Y2gsIGAke190aGlzMi51cmx9L0dldFZlY3RvcnNgLCBvcHRpb25zLCB7IGhlYWRlcnM6IF90aGlzMi5oZWFkZXJzIH0pLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzMi5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZVZlY3RvcnNFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKiBMaXN0cyB2ZWN0b3JzIGluIGFuIGluZGV4IHdpdGggcGFnaW5hdGlvbiAqL1xuXHRhc3luYyBsaXN0VmVjdG9ycyhvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzMyA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdGlmIChvcHRpb25zLnNlZ21lbnRDb3VudCAhPT0gdm9pZCAwKSB7XG5cdFx0XHRcdGlmIChvcHRpb25zLnNlZ21lbnRDb3VudCA8IDEgfHwgb3B0aW9ucy5zZWdtZW50Q291bnQgPiAxNikgdGhyb3cgbmV3IEVycm9yKFwic2VnbWVudENvdW50IG11c3QgYmUgYmV0d2VlbiAxIGFuZCAxNlwiKTtcblx0XHRcdFx0aWYgKG9wdGlvbnMuc2VnbWVudEluZGV4ICE9PSB2b2lkIDApIHtcblx0XHRcdFx0XHRpZiAob3B0aW9ucy5zZWdtZW50SW5kZXggPCAwIHx8IG9wdGlvbnMuc2VnbWVudEluZGV4ID49IG9wdGlvbnMuc2VnbWVudENvdW50KSB0aHJvdyBuZXcgRXJyb3IoYHNlZ21lbnRJbmRleCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgJHtvcHRpb25zLnNlZ21lbnRDb3VudCAtIDF9YCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHBvc3QoX3RoaXMzLmZldGNoLCBgJHtfdGhpczMudXJsfS9MaXN0VmVjdG9yc2AsIG9wdGlvbnMsIHsgaGVhZGVyczogX3RoaXMzLmhlYWRlcnMgfSksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMzLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlVmVjdG9yc0Vycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqIFF1ZXJpZXMgZm9yIHNpbWlsYXIgdmVjdG9ycyB1c2luZyBhcHByb3hpbWF0ZSBuZWFyZXN0IG5laWdoYm9yIHNlYXJjaCAqL1xuXHRhc3luYyBxdWVyeVZlY3RvcnMob3B0aW9ucykge1xuXHRcdHZhciBfdGhpczQgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBwb3N0KF90aGlzNC5mZXRjaCwgYCR7X3RoaXM0LnVybH0vUXVlcnlWZWN0b3JzYCwgb3B0aW9ucywgeyBoZWFkZXJzOiBfdGhpczQuaGVhZGVycyB9KSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczQuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VWZWN0b3JzRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKiogRGVsZXRlcyB2ZWN0b3JzIGJ5IHRoZWlyIGtleXMgaW4gYmF0Y2ggKDEtNTAwIHBlciByZXF1ZXN0KSAqL1xuXHRhc3luYyBkZWxldGVWZWN0b3JzKG9wdGlvbnMpIHtcblx0XHR2YXIgX3RoaXM1ID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0aWYgKG9wdGlvbnMua2V5cy5sZW5ndGggPCAxIHx8IG9wdGlvbnMua2V5cy5sZW5ndGggPiA1MDApIHRocm93IG5ldyBFcnJvcihcIktleXMgYmF0Y2ggc2l6ZSBtdXN0IGJlIGJldHdlZW4gMSBhbmQgNTAwIGl0ZW1zXCIpO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgcG9zdChfdGhpczUuZmV0Y2gsIGAke190aGlzNS51cmx9L0RlbGV0ZVZlY3RvcnNgLCBvcHRpb25zLCB7IGhlYWRlcnM6IF90aGlzNS5oZWFkZXJzIH0pIHx8IHt9LFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzNS5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZVZlY3RvcnNFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvbGliL3ZlY3RvcnMvVmVjdG9yQnVja2V0QXBpLnRzXG4vKipcbiogQGhpZGRlblxuKiBCYXNlIGltcGxlbWVudGF0aW9uIGZvciB2ZWN0b3IgYnVja2V0IG9wZXJhdGlvbnMuXG4qIFVzZSB7QGxpbmsgU3RvcmFnZVZlY3RvcnNDbGllbnR9IHZpYSBgc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzYCBpbnN0ZWFkLlxuKi9cbnZhciBWZWN0b3JCdWNrZXRBcGkgPSBjbGFzcyB7XG5cdC8qKiBDcmVhdGVzIGEgbmV3IFZlY3RvckJ1Y2tldEFwaSBpbnN0YW5jZSAqL1xuXHRjb25zdHJ1Y3Rvcih1cmwsIGhlYWRlcnMgPSB7fSwgZmV0Y2gkMSkge1xuXHRcdHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gZmFsc2U7XG5cdFx0dGhpcy51cmwgPSB1cmwucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuXHRcdHRoaXMuaGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBERUZBVUxUX0hFQURFUlMpLCBoZWFkZXJzKTtcblx0XHR0aGlzLmZldGNoID0gcmVzb2x2ZUZldGNoKGZldGNoJDEpO1xuXHR9XG5cdC8qKiBFbmFibGUgdGhyb3dpbmcgZXJyb3JzIGluc3RlYWQgb2YgcmV0dXJuaW5nIHRoZW0gaW4gdGhlIHJlc3BvbnNlICovXG5cdHRocm93T25FcnJvcigpIHtcblx0XHR0aGlzLnNob3VsZFRocm93T25FcnJvciA9IHRydWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqIENyZWF0ZXMgYSBuZXcgdmVjdG9yIGJ1Y2tldCAqL1xuXHRhc3luYyBjcmVhdGVCdWNrZXQodmVjdG9yQnVja2V0TmFtZSkge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHBvc3QoX3RoaXMuZmV0Y2gsIGAke190aGlzLnVybH0vQ3JlYXRlVmVjdG9yQnVja2V0YCwgeyB2ZWN0b3JCdWNrZXROYW1lIH0sIHsgaGVhZGVyczogX3RoaXMuaGVhZGVycyB9KSB8fCB7fSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZVZlY3RvcnNFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKiBSZXRyaWV2ZXMgbWV0YWRhdGEgZm9yIGEgc3BlY2lmaWMgdmVjdG9yIGJ1Y2tldCAqL1xuXHRhc3luYyBnZXRCdWNrZXQodmVjdG9yQnVja2V0TmFtZSkge1xuXHRcdHZhciBfdGhpczIgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBwb3N0KF90aGlzMi5mZXRjaCwgYCR7X3RoaXMyLnVybH0vR2V0VmVjdG9yQnVja2V0YCwgeyB2ZWN0b3JCdWNrZXROYW1lIH0sIHsgaGVhZGVyczogX3RoaXMyLmhlYWRlcnMgfSksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMyLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlVmVjdG9yc0Vycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqIExpc3RzIHZlY3RvciBidWNrZXRzIHdpdGggb3B0aW9uYWwgZmlsdGVyaW5nIGFuZCBwYWdpbmF0aW9uICovXG5cdGFzeW5jIGxpc3RCdWNrZXRzKG9wdGlvbnMgPSB7fSkge1xuXHRcdHZhciBfdGhpczMgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBwb3N0KF90aGlzMy5mZXRjaCwgYCR7X3RoaXMzLnVybH0vTGlzdFZlY3RvckJ1Y2tldHNgLCBvcHRpb25zLCB7IGhlYWRlcnM6IF90aGlzMy5oZWFkZXJzIH0pLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzMy5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZVZlY3RvcnNFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKiBEZWxldGVzIGEgdmVjdG9yIGJ1Y2tldCAobXVzdCBiZSBlbXB0eSBmaXJzdCkgKi9cblx0YXN5bmMgZGVsZXRlQnVja2V0KHZlY3RvckJ1Y2tldE5hbWUpIHtcblx0XHR2YXIgX3RoaXM0ID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgcG9zdChfdGhpczQuZmV0Y2gsIGAke190aGlzNC51cmx9L0RlbGV0ZVZlY3RvckJ1Y2tldGAsIHsgdmVjdG9yQnVja2V0TmFtZSB9LCB7IGhlYWRlcnM6IF90aGlzNC5oZWFkZXJzIH0pIHx8IHt9LFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzNC5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZVZlY3RvcnNFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvbGliL3ZlY3RvcnMvU3RvcmFnZVZlY3RvcnNDbGllbnQudHNcbi8qKlxuKlxuKiBAYWxwaGFcbipcbiogTWFpbiBjbGllbnQgZm9yIGludGVyYWN0aW5nIHdpdGggUzMgVmVjdG9ycyBBUElcbiogUHJvdmlkZXMgYWNjZXNzIHRvIGJ1Y2tldCwgaW5kZXgsIGFuZCB2ZWN0b3IgZGF0YSBvcGVyYXRpb25zXG4qXG4qICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG4qXG4qICoqVXNhZ2UgUGF0dGVybnM6KipcbipcbiogYGBgdHlwZXNjcmlwdFxuKiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuKiAgLnN0b3JhZ2VcbiogIC52ZWN0b3JzXG4qICAuY3JlYXRlQnVja2V0KCdlbWJlZGRpbmdzLXByb2QnKVxuKlxuKiAvLyBBY2Nlc3MgaW5kZXggb3BlcmF0aW9ucyB2aWEgYnVja2V0c1xuKiBjb25zdCBidWNrZXQgPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJylcbiogYXdhaXQgYnVja2V0LmNyZWF0ZUluZGV4KHtcbiogICBpbmRleE5hbWU6ICdkb2N1bWVudHMnLFxuKiAgIGRhdGFUeXBlOiAnZmxvYXQzMicsXG4qICAgZGltZW5zaW9uOiAxNTM2LFxuKiAgIGRpc3RhbmNlTWV0cmljOiAnY29zaW5lJ1xuKiB9KVxuKlxuKiAvLyBBY2Nlc3MgdmVjdG9yIG9wZXJhdGlvbnMgdmlhIGluZGV4XG4qIGNvbnN0IGluZGV4ID0gYnVja2V0LmluZGV4KCdkb2N1bWVudHMnKVxuKiBhd2FpdCBpbmRleC5wdXRWZWN0b3JzKHtcbiogICB2ZWN0b3JzOiBbXG4qICAgICB7IGtleTogJ2RvYy0xJywgZGF0YTogeyBmbG9hdDMyOiBbLi4uXSB9LCBtZXRhZGF0YTogeyB0aXRsZTogJ0ludHJvJyB9IH1cbiogICBdXG4qIH0pXG4qXG4qIC8vIFF1ZXJ5IHNpbWlsYXIgdmVjdG9yc1xuKiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGluZGV4LnF1ZXJ5VmVjdG9ycyh7XG4qICAgcXVlcnlWZWN0b3I6IHsgZmxvYXQzMjogWy4uLl0gfSxcbiogICB0b3BLOiA1LFxuKiAgIHJldHVybkRpc3RhbmNlOiB0cnVlXG4qIH0pXG4qIGBgYFxuKi9cbnZhciBTdG9yYWdlVmVjdG9yc0NsaWVudCA9IGNsYXNzIGV4dGVuZHMgVmVjdG9yQnVja2V0QXBpIHtcblx0LyoqXG5cdCogQGFscGhhXG5cdCpcblx0KiBDcmVhdGVzIGEgU3RvcmFnZVZlY3RvcnNDbGllbnQgdGhhdCBjYW4gbWFuYWdlIGJ1Y2tldHMsIGluZGV4ZXMsIGFuZCB2ZWN0b3JzLlxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEBwYXJhbSB1cmwgLSBCYXNlIFVSTCBvZiB0aGUgU3RvcmFnZSBWZWN0b3JzIFJFU1QgQVBJLlxuXHQqIEBwYXJhbSBvcHRpb25zLmhlYWRlcnMgLSBPcHRpb25hbCBoZWFkZXJzIChmb3IgZXhhbXBsZSBgQXV0aG9yaXphdGlvbmApIGFwcGxpZWQgdG8gZXZlcnkgcmVxdWVzdC5cblx0KiBAcGFyYW0gb3B0aW9ucy5mZXRjaCAtIE9wdGlvbmFsIGN1c3RvbSBgZmV0Y2hgIGltcGxlbWVudGF0aW9uIGZvciBub24tYnJvd3NlciBydW50aW1lcy5cblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGNsaWVudCA9IG5ldyBTdG9yYWdlVmVjdG9yc0NsaWVudCh1cmwsIG9wdGlvbnMpXG5cdCogYGBgXG5cdCovXG5cdGNvbnN0cnVjdG9yKHVybCwgb3B0aW9ucyA9IHt9KSB7XG5cdFx0c3VwZXIodXJsLCBvcHRpb25zLmhlYWRlcnMgfHwge30sIG9wdGlvbnMuZmV0Y2gpO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBBY2Nlc3Mgb3BlcmF0aW9ucyBmb3IgYSBzcGVjaWZpYyB2ZWN0b3IgYnVja2V0XG5cdCogUmV0dXJucyBhIHNjb3BlZCBjbGllbnQgZm9yIGluZGV4IGFuZCB2ZWN0b3Igb3BlcmF0aW9ucyB3aXRoaW4gdGhlIGJ1Y2tldFxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEBwYXJhbSB2ZWN0b3JCdWNrZXROYW1lIC0gTmFtZSBvZiB0aGUgdmVjdG9yIGJ1Y2tldFxuXHQqIEByZXR1cm5zIEJ1Y2tldC1zY29wZWQgY2xpZW50IHdpdGggaW5kZXggYW5kIHZlY3RvciBvcGVyYXRpb25zXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCBidWNrZXQgPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJylcblx0KiBgYGBcblx0Ki9cblx0ZnJvbSh2ZWN0b3JCdWNrZXROYW1lKSB7XG5cdFx0cmV0dXJuIG5ldyBWZWN0b3JCdWNrZXRTY29wZSh0aGlzLnVybCwgdGhpcy5oZWFkZXJzLCB2ZWN0b3JCdWNrZXROYW1lLCB0aGlzLmZldGNoKTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogQ3JlYXRlcyBhIG5ldyB2ZWN0b3IgYnVja2V0XG5cdCogVmVjdG9yIGJ1Y2tldHMgYXJlIGNvbnRhaW5lcnMgZm9yIHZlY3RvciBpbmRleGVzIGFuZCB0aGVpciBkYXRhXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIHZlY3RvckJ1Y2tldE5hbWUgLSBVbmlxdWUgbmFtZSBmb3IgdGhlIHZlY3RvciBidWNrZXRcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggZW1wdHkgcmVzcG9uc2Ugb24gc3VjY2VzcyBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAudmVjdG9yc1xuXHQqICAgLmNyZWF0ZUJ1Y2tldCgnZW1iZWRkaW5ncy1wcm9kJylcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgY3JlYXRlQnVja2V0KHZlY3RvckJ1Y2tldE5hbWUpIHtcblx0XHR2YXIgX3N1cGVycHJvcF9nZXRDcmVhdGVCdWNrZXQgPSAoKSA9PiBzdXBlci5jcmVhdGVCdWNrZXQsIF90aGlzID0gdGhpcztcblx0XHRyZXR1cm4gX3N1cGVycHJvcF9nZXRDcmVhdGVCdWNrZXQoKS5jYWxsKF90aGlzLCB2ZWN0b3JCdWNrZXROYW1lKTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogUmV0cmlldmVzIG1ldGFkYXRhIGZvciBhIHNwZWNpZmljIHZlY3RvciBidWNrZXRcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gdmVjdG9yQnVja2V0TmFtZSAtIE5hbWUgb2YgdGhlIHZlY3RvciBidWNrZXRcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggYnVja2V0IG1ldGFkYXRhIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC52ZWN0b3JzXG5cdCogICAuZ2V0QnVja2V0KCdlbWJlZGRpbmdzLXByb2QnKVxuXHQqXG5cdCogY29uc29sZS5sb2coJ0J1Y2tldCBjcmVhdGVkOicsIGRhdGE/LnZlY3RvckJ1Y2tldC5jcmVhdGlvblRpbWUpXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGdldEJ1Y2tldCh2ZWN0b3JCdWNrZXROYW1lKSB7XG5cdFx0dmFyIF9zdXBlcnByb3BfZ2V0R2V0QnVja2V0ID0gKCkgPT4gc3VwZXIuZ2V0QnVja2V0LCBfdGhpczIgPSB0aGlzO1xuXHRcdHJldHVybiBfc3VwZXJwcm9wX2dldEdldEJ1Y2tldCgpLmNhbGwoX3RoaXMyLCB2ZWN0b3JCdWNrZXROYW1lKTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogTGlzdHMgYWxsIHZlY3RvciBidWNrZXRzIHdpdGggb3B0aW9uYWwgZmlsdGVyaW5nIGFuZCBwYWdpbmF0aW9uXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBmaWx0ZXJzIChwcmVmaXgsIG1heFJlc3VsdHMsIG5leHRUb2tlbilcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggbGlzdCBvZiBidWNrZXRzIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC52ZWN0b3JzXG5cdCogICAubGlzdEJ1Y2tldHMoeyBwcmVmaXg6ICdlbWJlZGRpbmdzLScgfSlcblx0KlxuXHQqIGRhdGE/LnZlY3RvckJ1Y2tldHMuZm9yRWFjaChidWNrZXQgPT4ge1xuXHQqICAgY29uc29sZS5sb2coYnVja2V0LnZlY3RvckJ1Y2tldE5hbWUpXG5cdCogfSlcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgbGlzdEJ1Y2tldHMob3B0aW9ucyA9IHt9KSB7XG5cdFx0dmFyIF9zdXBlcnByb3BfZ2V0TGlzdEJ1Y2tldHMgPSAoKSA9PiBzdXBlci5saXN0QnVja2V0cywgX3RoaXMzID0gdGhpcztcblx0XHRyZXR1cm4gX3N1cGVycHJvcF9nZXRMaXN0QnVja2V0cygpLmNhbGwoX3RoaXMzLCBvcHRpb25zKTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogRGVsZXRlcyBhIHZlY3RvciBidWNrZXQgKGJ1Y2tldCBtdXN0IGJlIGVtcHR5KVxuXHQqIEFsbCBpbmRleGVzIG11c3QgYmUgZGVsZXRlZCBiZWZvcmUgZGVsZXRpbmcgdGhlIGJ1Y2tldFxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEBwYXJhbSB2ZWN0b3JCdWNrZXROYW1lIC0gTmFtZSBvZiB0aGUgdmVjdG9yIGJ1Y2tldCB0byBkZWxldGVcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggZW1wdHkgcmVzcG9uc2Ugb24gc3VjY2VzcyBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAudmVjdG9yc1xuXHQqICAgLmRlbGV0ZUJ1Y2tldCgnZW1iZWRkaW5ncy1vbGQnKVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBkZWxldGVCdWNrZXQodmVjdG9yQnVja2V0TmFtZSkge1xuXHRcdHZhciBfc3VwZXJwcm9wX2dldERlbGV0ZUJ1Y2tldCA9ICgpID0+IHN1cGVyLmRlbGV0ZUJ1Y2tldCwgX3RoaXM0ID0gdGhpcztcblx0XHRyZXR1cm4gX3N1cGVycHJvcF9nZXREZWxldGVCdWNrZXQoKS5jYWxsKF90aGlzNCwgdmVjdG9yQnVja2V0TmFtZSk7XG5cdH1cbn07XG4vKipcbipcbiogQGFscGhhXG4qXG4qIFNjb3BlZCBjbGllbnQgZm9yIG9wZXJhdGlvbnMgd2l0aGluIGEgc3BlY2lmaWMgdmVjdG9yIGJ1Y2tldFxuKiBQcm92aWRlcyBpbmRleCBtYW5hZ2VtZW50IGFuZCBhY2Nlc3MgdG8gdmVjdG9yIG9wZXJhdGlvbnNcbipcbiogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cbiovXG52YXIgVmVjdG9yQnVja2V0U2NvcGUgPSBjbGFzcyBleHRlbmRzIFZlY3RvckluZGV4QXBpIHtcblx0LyoqXG5cdCogQGFscGhhXG5cdCpcblx0KiBDcmVhdGVzIGEgaGVscGVyIHRoYXQgYXV0b21hdGljYWxseSBzY29wZXMgYWxsIGluZGV4IG9wZXJhdGlvbnMgdG8gdGhlIHByb3ZpZGVkIGJ1Y2tldC5cblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCBidWNrZXQgPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJylcblx0KiBgYGBcblx0Ki9cblx0Y29uc3RydWN0b3IodXJsLCBoZWFkZXJzLCB2ZWN0b3JCdWNrZXROYW1lLCBmZXRjaCQxKSB7XG5cdFx0c3VwZXIodXJsLCBoZWFkZXJzLCBmZXRjaCQxKTtcblx0XHR0aGlzLnZlY3RvckJ1Y2tldE5hbWUgPSB2ZWN0b3JCdWNrZXROYW1lO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBDcmVhdGVzIGEgbmV3IHZlY3RvciBpbmRleCBpbiB0aGlzIGJ1Y2tldFxuXHQqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGF1dG9tYXRpY2FsbHkgaW5jbHVkZXMgdGhlIGJ1Y2tldCBuYW1lXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBJbmRleCBjb25maWd1cmF0aW9uICh2ZWN0b3JCdWNrZXROYW1lIGlzIGF1dG9tYXRpY2FsbHkgc2V0KVxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBlbXB0eSByZXNwb25zZSBvbiBzdWNjZXNzIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCBidWNrZXQgPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJylcblx0KiBhd2FpdCBidWNrZXQuY3JlYXRlSW5kZXgoe1xuXHQqICAgaW5kZXhOYW1lOiAnZG9jdW1lbnRzLW9wZW5haScsXG5cdCogICBkYXRhVHlwZTogJ2Zsb2F0MzInLFxuXHQqICAgZGltZW5zaW9uOiAxNTM2LFxuXHQqICAgZGlzdGFuY2VNZXRyaWM6ICdjb3NpbmUnLFxuXHQqICAgbWV0YWRhdGFDb25maWd1cmF0aW9uOiB7XG5cdCogICAgIG5vbkZpbHRlcmFibGVNZXRhZGF0YUtleXM6IFsncmF3X3RleHQnXVxuXHQqICAgfVxuXHQqIH0pXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGNyZWF0ZUluZGV4KG9wdGlvbnMpIHtcblx0XHR2YXIgX3N1cGVycHJvcF9nZXRDcmVhdGVJbmRleCA9ICgpID0+IHN1cGVyLmNyZWF0ZUluZGV4LCBfdGhpczUgPSB0aGlzO1xuXHRcdHJldHVybiBfc3VwZXJwcm9wX2dldENyZWF0ZUluZGV4KCkuY2FsbChfdGhpczUsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBvcHRpb25zKSwge30sIHsgdmVjdG9yQnVja2V0TmFtZTogX3RoaXM1LnZlY3RvckJ1Y2tldE5hbWUgfSkpO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBMaXN0cyBpbmRleGVzIGluIHRoaXMgYnVja2V0XG5cdCogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgYXV0b21hdGljYWxseSBpbmNsdWRlcyB0aGUgYnVja2V0IG5hbWVcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gb3B0aW9ucyAtIExpc3Rpbmcgb3B0aW9ucyAodmVjdG9yQnVja2V0TmFtZSBpcyBhdXRvbWF0aWNhbGx5IHNldClcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBpbmRleGVzIGFycmF5IGFuZCBwYWdpbmF0aW9uIHRva2VuIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCBidWNrZXQgPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJylcblx0KiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGJ1Y2tldC5saXN0SW5kZXhlcyh7IHByZWZpeDogJ2RvY3VtZW50cy0nIH0pXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGxpc3RJbmRleGVzKG9wdGlvbnMgPSB7fSkge1xuXHRcdHZhciBfc3VwZXJwcm9wX2dldExpc3RJbmRleGVzID0gKCkgPT4gc3VwZXIubGlzdEluZGV4ZXMsIF90aGlzNiA9IHRoaXM7XG5cdFx0cmV0dXJuIF9zdXBlcnByb3BfZ2V0TGlzdEluZGV4ZXMoKS5jYWxsKF90aGlzNiwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG9wdGlvbnMpLCB7fSwgeyB2ZWN0b3JCdWNrZXROYW1lOiBfdGhpczYudmVjdG9yQnVja2V0TmFtZSB9KSk7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIFJldHJpZXZlcyBtZXRhZGF0YSBmb3IgYSBzcGVjaWZpYyBpbmRleCBpbiB0aGlzIGJ1Y2tldFxuXHQqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGF1dG9tYXRpY2FsbHkgaW5jbHVkZXMgdGhlIGJ1Y2tldCBuYW1lXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIGluZGV4TmFtZSAtIE5hbWUgb2YgdGhlIGluZGV4IHRvIHJldHJpZXZlXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIGluZGV4IG1ldGFkYXRhIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCBidWNrZXQgPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJylcblx0KiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGJ1Y2tldC5nZXRJbmRleCgnZG9jdW1lbnRzLW9wZW5haScpXG5cdCogY29uc29sZS5sb2coJ0RpbWVuc2lvbjonLCBkYXRhPy5pbmRleC5kaW1lbnNpb24pXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGdldEluZGV4KGluZGV4TmFtZSkge1xuXHRcdHZhciBfc3VwZXJwcm9wX2dldEdldEluZGV4ID0gKCkgPT4gc3VwZXIuZ2V0SW5kZXgsIF90aGlzNyA9IHRoaXM7XG5cdFx0cmV0dXJuIF9zdXBlcnByb3BfZ2V0R2V0SW5kZXgoKS5jYWxsKF90aGlzNywgX3RoaXM3LnZlY3RvckJ1Y2tldE5hbWUsIGluZGV4TmFtZSk7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIERlbGV0ZXMgYW4gaW5kZXggZnJvbSB0aGlzIGJ1Y2tldFxuXHQqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGF1dG9tYXRpY2FsbHkgaW5jbHVkZXMgdGhlIGJ1Y2tldCBuYW1lXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIGluZGV4TmFtZSAtIE5hbWUgb2YgdGhlIGluZGV4IHRvIGRlbGV0ZVxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBlbXB0eSByZXNwb25zZSBvbiBzdWNjZXNzIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCBidWNrZXQgPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJylcblx0KiBhd2FpdCBidWNrZXQuZGVsZXRlSW5kZXgoJ29sZC1pbmRleCcpXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGRlbGV0ZUluZGV4KGluZGV4TmFtZSkge1xuXHRcdHZhciBfc3VwZXJwcm9wX2dldERlbGV0ZUluZGV4ID0gKCkgPT4gc3VwZXIuZGVsZXRlSW5kZXgsIF90aGlzOCA9IHRoaXM7XG5cdFx0cmV0dXJuIF9zdXBlcnByb3BfZ2V0RGVsZXRlSW5kZXgoKS5jYWxsKF90aGlzOCwgX3RoaXM4LnZlY3RvckJ1Y2tldE5hbWUsIGluZGV4TmFtZSk7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIEFjY2VzcyBvcGVyYXRpb25zIGZvciBhIHNwZWNpZmljIGluZGV4IHdpdGhpbiB0aGlzIGJ1Y2tldFxuXHQqIFJldHVybnMgYSBzY29wZWQgY2xpZW50IGZvciB2ZWN0b3IgZGF0YSBvcGVyYXRpb25zXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIGluZGV4TmFtZSAtIE5hbWUgb2YgdGhlIGluZGV4XG5cdCogQHJldHVybnMgSW5kZXgtc2NvcGVkIGNsaWVudCB3aXRoIHZlY3RvciBkYXRhIG9wZXJhdGlvbnNcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGluZGV4ID0gc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpLmluZGV4KCdkb2N1bWVudHMtb3BlbmFpJylcblx0KlxuXHQqIC8vIEluc2VydCB2ZWN0b3JzXG5cdCogYXdhaXQgaW5kZXgucHV0VmVjdG9ycyh7XG5cdCogICB2ZWN0b3JzOiBbXG5cdCogICAgIHsga2V5OiAnZG9jLTEnLCBkYXRhOiB7IGZsb2F0MzI6IFsuLi5dIH0sIG1ldGFkYXRhOiB7IHRpdGxlOiAnSW50cm8nIH0gfVxuXHQqICAgXVxuXHQqIH0pXG5cdCpcblx0KiAvLyBRdWVyeSBzaW1pbGFyIHZlY3RvcnNcblx0KiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGluZGV4LnF1ZXJ5VmVjdG9ycyh7XG5cdCogICBxdWVyeVZlY3RvcjogeyBmbG9hdDMyOiBbLi4uXSB9LFxuXHQqICAgdG9wSzogNVxuXHQqIH0pXG5cdCogYGBgXG5cdCovXG5cdGluZGV4KGluZGV4TmFtZSkge1xuXHRcdHJldHVybiBuZXcgVmVjdG9ySW5kZXhTY29wZSh0aGlzLnVybCwgdGhpcy5oZWFkZXJzLCB0aGlzLnZlY3RvckJ1Y2tldE5hbWUsIGluZGV4TmFtZSwgdGhpcy5mZXRjaCk7XG5cdH1cbn07XG4vKipcbipcbiogQGFscGhhXG4qXG4qIFNjb3BlZCBjbGllbnQgZm9yIG9wZXJhdGlvbnMgd2l0aGluIGEgc3BlY2lmaWMgdmVjdG9yIGluZGV4XG4qIFByb3ZpZGVzIHZlY3RvciBkYXRhIG9wZXJhdGlvbnMgKHB1dCwgZ2V0LCBsaXN0LCBxdWVyeSwgZGVsZXRlKVxuKlxuKiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuKi9cbnZhciBWZWN0b3JJbmRleFNjb3BlID0gY2xhc3MgZXh0ZW5kcyBWZWN0b3JEYXRhQXBpIHtcblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIENyZWF0ZXMgYSBoZWxwZXIgdGhhdCBhdXRvbWF0aWNhbGx5IHNjb3BlcyBhbGwgdmVjdG9yIG9wZXJhdGlvbnMgdG8gdGhlIHByb3ZpZGVkIGJ1Y2tldC9pbmRleCBuYW1lcy5cblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCBpbmRleCA9IHN1cGFiYXNlLnN0b3JhZ2UudmVjdG9ycy5mcm9tKCdlbWJlZGRpbmdzLXByb2QnKS5pbmRleCgnZG9jdW1lbnRzLW9wZW5haScpXG5cdCogYGBgXG5cdCovXG5cdGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycywgdmVjdG9yQnVja2V0TmFtZSwgaW5kZXhOYW1lLCBmZXRjaCQxKSB7XG5cdFx0c3VwZXIodXJsLCBoZWFkZXJzLCBmZXRjaCQxKTtcblx0XHR0aGlzLnZlY3RvckJ1Y2tldE5hbWUgPSB2ZWN0b3JCdWNrZXROYW1lO1xuXHRcdHRoaXMuaW5kZXhOYW1lID0gaW5kZXhOYW1lO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBJbnNlcnRzIG9yIHVwZGF0ZXMgdmVjdG9ycyBpbiB0aGlzIGluZGV4XG5cdCogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgYXV0b21hdGljYWxseSBpbmNsdWRlcyBidWNrZXQgYW5kIGluZGV4IG5hbWVzXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBWZWN0b3IgaW5zZXJ0aW9uIG9wdGlvbnMgKGJ1Y2tldCBhbmQgaW5kZXggbmFtZXMgYXV0b21hdGljYWxseSBzZXQpXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIGVtcHR5IHJlc3BvbnNlIG9uIHN1Y2Nlc3Mgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGluZGV4ID0gc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpLmluZGV4KCdkb2N1bWVudHMtb3BlbmFpJylcblx0KiBhd2FpdCBpbmRleC5wdXRWZWN0b3JzKHtcblx0KiAgIHZlY3RvcnM6IFtcblx0KiAgICAge1xuXHQqICAgICAgIGtleTogJ2RvYy0xJyxcblx0KiAgICAgICBkYXRhOiB7IGZsb2F0MzI6IFswLjEsIDAuMiwgLi4uXSB9LFxuXHQqICAgICAgIG1ldGFkYXRhOiB7IHRpdGxlOiAnSW50cm9kdWN0aW9uJywgcGFnZTogMSB9XG5cdCogICAgIH1cblx0KiAgIF1cblx0KiB9KVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBwdXRWZWN0b3JzKG9wdGlvbnMpIHtcblx0XHR2YXIgX3N1cGVycHJvcF9nZXRQdXRWZWN0b3JzID0gKCkgPT4gc3VwZXIucHV0VmVjdG9ycywgX3RoaXM5ID0gdGhpcztcblx0XHRyZXR1cm4gX3N1cGVycHJvcF9nZXRQdXRWZWN0b3JzKCkuY2FsbChfdGhpczksIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBvcHRpb25zKSwge30sIHtcblx0XHRcdHZlY3RvckJ1Y2tldE5hbWU6IF90aGlzOS52ZWN0b3JCdWNrZXROYW1lLFxuXHRcdFx0aW5kZXhOYW1lOiBfdGhpczkuaW5kZXhOYW1lXG5cdFx0fSkpO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBSZXRyaWV2ZXMgdmVjdG9ycyBieSBrZXlzIGZyb20gdGhpcyBpbmRleFxuXHQqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGF1dG9tYXRpY2FsbHkgaW5jbHVkZXMgYnVja2V0IGFuZCBpbmRleCBuYW1lc1xuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEBwYXJhbSBvcHRpb25zIC0gVmVjdG9yIHJldHJpZXZhbCBvcHRpb25zIChidWNrZXQgYW5kIGluZGV4IG5hbWVzIGF1dG9tYXRpY2FsbHkgc2V0KVxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIHZlY3RvcnMgYXJyYXkgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGluZGV4ID0gc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpLmluZGV4KCdkb2N1bWVudHMtb3BlbmFpJylcblx0KiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGluZGV4LmdldFZlY3RvcnMoe1xuXHQqICAga2V5czogWydkb2MtMScsICdkb2MtMiddLFxuXHQqICAgcmV0dXJuTWV0YWRhdGE6IHRydWVcblx0KiB9KVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBnZXRWZWN0b3JzKG9wdGlvbnMpIHtcblx0XHR2YXIgX3N1cGVycHJvcF9nZXRHZXRWZWN0b3JzID0gKCkgPT4gc3VwZXIuZ2V0VmVjdG9ycywgX3RoaXMxMCA9IHRoaXM7XG5cdFx0cmV0dXJuIF9zdXBlcnByb3BfZ2V0R2V0VmVjdG9ycygpLmNhbGwoX3RoaXMxMCwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG9wdGlvbnMpLCB7fSwge1xuXHRcdFx0dmVjdG9yQnVja2V0TmFtZTogX3RoaXMxMC52ZWN0b3JCdWNrZXROYW1lLFxuXHRcdFx0aW5kZXhOYW1lOiBfdGhpczEwLmluZGV4TmFtZVxuXHRcdH0pKTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogTGlzdHMgdmVjdG9ycyBpbiB0aGlzIGluZGV4IHdpdGggcGFnaW5hdGlvblxuXHQqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGF1dG9tYXRpY2FsbHkgaW5jbHVkZXMgYnVja2V0IGFuZCBpbmRleCBuYW1lc1xuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEBwYXJhbSBvcHRpb25zIC0gTGlzdGluZyBvcHRpb25zIChidWNrZXQgYW5kIGluZGV4IG5hbWVzIGF1dG9tYXRpY2FsbHkgc2V0KVxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIHZlY3RvcnMgYXJyYXkgYW5kIHBhZ2luYXRpb24gdG9rZW4gb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGluZGV4ID0gc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpLmluZGV4KCdkb2N1bWVudHMtb3BlbmFpJylcblx0KiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGluZGV4Lmxpc3RWZWN0b3JzKHtcblx0KiAgIG1heFJlc3VsdHM6IDUwMCxcblx0KiAgIHJldHVybk1ldGFkYXRhOiB0cnVlXG5cdCogfSlcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgbGlzdFZlY3RvcnMob3B0aW9ucyA9IHt9KSB7XG5cdFx0dmFyIF9zdXBlcnByb3BfZ2V0TGlzdFZlY3RvcnMgPSAoKSA9PiBzdXBlci5saXN0VmVjdG9ycywgX3RoaXMxMSA9IHRoaXM7XG5cdFx0cmV0dXJuIF9zdXBlcnByb3BfZ2V0TGlzdFZlY3RvcnMoKS5jYWxsKF90aGlzMTEsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBvcHRpb25zKSwge30sIHtcblx0XHRcdHZlY3RvckJ1Y2tldE5hbWU6IF90aGlzMTEudmVjdG9yQnVja2V0TmFtZSxcblx0XHRcdGluZGV4TmFtZTogX3RoaXMxMS5pbmRleE5hbWVcblx0XHR9KSk7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIFF1ZXJpZXMgZm9yIHNpbWlsYXIgdmVjdG9ycyBpbiB0aGlzIGluZGV4XG5cdCogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgYXV0b21hdGljYWxseSBpbmNsdWRlcyBidWNrZXQgYW5kIGluZGV4IG5hbWVzXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBRdWVyeSBvcHRpb25zIChidWNrZXQgYW5kIGluZGV4IG5hbWVzIGF1dG9tYXRpY2FsbHkgc2V0KVxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIG1hdGNoZXMgYXJyYXkgb2Ygc2ltaWxhciB2ZWN0b3JzIG9yZGVyZWQgYnkgZGlzdGFuY2Ugb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGluZGV4ID0gc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpLmluZGV4KCdkb2N1bWVudHMtb3BlbmFpJylcblx0KiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGluZGV4LnF1ZXJ5VmVjdG9ycyh7XG5cdCogICBxdWVyeVZlY3RvcjogeyBmbG9hdDMyOiBbMC4xLCAwLjIsIC4uLl0gfSxcblx0KiAgIHRvcEs6IDUsXG5cdCogICBmaWx0ZXI6IHsgY2F0ZWdvcnk6ICd0ZWNobmljYWwnIH0sXG5cdCogICByZXR1cm5EaXN0YW5jZTogdHJ1ZSxcblx0KiAgIHJldHVybk1ldGFkYXRhOiB0cnVlXG5cdCogfSlcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgcXVlcnlWZWN0b3JzKG9wdGlvbnMpIHtcblx0XHR2YXIgX3N1cGVycHJvcF9nZXRRdWVyeVZlY3RvcnMgPSAoKSA9PiBzdXBlci5xdWVyeVZlY3RvcnMsIF90aGlzMTIgPSB0aGlzO1xuXHRcdHJldHVybiBfc3VwZXJwcm9wX2dldFF1ZXJ5VmVjdG9ycygpLmNhbGwoX3RoaXMxMiwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG9wdGlvbnMpLCB7fSwge1xuXHRcdFx0dmVjdG9yQnVja2V0TmFtZTogX3RoaXMxMi52ZWN0b3JCdWNrZXROYW1lLFxuXHRcdFx0aW5kZXhOYW1lOiBfdGhpczEyLmluZGV4TmFtZVxuXHRcdH0pKTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogRGVsZXRlcyB2ZWN0b3JzIGJ5IGtleXMgZnJvbSB0aGlzIGluZGV4XG5cdCogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgYXV0b21hdGljYWxseSBpbmNsdWRlcyBidWNrZXQgYW5kIGluZGV4IG5hbWVzXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBEZWxldGlvbiBvcHRpb25zIChidWNrZXQgYW5kIGluZGV4IG5hbWVzIGF1dG9tYXRpY2FsbHkgc2V0KVxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBlbXB0eSByZXNwb25zZSBvbiBzdWNjZXNzIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCBpbmRleCA9IHN1cGFiYXNlLnN0b3JhZ2UudmVjdG9ycy5mcm9tKCdlbWJlZGRpbmdzLXByb2QnKS5pbmRleCgnZG9jdW1lbnRzLW9wZW5haScpXG5cdCogYXdhaXQgaW5kZXguZGVsZXRlVmVjdG9ycyh7XG5cdCogICBrZXlzOiBbJ2RvYy0xJywgJ2RvYy0yJywgJ2RvYy0zJ11cblx0KiB9KVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBkZWxldGVWZWN0b3JzKG9wdGlvbnMpIHtcblx0XHR2YXIgX3N1cGVycHJvcF9nZXREZWxldGVWZWN0b3JzID0gKCkgPT4gc3VwZXIuZGVsZXRlVmVjdG9ycywgX3RoaXMxMyA9IHRoaXM7XG5cdFx0cmV0dXJuIF9zdXBlcnByb3BfZ2V0RGVsZXRlVmVjdG9ycygpLmNhbGwoX3RoaXMxMywgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG9wdGlvbnMpLCB7fSwge1xuXHRcdFx0dmVjdG9yQnVja2V0TmFtZTogX3RoaXMxMy52ZWN0b3JCdWNrZXROYW1lLFxuXHRcdFx0aW5kZXhOYW1lOiBfdGhpczEzLmluZGV4TmFtZVxuXHRcdH0pKTtcblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL1N0b3JhZ2VDbGllbnQudHNcbnZhciBTdG9yYWdlQ2xpZW50ID0gY2xhc3MgZXh0ZW5kcyBTdG9yYWdlQnVja2V0QXBpIHtcblx0LyoqXG5cdCogQ3JlYXRlcyBhIGNsaWVudCBmb3IgU3RvcmFnZSBidWNrZXRzLCBmaWxlcywgYW5hbHl0aWNzLCBhbmQgdmVjdG9ycy5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHRzXG5cdCogaW1wb3J0IHsgU3RvcmFnZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdG9yYWdlLWpzJ1xuXHQqXG5cdCogY29uc3Qgc3RvcmFnZSA9IG5ldyBTdG9yYWdlQ2xpZW50KCdodHRwczovL3h5emNvbXBhbnkuc3VwYWJhc2UuY28vc3RvcmFnZS92MScsIHtcblx0KiAgIGFwaWtleTogJ3B1YmxpYy1hbm9uLWtleScsXG5cdCogfSlcblx0KiBjb25zdCBhdmF0YXJzID0gc3RvcmFnZS5mcm9tKCdhdmF0YXJzJylcblx0KiBgYGBcblx0Ki9cblx0Y29uc3RydWN0b3IodXJsLCBoZWFkZXJzID0ge30sIGZldGNoJDEsIG9wdHMpIHtcblx0XHRzdXBlcih1cmwsIGhlYWRlcnMsIGZldGNoJDEsIG9wdHMpO1xuXHR9XG5cdC8qKlxuXHQqIFBlcmZvcm0gZmlsZSBvcGVyYXRpb24gaW4gYSBidWNrZXQuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIGlkIFRoZSBidWNrZXQgaWQgdG8gb3BlcmF0ZSBvbi5cblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGF2YXRhcnMgPSBzdXBhYmFzZS5zdG9yYWdlLmZyb20oJ2F2YXRhcnMnKVxuXHQqIGBgYFxuXHQqL1xuXHRmcm9tKGlkKSB7XG5cdFx0cmV0dXJuIG5ldyBTdG9yYWdlRmlsZUFwaSh0aGlzLnVybCwgdGhpcy5oZWFkZXJzLCBpZCwgdGhpcy5mZXRjaCk7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIEFjY2VzcyB2ZWN0b3Igc3RvcmFnZSBvcGVyYXRpb25zLlxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEByZXR1cm5zIEEgU3RvcmFnZVZlY3RvcnNDbGllbnQgaW5zdGFuY2UgY29uZmlndXJlZCB3aXRoIHRoZSBjdXJyZW50IHN0b3JhZ2Ugc2V0dGluZ3MuXG5cdCovXG5cdGdldCB2ZWN0b3JzKCkge1xuXHRcdHJldHVybiBuZXcgU3RvcmFnZVZlY3RvcnNDbGllbnQodGhpcy51cmwgKyBcIi92ZWN0b3JcIiwge1xuXHRcdFx0aGVhZGVyczogdGhpcy5oZWFkZXJzLFxuXHRcdFx0ZmV0Y2g6IHRoaXMuZmV0Y2hcblx0XHR9KTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogQWNjZXNzIGFuYWx5dGljcyBzdG9yYWdlIG9wZXJhdGlvbnMgdXNpbmcgSWNlYmVyZyB0YWJsZXMuXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IEFuYWx5dGljcyBCdWNrZXRzXG5cdCogQHJldHVybnMgQSBTdG9yYWdlQW5hbHl0aWNzQ2xpZW50IGluc3RhbmNlIGNvbmZpZ3VyZWQgd2l0aCB0aGUgY3VycmVudCBzdG9yYWdlIHNldHRpbmdzLlxuXHQqL1xuXHRnZXQgYW5hbHl0aWNzKCkge1xuXHRcdHJldHVybiBuZXcgU3RvcmFnZUFuYWx5dGljc0NsaWVudCh0aGlzLnVybCArIFwiL2ljZWJlcmdcIiwgdGhpcy5oZWFkZXJzLCB0aGlzLmZldGNoKTtcblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG5leHBvcnQgeyBTdG9yYWdlQW5hbHl0aWNzQ2xpZW50LCBTdG9yYWdlQXBpRXJyb3IsIFN0b3JhZ2VDbGllbnQsIFN0b3JhZ2VFcnJvciwgU3RvcmFnZVVua25vd25FcnJvciwgU3RvcmFnZVZlY3RvcnNBcGlFcnJvciwgU3RvcmFnZVZlY3RvcnNDbGllbnQsIFN0b3JhZ2VWZWN0b3JzRXJyb3IsIFN0b3JhZ2VWZWN0b3JzRXJyb3JDb2RlLCBTdG9yYWdlVmVjdG9yc1Vua25vd25FcnJvciwgVmVjdG9yQnVja2V0QXBpLCBWZWN0b3JCdWNrZXRTY29wZSwgVmVjdG9yRGF0YUFwaSwgVmVjdG9ySW5kZXhBcGksIFZlY3RvckluZGV4U2NvcGUsIGlzUGxhaW5PYmplY3QsIGlzU3RvcmFnZUVycm9yLCBpc1N0b3JhZ2VWZWN0b3JzRXJyb3IsIG5vcm1hbGl6ZVRvRmxvYXQzMiwgcmVzb2x2ZUZldGNoLCByZXNvbHZlUmVzcG9uc2UsIHZhbGlkYXRlVmVjdG9yRGltZW5zaW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbIkljZWJlcmdSZXN0Q2F0YWxvZyIsIlN0b3JhZ2VFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwiX19pc1N0b3JhZ2VFcnJvciIsIm5hbWUiLCJpc1N0b3JhZ2VFcnJvciIsImVycm9yIiwiU3RvcmFnZUFwaUVycm9yIiwic3RhdHVzIiwic3RhdHVzQ29kZSIsInRvSlNPTiIsIlN0b3JhZ2VVbmtub3duRXJyb3IiLCJvcmlnaW5hbEVycm9yIiwicmVzb2x2ZUZldGNoJDEiLCJjdXN0b21GZXRjaCIsImFyZ3MiLCJmZXRjaCIsInJlc29sdmVSZXNwb25zZSQxIiwiUmVzcG9uc2UiLCJyZWN1cnNpdmVUb0NhbWVsIiwiaXRlbSIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsImVsIiwiT2JqZWN0IiwicmVzdWx0IiwiZW50cmllcyIsImZvckVhY2giLCJrZXkiLCJ2YWx1ZSIsIm5ld0tleSIsInJlcGxhY2UiLCJjIiwidG9VcHBlckNhc2UiLCJpc1BsYWluT2JqZWN0JDEiLCJwcm90b3R5cGUiLCJnZXRQcm90b3R5cGVPZiIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwiaXRlcmF0b3IiLCJpc1ZhbGlkQnVja2V0TmFtZSIsImJ1Y2tldE5hbWUiLCJsZW5ndGgiLCJ0cmltIiwiaW5jbHVkZXMiLCJ0ZXN0IiwiX3R5cGVvZiIsIm8iLCJvJDEiLCJ0b1ByaW1pdGl2ZSIsInQiLCJyIiwiZSIsImkiLCJjYWxsIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiTnVtYmVyIiwidG9Qcm9wZXJ0eUtleSIsIl9kZWZpbmVQcm9wZXJ0eSIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwib3duS2V5cyIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJyJDEiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkMiIsImFyZ3VtZW50cyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX2dldEVycm9yTWVzc2FnZSQxIiwiZXJyIiwiX2VyciRlcnJvciIsIm1zZyIsImVycm9yX2Rlc2NyaXB0aW9uIiwiSlNPTiIsInN0cmluZ2lmeSIsImhhbmRsZUVycm9yJDEiLCJyZWplY3QiLCJvcHRpb25zIiwibm9SZXNvbHZlSnNvbiIsImpzb24iLCJ0aGVuIiwiY2F0Y2giLCJfZ2V0UmVxdWVzdFBhcmFtcyQxIiwibWV0aG9kIiwicGFyYW1ldGVycyIsImJvZHkiLCJwYXJhbXMiLCJoZWFkZXJzIiwiZHVwbGV4IiwiX2hhbmRsZVJlcXVlc3QkMSIsImZldGNoZXIiLCJ1cmwiLCJQcm9taXNlIiwicmVzb2x2ZSIsIm9rIiwiZGF0YSIsImdldCIsInBvc3QkMSIsInB1dCIsImhlYWQiLCJyZW1vdmUiLCJTdHJlYW1Eb3dubG9hZEJ1aWxkZXIiLCJkb3dubG9hZEZuIiwic2hvdWxkVGhyb3dPbkVycm9yIiwib25mdWxmaWxsZWQiLCJvbnJlamVjdGVkIiwiZXhlY3V0ZSIsIl90aGlzIiwiX1N5bWJvbCR0b1N0cmluZ1RhZyIsIkJsb2JEb3dubG9hZEJ1aWxkZXIiLCJwcm9taXNlIiwiYXNTdHJlYW0iLCJnZXRQcm9taXNlIiwiZmluYWxseSIsIm9uZmluYWxseSIsImJsb2IiLCJERUZBVUxUX1NFQVJDSF9PUFRJT05TIiwibGltaXQiLCJvZmZzZXQiLCJzb3J0QnkiLCJjb2x1bW4iLCJvcmRlciIsIkRFRkFVTFRfRklMRV9PUFRJT05TIiwiY2FjaGVDb250cm9sIiwiY29udGVudFR5cGUiLCJ1cHNlcnQiLCJTdG9yYWdlRmlsZUFwaSIsImJ1Y2tldElkIiwiZmV0Y2gkMSIsInRocm93T25FcnJvciIsInVwbG9hZE9yVXBkYXRlIiwicGF0aCIsImZpbGVCb2R5IiwiZmlsZU9wdGlvbnMiLCJtZXRhZGF0YSIsIkJsb2IiLCJGb3JtRGF0YSIsImFwcGVuZCIsImVuY29kZU1ldGFkYXRhIiwiaGFzIiwidG9CYXNlNjQiLCJSZWFkYWJsZVN0cmVhbSIsInBpcGUiLCJjbGVhblBhdGgiLCJfcmVtb3ZlRW1wdHlGb2xkZXJzIiwiX3BhdGgiLCJfZ2V0RmluYWxQYXRoIiwiaWQiLCJJZCIsImZ1bGxQYXRoIiwiS2V5IiwidXBsb2FkIiwidXBsb2FkVG9TaWduZWRVcmwiLCJ0b2tlbiIsIl90aGlzMyIsIlVSTCIsInNlYXJjaFBhcmFtcyIsInNldCIsInRvU3RyaW5nIiwiY3JlYXRlU2lnbmVkVXBsb2FkVXJsIiwiX3RoaXM0Iiwic2lnbmVkVXJsIiwidXBkYXRlIiwibW92ZSIsImZyb21QYXRoIiwidG9QYXRoIiwiX3RoaXM2Iiwic291cmNlS2V5IiwiZGVzdGluYXRpb25LZXkiLCJkZXN0aW5hdGlvbkJ1Y2tldCIsImNvcHkiLCJfdGhpczciLCJjcmVhdGVTaWduZWRVcmwiLCJleHBpcmVzSW4iLCJfdGhpczgiLCJ0cmFuc2Zvcm0iLCJkb3dubG9hZFF1ZXJ5UGFyYW0iLCJkb3dubG9hZCIsImVuY29kZVVSSSIsInNpZ25lZFVSTCIsImNyZWF0ZVNpZ25lZFVybHMiLCJwYXRocyIsIl90aGlzOSIsImRhdHVtIiwicmVuZGVyUGF0aCIsInRyYW5zZm9ybWF0aW9uUXVlcnkiLCJ0cmFuc2Zvcm1PcHRzVG9RdWVyeVN0cmluZyIsInF1ZXJ5U3RyaW5nIiwiaW5mbyIsIl90aGlzMTAiLCJleGlzdHMiLCJfdGhpczExIiwiZ2V0UHVibGljVXJsIiwiX3F1ZXJ5U3RyaW5nIiwiam9pbiIsInB1YmxpY1VybCIsIl90aGlzMTIiLCJwcmVmaXhlcyIsImxpc3QiLCJfdGhpczEzIiwicHJlZml4IiwibGlzdFYyIiwiX3RoaXMxNCIsIkJ1ZmZlciIsImZyb20iLCJidG9hIiwid2lkdGgiLCJoZWlnaHQiLCJyZXNpemUiLCJmb3JtYXQiLCJxdWFsaXR5IiwidmVyc2lvbiIsIkRFRkFVTFRfSEVBREVSUyQxIiwiU3RvcmFnZUJ1Y2tldEFwaSIsIm9wdHMiLCJiYXNlVXJsIiwidXNlTmV3SG9zdG5hbWUiLCJob3N0bmFtZSIsImhyZWYiLCJsaXN0QnVja2V0cyIsImxpc3RCdWNrZXRPcHRpb25zVG9RdWVyeVN0cmluZyIsImdldEJ1Y2tldCIsIl90aGlzMiIsImNyZWF0ZUJ1Y2tldCIsInB1YmxpYyIsInR5cGUiLCJmaWxlX3NpemVfbGltaXQiLCJmaWxlU2l6ZUxpbWl0IiwiYWxsb3dlZF9taW1lX3R5cGVzIiwiYWxsb3dlZE1pbWVUeXBlcyIsInVwZGF0ZUJ1Y2tldCIsImVtcHR5QnVja2V0IiwiX3RoaXM1IiwiZGVsZXRlQnVja2V0Iiwic2VhcmNoIiwic29ydENvbHVtbiIsInNvcnRPcmRlciIsIlVSTFNlYXJjaFBhcmFtcyIsIlN0b3JhZ2VBbmFseXRpY3NDbGllbnQiLCJxdWVyeVBhcmFtcyIsImNhdGFsb2ciLCJjYXRhbG9nTmFtZSIsImF1dGgiLCJnZXRIZWFkZXJzIiwiUHJveHkiLCJ0YXJnZXQiLCJwcm9wIiwiREVGQVVMVF9IRUFERVJTIiwiU3RvcmFnZVZlY3RvcnNFcnJvciIsIl9faXNTdG9yYWdlVmVjdG9yc0Vycm9yIiwiaXNTdG9yYWdlVmVjdG9yc0Vycm9yIiwiU3RvcmFnZVZlY3RvcnNBcGlFcnJvciIsIlN0b3JhZ2VWZWN0b3JzVW5rbm93bkVycm9yIiwiU3RvcmFnZVZlY3RvcnNFcnJvckNvZGUiLCJTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSQxIiwicmVzb2x2ZUZldGNoIiwicmVzb2x2ZVJlc3BvbnNlIiwiaXNQbGFpbk9iamVjdCIsIm5vcm1hbGl6ZVRvRmxvYXQzMiIsInZhbHVlcyIsIkZsb2F0MzJBcnJheSIsInZhbGlkYXRlVmVjdG9yRGltZW5zaW9uIiwidmVjdG9yIiwiZXhwZWN0ZWREaW1lbnNpb24iLCJmbG9hdDMyIiwiX2dldEVycm9yTWVzc2FnZSIsImhhbmRsZUVycm9yIiwicmVzcG9uc2VFcnJvciIsImNvZGUiLCJzdGF0dXNUZXh0IiwiX2dldFJlcXVlc3RQYXJhbXMiLCJfaGFuZGxlUmVxdWVzdCIsInBvc3QiLCJWZWN0b3JJbmRleEFwaSIsImNyZWF0ZUluZGV4IiwiZ2V0SW5kZXgiLCJ2ZWN0b3JCdWNrZXROYW1lIiwiaW5kZXhOYW1lIiwibGlzdEluZGV4ZXMiLCJkZWxldGVJbmRleCIsIlZlY3RvckRhdGFBcGkiLCJwdXRWZWN0b3JzIiwidmVjdG9ycyIsImdldFZlY3RvcnMiLCJsaXN0VmVjdG9ycyIsInNlZ21lbnRDb3VudCIsInNlZ21lbnRJbmRleCIsInF1ZXJ5VmVjdG9ycyIsImRlbGV0ZVZlY3RvcnMiLCJWZWN0b3JCdWNrZXRBcGkiLCJTdG9yYWdlVmVjdG9yc0NsaWVudCIsIlZlY3RvckJ1Y2tldFNjb3BlIiwiX3N1cGVycHJvcF9nZXRDcmVhdGVCdWNrZXQiLCJfc3VwZXJwcm9wX2dldEdldEJ1Y2tldCIsIl9zdXBlcnByb3BfZ2V0TGlzdEJ1Y2tldHMiLCJfc3VwZXJwcm9wX2dldERlbGV0ZUJ1Y2tldCIsIl9zdXBlcnByb3BfZ2V0Q3JlYXRlSW5kZXgiLCJfc3VwZXJwcm9wX2dldExpc3RJbmRleGVzIiwiX3N1cGVycHJvcF9nZXRHZXRJbmRleCIsIl9zdXBlcnByb3BfZ2V0RGVsZXRlSW5kZXgiLCJpbmRleCIsIlZlY3RvckluZGV4U2NvcGUiLCJfc3VwZXJwcm9wX2dldFB1dFZlY3RvcnMiLCJfc3VwZXJwcm9wX2dldEdldFZlY3RvcnMiLCJfc3VwZXJwcm9wX2dldExpc3RWZWN0b3JzIiwiX3N1cGVycHJvcF9nZXRRdWVyeVZlY3RvcnMiLCJfc3VwZXJwcm9wX2dldERlbGV0ZVZlY3RvcnMiLCJTdG9yYWdlQ2xpZW50IiwiYW5hbHl0aWNzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@supabase+storage-js@2.91.0/node_modules/@supabase/storage-js/dist/index.mjs\n");

/***/ })

};
;