import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { encrypt, decrypt } from "@/lib/encryption";

export const runtime = "nodejs";

export async function GET(req: NextRequest) {
    const searchParams = req.nextUrl.searchParams;
    const code = searchParams.get("code");
    const state = searchParams.get("state");
    const error = searchParams.get("error");

    if (error || !code || !state) {
        return NextResponse.redirect(new URL('/settings/integracoes?error=access_denied', req.url));
    }

    try {
        const stateData = JSON.parse(decrypt(state));
        // Verify nonce if we stored it, but encryption ensures it was generated by us.
        const { workspaceId } = stateData;

        // Exchange code for token
        const appId = process.env.IG_APP_ID!;
        const appSecret = process.env.IG_APP_SECRET!;
        const redirectUri = process.env.IG_REDIRECT_URI!;

        const formData = new URLSearchParams();
        formData.append('client_id', appId);
        formData.append('client_secret', appSecret);
        formData.append('grant_type', 'authorization_code');
        formData.append('redirect_uri', redirectUri);
        formData.append('code', code);

        const tokenRes = await fetch('https://api.instagram.com/oauth/access_token', {
            method: 'POST',
            body: formData,
        });

        const tokenData = await tokenRes.json();

        if (!tokenRes.ok) {
            console.error('IG Token Error', tokenData);
            throw new Error(tokenData.error_message || "Failed to exchange token");
        }

        // Response: { access_token, user_id }
        // Now we need to get the long-lived token?
        // "Instagram Login" tokens are already long-lived (60 days)? Or need exchange?
        // Documentation says for Instagram Login: they are short-lived (1 hour). Need to exchange for long-lived.

        // Exchange for long-lived
        const longLivedRes = await fetch(`https://graph.instagram.com/access_token?grant_type=ig_exchange_token&client_secret=${appSecret}&access_token=${tokenData.access_token}`);
        const longLivedData = await longLivedRes.json();

        const finalAccessToken = longLivedData.access_token || tokenData.access_token;
        const expiresSeconds = longLivedData.expires_in || 3600;
        const expiresAt = new Date(Date.now() + expiresSeconds * 1000);

        // Get User Profile (to get username and profile pic)
        // endpoint: https://graph.instagram.com/v11.0/me?fields=id,username,profile_picture_url&access_token=...
        const meRes = await fetch(`https://graph.instagram.com/v21.0/me?fields=id,username,profile_picture_url&access_token=${finalAccessToken}`);
        const meData = await meRes.json();

        if (!meRes.ok) {
            // If this fails, maybe scopes are wrong or user is not business
            console.error('IG Me Error', meData);
            // Continue but with warning? or fail?
        }

        const igUserId = meData.id || tokenData.user_id;

        // Store in DB
        await prisma.instagramAccount.upsert({
            where: {
                workspaceId_igUserId: {
                    workspaceId,
                    igUserId: String(igUserId)
                }
            },
            update: {
                username: meData.username || 'Linked Account',
                profilePicUrl: meData.profile_picture_url || '',
                status: 'CONNECTED',
                accessTokenEncrypted: encrypt(finalAccessToken),
                tokenExpiresAt: expiresAt,
                updatedAt: new Date(),
            },
            create: {
                workspaceId,
                igUserId: String(igUserId),
                username: meData.username || 'Linked Account',
                profilePicUrl: meData.profile_picture_url || '',
                status: 'CONNECTED',
                accessTokenEncrypted: encrypt(finalAccessToken),
                tokenExpiresAt: expiresAt
            }
        });

        return NextResponse.redirect(new URL('/settings/integracoes?success=true', req.url));

    } catch (err) {
        console.error(err);
        return NextResponse.redirect(new URL('/settings/integracoes?error=server_error', req.url));
    }
}
