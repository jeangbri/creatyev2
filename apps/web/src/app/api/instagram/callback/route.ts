// Test URL: /api/instagram/callback?hub.mode=subscribe&hub.verify_token=creatye_verify_token&hub.challenge=123456
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { encrypt, decrypt } from "@/lib/encryption";
import { processInstagramEvent } from "@/lib/instagram-service";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";

export async function GET(req: NextRequest) {
    const searchParams = req.nextUrl.searchParams;

    // --- Webhook Verification Logic ---
    const mode = searchParams.get("hub.mode");
    const token = searchParams.get("hub.verify_token");
    const challenge = searchParams.get("hub.challenge");

    if (mode === "subscribe") {
        if (token === process.env.IG_VERIFY_TOKEN && challenge) {
            return new NextResponse(challenge, {
                status: 200,
                headers: { "content-type": "text/plain; charset=utf-8" },
            });
        }
        return new NextResponse("Forbidden", { status: 403 });
    }
    // ----------------------------------

    const code = searchParams.get("code");
    const state = searchParams.get("state");
    const error = searchParams.get("error");

    if (error || !code || !state) {
        return NextResponse.redirect(new URL('/settings/integracoes?error=access_denied', req.url));
    }

    try {
        const stateData = JSON.parse(decrypt(state));
        // Verify nonce if we stored it, but encryption ensures it was generated by us.
        const { workspaceId } = stateData;

        // Exchange code for token
        const appId = process.env.IG_APP_ID!;
        const appSecret = process.env.IG_APP_SECRET!;
        const redirectUri = process.env.IG_REDIRECT_URI!;

        const formData = new URLSearchParams();
        formData.append('client_id', appId);
        formData.append('client_secret', appSecret);
        formData.append('grant_type', 'authorization_code');
        formData.append('redirect_uri', redirectUri);
        formData.append('code', code);

        const tokenRes = await fetch('https://api.instagram.com/oauth/access_token', {
            method: 'POST',
            body: formData,
        });

        const tokenData = await tokenRes.json();

        if (!tokenRes.ok) {
            console.error('IG Token Error', tokenData);
            throw new Error(tokenData.error_message || "Failed to exchange token");
        }

        console.log('[IG Callback] Token exchanged successfully.');

        // Response: { access_token, user_id }

        // Exchange for long-lived
        const longLivedRes = await fetch(`https://graph.instagram.com/access_token?grant_type=ig_exchange_token&client_secret=${appSecret}&access_token=${tokenData.access_token}`);
        const longLivedData = await longLivedRes.json();

        console.log('[IG Callback] Long-lived token fetched.');

        const finalAccessToken = longLivedData.access_token || tokenData.access_token;
        const expiresSeconds = longLivedData.expires_in || 3600;
        const expiresAt = new Date(Date.now() + expiresSeconds * 1000);

        // Get User Profile (to get username and profile pic)
        // endpoint: https://graph.instagram.com/v11.0/me?fields=id,username,profile_picture_url&access_token=...
        const meRes = await fetch(`https://graph.instagram.com/v21.0/me?fields=id,username,profile_picture_url&access_token=${finalAccessToken}`);
        const meData = await meRes.json();

        console.log('[IG Callback] Me Data fetched:', meData);

        if (!meRes.ok) {
            console.error('[IG Callback] Me Error', meData);
        }

        const igUserId = meData.id || tokenData.user_id;

        console.log(`[IG Callback] Saving account. Workspace: ${workspaceId}, IG User ID: ${igUserId}`);

        // Store in DB
        const result = await prisma.instagramAccount.upsert({
            where: {
                workspaceId_igUserId: {
                    workspaceId,
                    igUserId: String(igUserId)
                }
            },
            update: {
                username: meData.username || 'Linked Account',
                profilePicUrl: meData.profile_picture_url || '',
                status: 'CONNECTED',
                accessTokenEncrypted: encrypt(finalAccessToken),
                tokenExpiresAt: expiresAt,
                updatedAt: new Date(),
            },
            create: {
                workspaceId,
                igUserId: String(igUserId),
                username: meData.username || 'Linked Account',
                profilePicUrl: meData.profile_picture_url || '',
                status: 'CONNECTED',
                accessTokenEncrypted: encrypt(finalAccessToken),
                tokenExpiresAt: expiresAt
            }
        });

        console.log('[IG Callback] Account saved successfully:', result.id);

        return NextResponse.redirect(new URL('/settings/integracoes?success=true', req.url));

    } catch (err) {
        console.error('[IG Callback] CRITICAL ERROR:', err);
        return NextResponse.redirect(new URL('/settings/integracoes?error=server_error', req.url));
    }
}

export async function POST(req: NextRequest) {
    try {
        const body = await req.json();
        const signature = req.headers.get("x-hub-signature-256");

        // Process event (awaiting to ensure completion for MVP)
        // In production, this should be offloaded to a queue.
        await processInstagramEvent(body, signature);

        return NextResponse.json({ ok: true });
    } catch (e) {
        console.error("Webhook POST Error", e);
        return NextResponse.json({ ok: false }, { status: 500 });
    }
}
